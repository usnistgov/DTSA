{[j=20/30]}   {[f-]} {*********************************} UNIT Utilities ;{*********************************}{**********************************} INTERFACE {**********************************} USES  QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Retrace, SegLoad, Events,   Packages, Printing, StandardFile, fenv, fp {SANE}, {StrLib,} PasLibIntf, TextUtils, Controls, Dialogs, Windows, Finder, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Physics, {Physics_Windows,} xray;  {[f+]} 	       PROCEDURE wait(Ticks: Longint);    FUNCTION  GetReal(message: Str255; default: real): real;    PROCEDURE WorkSpectrum_To_Disk(sp_number : integer);        FUNCTION  ShiftKeyDown: boolean;    FUNCTION  CommandPeriod: boolean;    FUNCTION ControlKeyDown : Boolean;     FUNCTION F1Down : Boolean;	FUNCTION F2Down : Boolean;	FUNCTION F3Down : Boolean;	FUNCTION F4Down : Boolean;	FUNCTION F5Down : Boolean;	FUNCTION F6Down : Boolean;	FUNCTION F7Down : Boolean;	FUNCTION F8Down : Boolean;	FUNCTION F9Down : Boolean;	FUNCTION F10Down : Boolean;	FUNCTION F11Down : Boolean;	FUNCTION F12Down : Boolean;	FUNCTION F13Down : Boolean;	FUNCTION F14Down : Boolean;	FUNCTION F15Down : Boolean;	FUNCTION NKPZeroDown : Boolean;	FUNCTION NKP2Down : Boolean;	FUNCTION NKP8Down : Boolean;	FUNCTION NKP4Down : Boolean;	FUNCTION NKP6Down : Boolean;	FUNCTION G6_Del_Down : Boolean;	FUNCTION G6_End_Down : Boolean;	FUNCTION G6_PgDn_Down : Boolean;	 	FUNCTION EscDown : Boolean;	FUNCTION SpaceBarDown : Boolean;	FUNCTION NKPClearDown : Boolean;	FUNCTION NKPEqualDown : Boolean;	FUNCTION CapsLockDown : Boolean;	FUNCTION RtnDown : Boolean;  {  FUNCTION OptionKeyDown : Boolean;}	{move to global_functions}  	    FUNCTION  Interrupted: boolean;         FUNCTION CreateFile(VAR FM: fnamestr; Prompt: str255): boolean;    FUNCTION GetFileName(VAR FJ: fnamestr; 	                      VAR theType1, theType2: OsType; 						  VAR Prompt: Str255): boolean;    PROCEDURE D_ASCII_FORMAT;    PROCEDURE PrintStuff;        PROCEDURE D_WDS;				       PROCEDURE D_Spectrum_Picker;    PROCEDURE Profile(VAR EStart, ChKv       :  real {double_t}; 	                  VAR ESet,ASet,SigSet   : PKARY; 					  VAR NumGauss,NumChs    : integer; 					  VAR GaussOut           : WindowArray ) ;		 		  { ¥¥¥ below are in mca.a ¥¥¥ }  (*  PROCEDURE zNGauss( VAR EStart,ChKv       : double_t; 	                  VAR ESet,ASet,SigSet  : PKARY; 					  VAR NumGauss,NumChs   : integer; 					  VAR GaussOut          : WindowArray ); *)					      PROCEDURE aNGauss( VAR EStart,ChKv       :  real {double_t}; 	                  VAR ESet,ASet,SigSet  : PKARY; 					  VAR NumGauss,NumChs   : integer; 					  VAR GaussOut          : WindowArray ); 					      PROCEDURE aTOPHAT( VAR  arrayin,  		                   arrayout      : WindowArray ;{ calculated stuff goes in so pass double_t}					  VAR  npoints, filtersize   : integer);           { in MCA.a } 					   	   (* PROCEDURE TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT); 		PROCEDURE VAX_TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT); 	PROCEDURE VAX_TCnvtMacInt(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT); *)	PROCEDURE Get_WDInfo(VAR VName:str31; VAR DirID:longint; VAR VNum:integer);	PROCEDURE Get_CreationDate(VAR aFilename:fnamestr; VAR aDirID:longint; VAR aVNum:integer);    FUNCTION  DTRec2Str:str255;									IMPLEMENTATION {$S Utilities}				  			   (* PROCEDURE aNGauss( VAR EStart,ChKv:double_t; 	                  VAR ESet,ASet,SigSet: PKARY; 					  VAR NumGauss,NumChs:integer; 					  VAR GaussOut:WindowArray{double_t});       EXTERNAL; *)      (* PROCEDURE aTOPHAT( VAR  arrayin,  		                   arrayout      : WindowArray{double_t};{ calculated stuff goes in so pass double_t}					  VAR  npoints, filtersize   : integer);      EXTERNAL;   *)      { in MCA.a } 					   	  (* PROCEDURE TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;		PROCEDURE VAX_TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;	PROCEDURE VAX_TCnvtMacInt(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;*)										  	TYPE                KeyPtrType                    = ^KeyMap;  	      VAR			List_I_Spectra                : ListHandle;			  PROCEDURE Remond (VAR Y: {real} double_t; FWHM, Centroid, Amplitude, Energy: {real} double_t) ;        VAR      Term, HWHM, Lamda		: {real} double_t;    BEGIN      Lamda := 12398.0 / Energy;      HWHM := FWHM / 2;   { J := -8.7E-3*exp(-0.34*Lamda);         HWHMg := 8.06E-2*2*exp(-2.4*(J+Lamda)) ;    Ag := Amplitude*2930*exp(-3.6*Lamda);   }      Term := (Energy - Centroid) / HWHM;      Term := Term * Term;      Y := one_Coeff * Amplitude * exp( - ln2 * Term) + (1 - one_Coeff) * Amplitude * (1 / (1 + Term)) {+ Ag*exp(-ln2 *             (J/HWHMg * J/HWHMg)) } ;    END; {Remond}(*  ¥¥¥¥¥¥ converted to assembly starting from this code  *)        PROCEDURE atophat{(VAR arrayin  ,  		                      arrayout : WindowArray ; 						  VAR npoints, filtersize  : integer)};        { on exit, the first npoints-filtersize chs of arrayout will have filtered data }          VAR            nn, mid,ncntr, nstrt, nend, side, center, filter, ntofil, nside: integer;            sumsl, sumcl, savesum                 : {real} double_t;          BEGIN	{procedure tophat}		 { putmessage('in tophat','','','');}			for nn := 1 to Max_Fitting_Chans do arrayout[nn] := zero;            ntofil := npoints - filtersize;            arrayout[1] := arrayin[1];                { Fits...has data for the first call}			{Cummulative sum:}            FOR nn := 2 TO npoints DO arrayout[nn] := arrayout[nn-1] + arrayin[nn];			{filtersize does not include the ch being filtered}            nside := filtersize DIV 4;     { # chs in side lobe of filter }            mid := nside * 2;              { # chs in center lobe, not counting the one being filtered }            ncntr := mid + 1;              {# chs incntrt lobe + filter ch }            nend := npoints - mid;      { the last ch that can be filtered }            {apply the filter over the chs of interest in the array}            side := nside;            { # of 1st array element with sum prec. cntr lobe }            center := 3 * nside + 1;  { # of 1st array el with sum including center lobe }            filter := filtersize + 1; { # of 1st array element with sum of filter chs and ncntr}            nstrt := mid + 1;         { # of the first ch that can be filtered }			{sum over side lobes}			sumsl := arrayout[side] + (arrayout[filter] - arrayout[center]);			{sum over center lobe not including ch nstrt}			sumcl := arrayout[center] - arrayout[side];			savesum := arrayout[1];	{put the result here so save the sum stored here}            arrayout[1]:= (sumcl - sumsl - arrayin[nstrt]) / ncntr; { the first ntofil chs of arrayout has }            FOR nn := 2 TO ntofil DO              BEGIN				side := side + 1; 				center := center + 1;				filter := filter + 1; 				nstrt := nstrt + 1;                sumsl := (arrayout[side] - savesum) + (arrayout[filter] - arrayout[center]);                sumcl := arrayout[center] - arrayout[side];				savesum := arrayout[nn];	{ arrayout is the running sum to nn}                arrayout[nn] := (sumcl - sumsl - arrayin[nstrt]) / ncntr; { the first ntofil chs of arrayout has }                                                             { results }              END;                                    {for nn}          END;                                        {procedure tophat}       (*          The assembly code is a little over 3 times faster than the Pascal  *) 	 PROCEDURE aNGauss  ; { (VAR EStart,ChKv:double_t; VAR ESet,ASet,SigSet: PKARRAY_ptr ; VAR                  NumGauss,NumChs:integer; VAR GaussOut:WindowArray);}         VAR        Energy, dele, arg: {real} double_t;        kk, jj:             Integer;      BEGIN                  {PROCEDURE NGauss}           {   calculate the  sum of gaussians at each channel -               array GaussOut[n] will have sum at each ch of all gaussians and incomplete chg               for the window + filter chs at each end }	    {debugstr('begin NGauss');}		        FOR jj := 1 TO NumChs DO GaussOut[jj] := 0.0;		{debugstr('zero`ed GaussOut');}         FOR kk := 1 TO NumGauss DO BEGIN          arg := - 0.5 / (sigSet[kk] * sigSet[kk]);          Energy := EStart;  { energy in kev of 1st ch in window inc filter chs }          FOR jj := 1 TO NumChs DO BEGIN            dele := Energy - ESet[kk];            GaussOut[jj] := GaussOut[jj] + ASet[kk] * (EXP(dele * dele * arg));            Energy := Energy + ChKv;          END;               { for jj }        END;                 { for kk }      END;                   {PROCEDURE NGauss}     PROCEDURE Profile (*( EStart,ChKv        : double_t; 	                   ESet,ASet,SigSet      : PKARY{ }; 					  VAR NumGauss,NumChs    : integer; 					  VAR GaussOut           : WindowArray {double_t})  *)   ;					        VAR        Energy, sig			            	 : {real} double_t;        kk, jj                               : Integer;         Y, centroid, amp                    : {real} double_t;		       BEGIN  	          if Si_Active then { SiLi detector }	     BEGIN	{	jj := NumChs DIV 2;		realTOSTRING(GaussOut[JJ],10,4,STR3);		realTOSTRING(ESet[1],10,4,STR1);		realTOSTRING(ASet[1],10,4,STR2);		numtostring(jj,str4);		str := concat('before: Energy = ',str1,' ampl = ',str2,' output = ',str3,' for chan ',str4);		debugstr(str);}		  		 aNGauss( EStart,		         ChKv, 	             ESet,		         ASet,		         SigSet, 				 NumGauss,				 NumChs, 				 GaussOut);  				 	{	jj := NumChs DIV 2;		realTOSTRING(GaussOut[JJ],10,4,STR3);		realTOSTRING(ESet[1],10,4,STR1);		realTOSTRING(ASet[1],10,4,STR2);		numtostring(jj,str4);		str := concat('After: Energy = ',str1,' ampl = ',str2,' output = ',str3,' for chan ',str4);		debugstr(str);}		END        else if WDS_Active then  { WDS detector }         begin		   FOR jj := 1 TO NumChs DO GaussOut[jj] := Zero;   			 Energy := EStart;  { energy in kev of 1st ch in window inc filter chs }			 FOR jj := 1 TO NumChs DO BEGIN			   FOR kk := 1 TO NumGauss DO BEGIN			     Sig := 2355.0*SigSet[kk]; { convert sig in keV to FWHM in eV }                 centroid := ESet[kk]*1000;				 amp := ASet[kk];				 			   Remond (Y, Sig, centroid, amp, Energy*1000  ) ;			    GaussOut[jj] := Y + GaussOut[jj]; 										 										 			   END;               { for kk }			   Energy := Energy + ChKv;			 END;                 { for jj }         end	  else if Ge_Active then            begin		 aNGauss( EStart,		         ChKv, 	             ESet,		         ASet,		         SigSet, 				 NumGauss,				 NumChs, 				 GaussOut)           end;      END;                   {PROCEDURE Profile} PROCEDURE WorkSpectrum_To_Disk{(sp_number)}; VAR 	 errCode 					: OSErr;	 bytecount 					: Longint;	 index1,ChsinSpec 			: Integer;	 dEinSpec					: real;	 str1,str2, defName   		: str255;	 Outreply					: StandardFileReply;	 ref_typ					: ARRAY [0..3] of OSType;	sfPtr                       : ConstSFTypeListPtr;	savename                     : fnamestr;	savevol         			 : integer;	save_dirID					 : longint;	 BEGIN              IF SpecWork_has_been_Changed THEN              BEGIN {if SpecWork_has_been_Changed...}                  IF (NOT save_work_open) THEN                  BEGIN                      IF answermessage('You have not specified a file for saving the spectrum.',					  			 'If IT`S OK I`ll let you pick an old file to append.',                                 'If IT`S NOT OK, to start a NEW spectrum file', 								 'go to FILE and select "Save DTSA spectrum to Disk".')                      then begin					    mytype := 'MCAf';                        myprompt := 'AppendwWORK to...';					  defName := 'Spectrum.Dat';        { the user's choice replaces this }					  ref_typ[0] :=  mytype; 					  sfPtr := @ref_typ;					  StandardGetFile(NIL, 1, sfPtr, Outreply);		{¥¥New DTSA file spec¥¥}					  File_Cancel_Button := Outreply.sfGood;					  if NOT Outreply.sfGood Then exit(WorkSpectrum_To_Disk);					  Write_DTSA_Spec := Outreply.sfFile;					  InVol_volnum := Write_DTSA_Spec.vRefNum;					  InVol_DirID := Write_DTSA_Spec.parID;					  					  {The volume names in the folowing calls are all StringPtr}					  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}					  errcode := HSetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}					  errcode := HGetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}					  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}					                          IF (NOT File_Cancel_Button) THEN                        BEGIN                          Hilitecontrol(SiLi_Control, 0); {Lighten the button before exit}                          exit(WorkSpectrum_To_Disk);                        END                        ELSE                        BEGIN                          save_work_open := True;                          Binary_VolNum_Write := In_VolRefNum;                        END;					 end	{IF answermessage...}					 else exit(WorkSpectrum_To_Disk); { if not answermessage...}                 END; { If (not save_work_open)...}                  IF ((save_work_open) and				     ((not demo_DTSA) or (Plt_Spec[sp_number]^^.SpectrumStuff.spectrum_Info.spare2))) THEN                    BEGIN					  ChsinSpec := Plt_spec[sp_number]^^.Expt_Info.Number_of_Channels;					  dEinSpec := Plt_spec[sp_number]^^.Expt_Info.dE;numtostring(ChsinSpec,str1);realtostring(dEinSpec,5,5,str2);{putmessage('ChsinSpec and dEinSpec are',str1,str2,'');}					  errCode := FSpOpenDF(Write_DTSA_Spec, fsRdWrPerm, Hold_RefNum);					  WrtBinaryName := Write_DTSA_Spec.name;					  Restore_Expt_Header( Hold_RefNum);					  If (dEinSpec <> Plt_spec[sp_number]^^.Expt_Info.dE) then 					  	if (not answermessage('The ev per channel of the spectrum is different from the file.',								   'If the Work Experiment Header just has the wrong value I will continue,',								   'but if they ARE different, hit IT`S NOT OK and save to a different file.',								   'If IT`S OK I`ll continue.'))						then exit(WorkSpectrum_To_Disk);					  if (ChsinSpec > Plt_spec[sp_number]^^.Expt_Info.Number_of_Channels) then						 begin						  numtostring(Plt_spec[sp_number]^^.Expt_Info.Number_of_Channels,str1);						  str1:=concat('If IT`S OK, I will truncate the spectrum to ',str1,' channels.');						  If (not answermessage('Warning, the number of channels in the spectrum you are saving is',						  				'greater then the number allowed for the file.',str1,										'If IT`S NOT OK I will exit and you can save to a different file.'))						  then exit(WorkSpectrum_To_Disk);						 end;                      errCode := SetFPos(Hold_RefNum, fsFromStart, 0);                      bytecount := sizeof(Integer);                      errCode := FSRead(Hold_RefNum, bytecount, @index1);{get last spec number}                      index1 := index1 + 1;	{new last spec number}					  {remember that the spectrum in work was NOT read from the read file...} 					  Plt_spec[sp_number]^^.SpectrumStuff.Spectrum_Info.spectrum_number := index1;					  If Plt_spec[sp_number]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements <1					  then Plt_spec[sp_number]^^.SpectrumStuff.Spectrum_Info.This_is_a_standard := false;					  errCode := SetFPos(Hold_RefNum, fsFromStart, 0);                      errCode := FSWrite(Hold_RefNum, bytecount, @index1);{change last spec number}                      errCode := SetFPos(Hold_RefNum, fsfromLEOF, 0);                      bytecount := sizeof(Spectrum_Structure);                      errCode := FSWrite(Hold_RefNum, bytecount, @Plt_spec[sp_number]^^.SpectrumStuff);                      bytecount := Longint(Plt_spec[sp_number]^^.Expt_Info.Number_of_Channels) * 4;                      errCode := FSWrite(Hold_RefNum, bytecount, @Plt_spec[sp_number]^^.S);                      SpecWork_has_been_Changed := False;					  ItsBeenAcquired := False;                      errCode := FSClose(Hold_RefNum);                      errCode := FlushVol(NIL, Write_DTSA_Spec.vRefNum);					  {We wrote a Work spectrum to the file open for writing;					   we opened the file we wrote to for reading to see what's in it ¥¥¥WHEN?;					   now WrtBinaryName = RdBinaryName. Spec_Displayed is the spectrum from					   RdBinaryName which we last displayed; it could be any number.					   Displayed_Lst and Displayed_Fst are the 1st and last spectra in the					   RdBinaryName. We update Displayed_Lst below. Spectrum_Counter gets updated in					   SiLiWindow clicking code. Spec_Displayed should be set to  Displayed_Lst since					   the spectrum in Work is now the last spectrum in the file to read. This holds					   only for SaveWork on generated spectra or a spectrum brought in via foreign 					   file conversion that does not also open a DTSA file to save to.}					  					  IF Write_DTSA_Spec.name = Read_DTSA_Spec.name then					  begin                      {Displayed_Lst := Plt_spec[sp_number]^^.Expt_Info.LastSpect; is definition}					   Displayed_Lst := Displayed_Lst + 1;					   Spec_Displayed := Displayed_Lst;					   Plt_spec[sp_number]^^.Expt_Info.LastSpect := Displayed_Lst;					  end;					  BeepBeep; { to signal a successful save }                    END { If (save_work_open) and not demo...}				  ELSE 				  putmessage('I`m sorry, but I can save only spectra supplied with the demo disk.',				             '','','');                END { if SpecWork_has_been_Changed }              ELSE                BEGIN                  BeepBeep;                  Putmessage('You have already saved this spectrum!!', '', '', '');                END; { ELSE...}              Mouse_Active_Window;END;PROCEDURE D_WDS;      CONST        I_ACCEPT            = 1;        I_Cancel            = 2;        I_MYR               = 3;        I_NaCl              = 4;        I_KAP               = 5;        I_RAP               = 6;        I_TAP               = 7;        I_PET               = 8;        I_LiF               = 9;        I_LOD               = 10;        I_LDE1              = 11;        I_V_C               = 12;        I_MoB4C             = 13;        I_SiO2_1011         = 14;        I_SiO2_1010         = 15;        I_Si                = 16;        I_Graphite          = 17;        I_Pb_Stearate       = 18;        I_Mica              = 19;        I_EDDT              = 20;        I_User1             = 21;        I_User2             = 22;        I_Angstroms         = 23;        I_Sin_Theta         = 24;        I_millimeters       = 25;        I_x                 = 28;        I_x43               = 36;	{eV/Ch for converted spectrum}        I_x51               = 37;	{begin chan}        I_x49               = 38;	{begin value}        I_x47               = 39;	{end chan}        I_x45               = 40;	{end value}        I_x53               = 41;	{2d}		MACRO               = 43;	    I_1st               = 44;		I_2nd               = 45; 		I_3rd               = 46; 		I_4th               = 47; 		I_5th               = 48; 			  TYPE	    Position	          = (Left,Middle,Right,Unknown);	  	      VAR                  ExitDialog:         Boolean;        GetSelection:       DialogPtr;        tempRect:           Rect;        DType:              Integer;        Index, n:           Integer;        DItem:              Handle;        CItem				:   controlhandle;        sTemp:              Str255;        itemHit:            Integer;        temp, nn:           Integer;        Slope, E, L:        Real;        test				:  Integer;        L_Scaler, hold:     Real;		L_shift				:	real;		L_norm				:	Real;		TopChan           : integer;		BottomChan		  : integer;		first             :  boolean;		tempLong          : Longint;		StartChan			:	Integer;		ChanLeftSide		:	Real;		MaxDE				:	Real;		Extreme             :   Real;		DE					:	Real;		Next_n				:	Boolean;		Next_nn				:	Boolean;		myposition			: 	position;		E_WDS_Two_d,E_EndValue,E_FirstValue,E_dE	:real {double_t};		E_begin, E_end		: real {double_t};		Macro_Boolean       : Boolean;		str,str1,str2,str3,str4 : str255;		Data_is_Good		: Boolean;		Ang, s_theta, millim :  Boolean;		label 100;  PROCEDURE Help;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	      CONST      G_Accept                      = 1;	  BEGIN                                              G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString(' ');	  n := n+1; moveto(Left,Top + n*offset);str := 'This dialog will convert a wavelength dispersive (WDS) scan in WORK to an energy scan in ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'results. If you have chosen the wrong value for eV/Channel to do the conversion, you will';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'be promted for a new one. This value should be the smallest one that will work, that is a';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '"reasonable" number and preferably an integer. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset); REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;ExitDialog := False;DisposeDialog(G_Help);END;                {End of G_Help procedure} 		PROCEDURE Refresh_Dialog;        VAR          rTempRect:          Rect;        BEGIN          SetPort(GetSelection);          rTempRect := tempRect;          {Draw a line, Drawn line1-2 }          MoveTo(10, 194);          LineTo(430, 194);          {Draw a line, Drawn line1 }          MoveTo(10, 135);          LineTo(430, 135);          {Draw a rectangle, Rectangle1  }          PenSize(3, 3);          SetRect(tempRect, 5, 52, 265, 130);          FrameRect(tempRect);          PenSize(1, 1);          {Draw a rectangle, Rectangle2  }          PenSize(3, 3);          SetRect(tempRect, 5, 268, 425, 376);          FrameRect(tempRect);          PenSize(1, 1);          tempRect := rTempRect;        END;      BEGIN	{presumeably you have put some WDS spectrum into Work to convert: any spectrum	  		 brought in from the JEOL will have sensible values for dE, Sili_res, number_			 of_channels now.}	  	    if WDS_Active = False then		  begin		   putMessage('To use this dialog it is necessary that the program be configured for WDS.',		              'Go to the "Choose Detector Type" in the PARAMETERS menu item and pick WDS.','','');		   exit(D_WDS);		  end;        GetSelection := GetNewDialog(4254, NIL, POINTER( - 1));        ShowWindow(GetSelection);        SelectWindow(GetSelection);        SetPort(GetSelection);        100: OutlineButton(GetSelection, 1, 16); { outline the accept button }        Data_is_Good := True;		Ready_to_Save_WDS := False; 		Ang := false;		s_theta := false;		WDS_Convert_only_X_axis := false;		Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := false;		        {¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}        GetDialogItem(GetSelection, I_millimeters, DType, DItem, tempRect);        SetControlValue(controlHandle(DItem), 1);		millim := true; 		HideDialogItem(GetSelection, MACRO); 		 		        GetDialogItem(GetSelection, I_LiF, DType, DItem, tempRect);        IF WDS_Two_d = WDS_MYR THEN GetDialogItem(GetSelection, I_MYR, DType, DItem, tempRect);        IF WDS_Two_d = WDS_NaCl THEN GetDialogItem(GetSelection, I_NaCl, DType, DItem, tempRect);        IF WDS_Two_d = WDS_KAP THEN GetDialogItem(GetSelection, I_KAP, DType, DItem, tempRect);        IF WDS_Two_d = WDS_RAP THEN GetDialogItem(GetSelection, I_RAP, DType, DItem, tempRect);        IF WDS_Two_d = WDS_TAP THEN GetDialogItem(GetSelection, I_TAP, DType, DItem, tempRect);        IF WDS_Two_d = WDS_PET THEN GetDialogItem(GetSelection, I_PET, DType, DItem, tempRect);        IF WDS_Two_d = WDS_LiF THEN GetDialogItem(GetSelection, I_LiF, DType, DItem, tempRect);        IF WDS_Two_d = WDS_LOD THEN GetDialogItem(GetSelection, I_LOD, DType, DItem, tempRect);        IF WDS_Two_d = WDS_LDE1 THEN GetDialogItem(GetSelection, I_LDE1, DType, DItem, tempRect);        IF WDS_Two_d = WDS_V_C THEN GetDialogItem(GetSelection, I_V_C, DType, DItem, tempRect);        IF WDS_Two_d = WDS_MoB4C THEN GetDialogItem(GetSelection, I_MoB4C, DType, DItem, tempRect);        IF WDS_Two_d = WDS_SiO2_1011 THEN          GetDialogItem(GetSelection, I_SiO2_1011, DType, DItem, tempRect);        IF WDS_Two_d = WDS_SiO2_1010 THEN          GetDialogItem(GetSelection, I_SiO2_1010, DType, DItem, tempRect);        IF WDS_Two_d = WDS_Si THEN GetDialogItem(GetSelection, I_Si, DType, DItem, tempRect);        IF WDS_Two_d = WDS_Graphite THEN GetDialogItem(GetSelection, I_Graphite, DType, DItem, tempRect);        IF WDS_Two_d = WDS_Pb_Stearate THEN          GetDialogItem(GetSelection, I_Pb_Stearate, DType, DItem, tempRect);        IF WDS_Two_d = WDS_Mica THEN GetDialogItem(GetSelection, I_Mica, DType, DItem, tempRect);        IF WDS_Two_d = WDS_EDDT THEN GetDialogItem(GetSelection, I_EDDT, DType, DItem, tempRect);        IF WDS_Two_d = WDS_User1 THEN GetDialogItem(GetSelection, I_User1, DType, DItem, tempRect);        IF WDS_Two_d = WDS_User2 THEN GetDialogItem(GetSelection, I_User2, DType, DItem, tempRect);        SetControlValue(controlHandle(DItem), 1);      FOR Index := I_1st TO I_5th DO         BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := controlHandle(DItem);          IF I_1st = Index THEN SetControlValue(CItem, 1)          ELSE SetControlValue(CItem, 0);        END;		WDS_Order := 1;		        GetDialogItem(GetSelection, I_x43, DType, DItem, tempRect);	{eV/Chan converted}        RealToString(Plt_Spec[10]^^.Expt_Info.dE, 5, 5, Str);         SetDialogItemText(DItem, Str);		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue <= 0.0) then			Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue := 80.0;        GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);	{end value}        RealToString(Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue, 5, 5, Str);        SetDialogItemText(DItem, Str);		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel <= 0) then			Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel := 400;        GetDialogItem(GetSelection, I_x47, DType, DItem, tempRect);	{end chan}        NumToString(Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel, Str);        SetDialogItemText(DItem, Str);		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue <= 0.0) then			Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue := 50.0;        GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);	{begin value}        RealToString(Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue, 5, 5, Str);        SetDialogItemText(DItem, Str);		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstChannel <= 0) then			Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstChannel := 1;        GetDialogItem(GetSelection, I_x51, DType, DItem, tempRect);	{begin chan}        NumToString(Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstChannel, Str);        SetDialogItemText(DItem, Str);        GetDialogItem(GetSelection, I_x53, DType, DItem, tempRect);	{2d}        RealToString(WDS_Two_d, 5, 5, Str);        SetDialogItemText(DItem, Str);		FOR Index := I_Sin_Theta TO I_millimeters DO BEGIN		  GetDialogItem(GetSelection, Index, DType, DItem, tempRect);		  SetControlValue(controlHandle(DItem), 0);		END;		GetDialogItem(GetSelection, I_Angstroms, DType, DItem, tempRect);		SetControlValue(controlHandle(DItem), 1);		Ang := true;		s_theta := false;		millim := false;        Refresh_Dialog;        ExitDialog := FALSE;        MACRO_Boolean := False;		        REPEAT          ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlHandle(DItem);          IF (itemHit = I_ACCEPT) THEN  BEGIN            MACRO_Boolean := True;            ExitDialog := True;          END;         { IF (itemHit = I_Help) THEN Help; }                     (*IF (itemHit = MACRO) THEN BEGIN            MACRO_Boolean := True;            ExitDialog := True;          END;*)		 IF (itemHit = I_Cancel) THEN BEGIN            DisposeDialog(GetSelection);            Mouse_Active_Window;            exit(D_WDS);          END;          IF (itemHit >= I_MYR) AND (itemHit <= I_User2) THEN BEGIN            FOR Index := I_MYR TO I_User2 DO BEGIN              GetDialogItem(GetSelection, Index, DType, DItem, tempRect);              SetControlValue(controlHandle(DItem), 0);            END;            SetControlValue(CItem, 1);            IF itemHit = I_MYR THEN WDS_Two_d := WDS_MYR;            IF itemHit = I_NaCl THEN WDS_Two_d := WDS_NaCl;            IF itemHit = I_KAP THEN WDS_Two_d := WDS_KAP;            IF itemHit = I_RAP THEN WDS_Two_d := WDS_RAP;            IF itemHit = I_TAP THEN WDS_Two_d := WDS_TAP;            IF itemHit = I_PET THEN WDS_Two_d := WDS_PET;            IF itemHit = I_LiF THEN WDS_Two_d := WDS_LiF;            IF itemHit = I_LOD THEN WDS_Two_d := WDS_LOD;            IF itemHit = I_LDE1 THEN WDS_Two_d := WDS_LDE1;            IF itemHit = I_V_C THEN WDS_Two_d := WDS_V_C;            IF itemHit = I_MoB4C THEN WDS_Two_d := WDS_MoB4C;            IF itemHit = I_SiO2_1011 THEN WDS_Two_d := WDS_SiO2_1011;            IF itemHit = I_SiO2_1010 THEN WDS_Two_d := WDS_SiO2_1010;            IF itemHit = I_Si THEN WDS_Two_d := WDS_Si;            IF itemHit = I_Graphite THEN WDS_Two_d := WDS_Graphite;            IF itemHit = I_Pb_Stearate THEN WDS_Two_d := WDS_Pb_Stearate;            IF itemHit = I_Mica THEN WDS_Two_d := WDS_Mica;            IF itemHit = I_EDDT THEN WDS_Two_d := WDS_EDDT;            IF itemHit = I_User1 THEN WDS_Two_d := WDS_User1;            IF itemHit = I_User2 THEN WDS_Two_d := WDS_User2;            GetDialogItem(GetSelection, I_x53, DType, DItem, tempRect);            RealToString(WDS_Two_d, 5, 5, Str);            SetDialogItemText(DItem, Str);          END;          IF (itemHit >= I_1st) AND (itemHit <= I_5th) THEN BEGIN            FOR Index := I_1st TO I_5th DO BEGIN              GetDialogItem(GetSelection, Index, DType, DItem, tempRect);              SetControlValue(controlHandle(DItem), 0);            END;            SetControlValue(CItem, 1);			IF itemHit = I_1st THEN WDS_Order := 1;			IF itemHit = I_2nd THEN WDS_Order := 2;			IF itemHit = I_3rd THEN WDS_Order := 3;			IF itemHit = I_4th THEN WDS_Order := 4;			IF itemHit = I_5th THEN WDS_Order := 5;		  END;          IF (itemHit >= I_Angstroms) AND (itemHit <= I_millimeters) THEN BEGIN            FOR Index := I_Angstroms TO I_millimeters DO BEGIN              GetDialogItem(GetSelection, Index, DType, DItem, tempRect);              SetControlValue(controlHandle(DItem), 0);            END;            SetControlValue(CItem, 1);			GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			E_FirstValue := MyStr2Num(sTemp);			GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			E_EndValue := MyStr2Num(sTemp);			IF itemHit = I_Angstroms THEN begin				if s_theta then begin	{ sin theta to Angstroms }					E_begin := E_FirstValue * WDS_Two_d / WDS_Order;					E_end := E_EndValue * WDS_Two_d / WDS_Order;				end				else if millim then begin	{ Millimeters to Angstroms }					E_begin := E_FirstValue * WDS_Two_d / WDS_Order / 280.0;					E_end := E_EndValue * WDS_Two_d / WDS_Order / 280.0;								end				else begin	{ no change }					E_begin := E_FirstValue;					E_end := E_EndValue;								end;				Ang := true;				s_theta := false;				millim := false;				GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);	{begin value}				RealToString(E_begin, 5, 5, Str);				SetDialogItemText(DItem, Str);				GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);	{end value}				RealToString(E_end, 5, 5, Str);				SetDialogItemText(DItem, Str);			end;			IF itemHit = I_Sin_Theta THEN begin				if Ang then begin	{ Angstroms to sin theta }					E_begin := E_FirstValue * WDS_Order / WDS_Two_d;					E_end := E_EndValue * WDS_Order / WDS_Two_d;				end				else if millim then begin	{ Millimeters to sin theta }					E_begin := E_FirstValue / 280.0;					E_end := E_EndValue / 280.0;								end				else begin	{ no change }					E_begin := E_FirstValue;					E_end := E_EndValue;								end;				s_theta := true;				Ang := false;				millim := false;				GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);	{begin value}				RealToString(E_begin, 5, 5, Str);				SetDialogItemText(DItem, Str);				GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);	{end value}				RealToString(E_end, 5, 5, Str);				SetDialogItemText(DItem, Str);			end;			IF itemHit = I_millimeters THEN begin				if Ang then begin	{ Angstroms to Millimeters }					E_begin := E_FirstValue * WDS_Order * 280.0 / WDS_Two_d;					E_end := E_EndValue * WDS_Order * 280.0 / WDS_Two_d;				end				else if s_theta then begin	{ sin theta to Millimeters }					E_begin := E_FirstValue * 280.0;					E_end := E_EndValue * 280.0;								end				else begin	{ no change }					E_begin := E_FirstValue;					E_end := E_EndValue;								end;				millim := true;				s_theta := false;				Ang := false;				GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);	{begin value}				RealToString(E_begin, 5, 5, Str);				SetDialogItemText(DItem, Str);				GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);	{end value}				RealToString(E_end, 5, 5, Str);				SetDialogItemText(DItem, Str);			end;          END;        UNTIL ExitDialog;        GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);		E_EndValue := MyStr2Num(sTemp);        Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue := {Num2Real}(E_EndValue);		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue <= 0.0) then Data_is_Good := False;        		GetDialogItem(GetSelection, I_x47, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);		StringtoNum(sTemp, tempLong);        Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel := tempLong;		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel <= 0) then Data_is_Good := False; 		GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);		E_FirstValue := MyStr2Num(sTemp);        Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue := {Num2Real}(E_FirstValue);		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue <= 0.0) then Data_is_Good := False;        GetDialogItem(GetSelection, I_x51, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);		StringtoNum(sTemp, tempLong);        Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstChannel := tempLong;		IF (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstChannel <= 0) then Data_is_Good := False;        GetDialogItem(GetSelection, I_x53, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        E_WDS_Two_d := MyStr2Num(sTemp);		WDS_Two_d := {Num2Real}(E_WDS_Two_d);				IF (Data_is_Good = False) then			begin			  Data_is_Good := True;			  putmessage('Zero or negative values are not allowed for any of these parameters.','','','');			  goto 100;			end;		 		BlockMove(@Plt_Spec[10]^^, @Plt_Spec[9]^^, Sizeof(Plt_Spec[10]^^));        For nn := 1 to Maximum_Channels do Plt_Spec[9]^^.S[nn] := 0.0;        GetDialogItem(GetSelection, I_x43, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        E_dE := MyStr2Num(sTemp);        Plt_Spec[9]^^.Expt_Info.dE := {Num2Real}(E_dE);		WDS_eV := Plt_Spec[9]^^.Expt_Info.dE;		WDS_BgnWDS := Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstChannel; 		WDS_EndWDS := Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel;		(*if (Ang = true) then begin*)			WDS_BgnLam := Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue / WDS_Order; 			WDS_EndLam := Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue / WDS_Order; 		 if (s_theta = true) then		  begin		    WDS_BgnLam := WDS_BgnLam * WDS_Two_d;			WDS_EndLam := WDS_EndLam * WDS_Two_d;		  end		else if (millim = true) then		  begin		    WDS_BgnLam := WDS_BgnLam * WDS_Two_d / 280.0;			WDS_EndLam := WDS_EndLam * WDS_Two_d / 280.0; 		  end;			Plt_Spec[10]^^.SpectrumStuff.Acq_Info.FirstValue := WDS_BgnLam;			Plt_Spec[10]^^.SpectrumStuff.Acq_Info.EndValue := WDS_EndLam;			Plt_Spec[9]^^.SpectrumStuff.Acq_Info.FirstValue := WDS_BgnLam;			Plt_Spec[9]^^.SpectrumStuff.Acq_Info.EndValue := WDS_EndLam;        Slope := (WDS_EndWDS - WDS_BgnWDS) / (WDS_EndLam - WDS_BgnLam){(E_EndValue - E_FirstValue)};        test := 0;        hold := 0.0;        temp := 0;				For nn := 1 to Maximum_Channels do Col_1^[nn] := 0.0; {Array for E(nn)}		For nn := 1 to Maximum_Channels do Col_2^[nn] := 0.0; {Array for deltaE(nn)}		For nn := 1 to Maximum_Channels do Col_3^[nn] := 0.0; {Array for converted measured points}		 				first := true;		L_shift :=0.0;		{L_shift :=getreal('Type in a backlash value',L_shift);}		        FOR nn := 1 TO Spectrum_Size+1 DO BEGIN          L := (nn - (WDS_BgnWDS - Slope * WDS_BgnLam)) / Slope - L_shift; 		  		{ L=JEOL mm's as a function of channel number }{¥¥¥NO L is now in Angstroms¥¥¥}          		{For the JEOL  mm := 280 / ( 2d ) * n * Lamda and E(eV) := 3471440/(WDS_Two_d * mm)}          {E := 3471440 / (E_WDS_Two_d * L );} 		{Convert it to Energy in eV}           E := 12398 / L;                                                              		  if nn = Spectrum_Size+1 then 		  	BEGIN		  		Extreme:=E;				 L_norm := 12398 / (E*E); 		  	END		  else Begin		    Col_1^[Spectrum_Size-nn+1] := E;			{position of measured point in E-space}						{order of points is turned upside down to make increasing index correspond to						increasing energy}		  End;        END;                 { FOR nn := 1 TO Spectrum_Size }				For nn := 1 TO Spectrum_Size DO BEGIN		  L_Scaler := 12398 / (Col_1^[nn]*Col_1^[nn]);	{Col[1] has been reversed}		  Col_3^[nn] := Plt_Spec[10]^^.s[Spectrum_Size-nn+1] *				L_Scaler  / L_norm ;	{converted into E-space by derivative and normalized}							    if nn = 1 then Col_2^[nn] := abs(Col_1^[nn] - Extreme)		    else Col_2^[nn] := abs(Col_1^[nn] - Col_1^[nn-1]);						{Col[2] = delta-E = spacing of the point in E-space}		  		END;				MaxDE := Col_2^[Spectrum_Size];		hold :=  Col_2^[1];		if hold > MaxDE then MaxDE := hold;				if MaxDE > E_dE then BEGIN		  hold := MaxDE / E_dE;		(*if MaxDE > Plt_Spec[10]^^.Expt_Info.dE then BEGIN		  hold := MaxDE / Plt_Spec[10]^^.Expt_Info.dE;*)		  str1 := 'Maximum step-size in E-space is ';		  realtostring(hold,5,1,str2);		  str3 := ' times the channel width';	  	  str4 := ' Change Spectrometer Stepsize or Channel width.';		  putmessage(str1,str2,str3,str4);		  goto 100;					{go back to set-up .dE}		END;				Topchan := rinttol(Col_1^[Spectrum_Size] / E_dE);		(*Topchan := rinttol(Col_1^[Spectrum_Size] / Plt_Spec[10]^^.Expt_Info.dE);*)				{??? is the WDS scan always going from low L to high L ???}		if TopChan > Maximum_Channels then BEGIN		  str1 := 'Topchannel is changed from ';		  numtostring(Topchan,str2);		  str3 := ' to Maximum_Channels =';		  numtostring(Maximum_Channels,str4);		  putmessage(str1,str2,str3,str4);		  TopChan := Maximum_Channels;		END;		BottomChan := rinttol(Col_1^[1] / E_dE);		{???}		(*BottomChan := rinttol(Col_1^[1] / Plt_Spec[10]^^.Expt_Info.dE);	*)	{???}		StartChan := 1;				FOR n:=BottomChan To TopChan DO BEGIN		  Next_n := false;		  myposition := unknown;	(*	  ChanLeftSide := n * Plt_Spec[10]^^.Expt_Info.dE;*)		  ChanLeftSide := n * E_dE;		  		  FOR nn:= StartChan TO Spectrum_Size DO BEGIN		    Next_nn := false;						if first then BEGIN			  if (ChanLeftSide + Col_2^[nn] < Col_1^[nn]) AND (Col_1^[nn] <			 (* ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE) then  BEGIN*)			  ChanLeftSide + E_dE) then  BEGIN				   Next_nn := true;		{go for next nn}				 			{middle point : not good as first; would leave incomplete integral}			  end;			  			  if (Next_nn = false) AND			  (*	(ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE <= Col_1^[nn]) AND 				(Col_1^[nn] < ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE + Col_2^[nn])*)			  	(ChanLeftSide + E_dE <= Col_1^[nn]) AND 				(Col_1^[nn] < ChanLeftSide + E_dE + Col_2^[nn])				then  BEGIN				{right side point : left section is dropped; right section goes to next channel}				first :=false;				Next_n := true;		{go for next n}			  end;			  			  if (Next_n = false) AND (ChanLeftSide < Col_1^[nn]) AND			  	(Col_1^[nn] <= ChanLeftSide + Col_2^[nn]) then first:=false;			  						{left side point}			END;									if (first = false) AND (Next_nn = false) AND (Next_n = false) THEN BEGIN			  if (ChanLeftSide < Col_1^[nn]) AND			  	(Col_1^[nn] <= ChanLeftSide + Col_2^[nn]) then  BEGIN			    DE:= Col_1^[nn] - ChanLeftSide;				Plt_Spec[9]^^.S[n] := Plt_Spec[9]^^.S[n] + DE * Col_3^[nn];				myposition := left;				str1 :='left';				Next_nn := true;			{go for next nn}									{left side point}			  end;			  if (Next_nn = false) AND			    (ChanLeftSide + Col_2^[nn] < Col_1^[nn]) AND (Col_1^[nn] <			  	(*ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE) then  BEGIN*)			  	ChanLeftSide + E_dE) then  BEGIN			    DE:= Col_2^[nn];				Plt_Spec[9]^^.S[n] := Plt_Spec[9]^^.S[n] + DE * Col_3^[nn];				myposition := middle;				str1 :='middle';				Next_nn := true	;			{go for next nn}				 					{middle point}			  end;			  if (Next_nn = false) AND			 (*  (ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE <= Col_1^[nn]) AND 				(Col_1^[nn] < ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE + Col_2^[nn])*)			    (ChanLeftSide + E_dE <= Col_1^[nn]) AND 				(Col_1^[nn] < ChanLeftSide + E_dE + Col_2^[nn])				then  BEGIN				myposition := right;				str1 := 'right';			  (*  DE:= ChanLeftSide + Plt_Spec[10]^^.Expt_Info.dE - (Col_1^[nn] - Col_2^[nn]);*)			    DE:= ChanLeftSide + E_dE - (Col_1^[nn] - Col_2^[nn]);				Plt_Spec[9]^^.S[n] := Plt_Spec[9]^^.S[n] + DE * Col_3^[nn];				if ChanLeftSide < Col_1^[nn] then 				  StartChan := nn	{something is left from the point to the next channel}				else StartChan := nn + 1;										Next_n :=true;			{go for next n}		{right side point}			  end;			end;			{if not first}			if Next_n = true then leave;		  END;             {For nn=..}		END;               {For n=..}				if myposition <> right then  BEGIN		  Plt_Spec[9]^^.S[TopChan] := 0;		  Topchan := TopChan - 1;		{unfinished interval is dropped}		END;				if (TopChan > 0) AND (TopChan <= 256) then TopChan := 256 else		if (TopChan > 256) AND (TopChan <= 512) then TopChan := 512 else		if (TopChan > 512) AND (TopChan <= 1024) then TopChan := 1024 else		if (TopChan > 1024) AND (TopChan <= 2048) then TopChan := 2048 else		if (TopChan > 2048) AND (TopChan <= 4096) then TopChan := 4096 else		if (TopChan > 4096) AND (TopChan <= Maximum_Channels) then 		               TopChan := Maximum_Channels;		     ChannelMin := 1;			 if TopChan = 256 then			 begin			   Range_Keeper := 5;			   Spectrum_Size := 256;			   New_Range := 256;			   ChannelMax := 256;                           end;			 			 if TopChan = 512 then			 begin			   Range_Keeper := 6;			   Spectrum_Size := 512;			   New_Range := 512;			   ChannelMax := 512;                           end;			 if TopChan = 1024 then			 begin			  			  Range_Keeper := 7;              Spectrum_Size := 1024;              New_Range := 1024;              ChannelMax := 1024;             end;			 			 if TopChan = 2048 then			 begin			                Range_Keeper := 8;              Spectrum_Size := 2048;              New_Range := 2048;              ChannelMax := 2048;             end;			 			 if TopChan = 4096 then			 begin			                Range_Keeper := 9;              Spectrum_Size := 4096;              New_Range := 4096;              ChannelMax := 4096;             end;			 			 if TopChan = 8192 then			 begin			                Range_Keeper := 10;              Spectrum_Size := 8192;              New_Range := 8192;              ChannelMax := 8192;             end;	Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := true;	WDS_Convert_only_X_axis := true;    if MACRO_Boolean then	BEGIN	  { now rotate }			                       { in case there is left over crap in the high channels }       For nn := 1 to Maximum_Channels do Col_1^[nn] := 0.0; 	   BlockMove(@Plt_spec[9]^^.S, @Col_1^, Sizeof(Col_1^));	   Plt_Spec[10]^^.Expt_Info.dE := Plt_Spec[9]^^.Expt_Info.dE; 	   BlockMove(@Plt_spec[10]^^.S, @Plt_spec[9]^^.S, Sizeof(Plt_spec[9]^^.S)); 	   BlockMove(@Col_1^, @Plt_spec[10]^^.S, Sizeof(Plt_spec[10]^^.S));	   Plt_Spec[10]^^.Expt_Info.detector.ID := 4;	   Plt_Spec[10]^^.Expt_Info.detector.Spec := WDS ;		   Spectrum_Full[10] := True;	   CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);	   SpecWork_has_been_Changed := True;	   Ready_to_Save_WDS := TRUE;	   WDS_ChanNum_Holder := Plt_spec[10]^^.Expt_Info.Number_of_Channels ;  	   Plt_spec[10]^^.Expt_Info.Number_of_Channels := TopChan;       END	ELSE	BEGIN	   Plt_Spec[9]^^.Expt_Info.detector.ID := 4;	   Plt_Spec[9]^^.Expt_Info.detector.Spec := WDS ;		   Spectrum_Full[10] := True;	   Spectrum_Full[9] := True;	   CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);	   CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);	   WDS_ChanNum_Holder := Plt_spec[9]^^.Expt_Info.Number_of_Channels ; 	   Plt_spec[9]^^.Expt_Info.Number_of_Channels := TopChan;    	END;	   DisposeDialog(GetSelection);	   UpDate_Max_Min(9);	 	   UpDate_Max_Min(10);	   Update_Full;	   Refresh_ROIs;		   Mouse_Active_Window;	   UpDate_SiLi_Window(SiLiWindow);   END;		{ PROCEDURE D_WDS }	  {$S Utilities1}   PROCEDURE D_ASCII_FORMAT;      CONST        I_ACCEPT            = 1;        I_Cancel            = 2;        Single_Column       = 3;        I_Kaledagraph       = 4;        I_EXEL              = 5;        I_Statview          = 6;        I_Spare_1           = 7;        I_Spare_2           = 8;        I_Spare_3           = 9;      VAR        GetSelection:       DialogPtr;        tempRect:           Rect;        DType:              Integer;        Index:              Integer;        DItem:              Handle;        CItem				:   controlhandle;        itemHit:            Integer;        temp:               Integer;        ExitDialog:         Boolean;        n, nn:              Integer;        Value:              Real;        errCode:            Integer;        fndrInfo:           FInfo;        refnum:             text;        str1 : str255;      BEGIN           GetSelection := GetNewDialog(17693, NIL, POINTER( - 1));        ShowWindow(GetSelection);        SelectWindow(GetSelection);        SetPort(GetSelection);        OutlineButton(GetSelection, 1, 16); { outline the accept button }        {Setup initial conditions}        GetDialogItem(GetSelection, Single_Column, DType, DItem, tempRect);        SetControlValue(controlHandle(DItem), 1);        ExitDialog := FALSE;        REPEAT          ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlHandle(DItem);          IF (itemHit = I_ACCEPT) THEN BEGIN            ExitDialog := True;          END;          IF (itemHit = I_Cancel) THEN BEGIN            DisposeDialog(GetSelection);            Mouse_Active_Window;            exit(D_ASCII_FORMAT);          END;          IF (itemHit >= Single_Column) AND (itemHit <= I_Spare_3) THEN BEGIN            FOR Index := Single_Column TO I_Spare_3 DO BEGIN              GetDialogItem(GetSelection, Index, DType, DItem, tempRect);              SetControlValue(controlHandle(DItem), 0);            END;            SetControlValue(CItem, 1);          END;        UNTIL ExitDialog;        Index := Single_Column;        REPEAT          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          temp := GetControlValue(controlHandle(DItem));          Index := Index + 1;        UNTIL (temp <> 0) OR (Index > I_Spare_3);        temp := Index - Single_Column + 1;        IF (temp = 2) AND (NOT ASCII_Out_finished) THEN BEGIN          OutName := 'Spectrum.Dat';          if (CreateFile(OutName, 'Send Work Spectrum to:') = True) OR (File_Cancel_Button =                FALSE) then;          IF (File_Cancel_Button = FALSE) THEN 			begin			  DisposeDialog(GetSelection);			  exit(D_ASCII_FORMAT);			end;		  errcode := getvol(Save_Volume_Name,save_vol);		  if errcode = noerr then errcode := SetVol(NIL, Out_VolRefNum);		  if errcode = noerr then begin			  Rewrite(refnum, OutName);			  fndrInfo.fdcreator := 'MSWD';			  fndrInfo.fdtype := 'TEXT';			  fndrInfo.fdFlags := 100;			  errCode := setfinfo(OutName, 0, fndrInfo);			  IF errCode <> noErr THEN				PutMessage('setFinfo error just occured', 'in WriteToFile', '', '');			  FOR n := 1 TO Spectrum_Size DO BEGIN				Value := Plt_Spec[10]^^.s[n];				WRITELN(refnum, Value);			  END;			  close(refnum);			  ASCII_Out_finished := True;			  errcode := FlushVol(NIL,Out_VolRefNum);		      errcode := SetVol(Save_Volume_Name,save_vol);		  end		  else putmessage('in D_ASCII_FORMAT, err in setvol','','','');        END;        IF temp = 3 THEN BEGIN          OutName := 'Spectrum.Dat';          if (CreateFile(OutName, 'Send Work Spectrum to:') = True) OR (File_Cancel_Button =                FALSE) then;          IF (File_Cancel_Button = FALSE) THEN 					    begin			  DisposeDialog(GetSelection);			  exit(D_ASCII_FORMAT);			end;		  errcode := getvol(Save_Volume_Name,save_vol);		  if errcode = noerr then errcode := SetVol(NIL, Out_VolRefNum);		  if errcode = noerr then begin			 Rewrite(refnum, OutName);			 fndrInfo.fdcreator := 'QKPT'; { KaleideGraph }			 fndrInfo.fdtype := 'TEXT';			 fndrInfo.fdFlags := 100;			 errCode := setfinfo(OutName, 0, fndrInfo);			 IF errCode <> noErr THEN BEGIN				 PutMessage('setFinfo error just occured', 'in WriteToFile', '', '');				 DisposeDialog(GetSelection);				 exit(D_ASCII_FORMAT);			 END;   			 WRITE(refnum, 'Channel');			 FOR nn := 1 TO 10 DO BEGIN			   IF Spectrum_Full[nn] THEN BEGIN				 NumToString(nn, str1);				 str1 := CONCAT('Spectrum ', str1);				 WRITE(refnum, CHR(9), str1);			   END;			 END;			 WRITE(refnum, CHR(13));   			 FOR n := 1 TO Spectrum_Size DO BEGIN			   WRITE(refnum, n);			   FOR nn := 1 TO 10 DO BEGIN				 IF Spectrum_Full[nn] THEN BEGIN				   Value := Plt_Spec[nn]^^.s[n];				   WRITE(refnum, CHR(9), Value);				 END;			   END;			   WRITE(refnum, CHR(13));			 END;			 close(refnum);			 ASCII_Out_finished := True;			  errcode := FlushVol(NIL,Out_VolRefNum);		      errcode := SetVol(Save_Volume_Name,save_vol);		  end		  else putmessage('in D_ASCII_FORMAT, err in setvol','','','');        END;        IF temp = 4 THEN BEGIN          OutName := 'Spectrum.Dat';          if (CreateFile(OutName, 'Send Work Spectrum to:') = True) OR (File_Cancel_Button =                FALSE) then;          IF (File_Cancel_Button = FALSE) THEN 			begin			  DisposeDialog(GetSelection);			  exit(D_ASCII_FORMAT);			end;		  errcode := getvol(Save_Volume_Name,save_vol);		  if errcode = noerr then errcode := SetVol(NIL, Out_VolRefNum);		  if errcode = noerr then begin			  Rewrite(refnum, OutName);          fndrInfo.fdcreator := 'XCEL'; { EXEL spreadsheet }          fndrInfo.fdtype := 'TEXT';          fndrInfo.fdFlags := 100;          errCode := setfinfo(OutName, 0, fndrInfo);          IF errCode <> noErr THEN BEGIN            PutMessage('setFinfo error just occured', 'in WriteToFile', '', '');			DisposeDialog(GetSelection);            exit(D_ASCII_FORMAT);          END;          WRITE(refnum, 'Channel');          FOR nn := 1 TO 10 DO BEGIN            IF Spectrum_Full[nn] THEN BEGIN              NumToString(nn, str1);              str1 := CONCAT('Spectrum ', str1);              WRITE(refnum, CHR(9), str1);            END;          END;          WRITE(refnum, CHR(13));          FOR n := 1 TO Spectrum_Size DO BEGIN            WRITE(refnum, n);            FOR nn := 1 TO 10 DO BEGIN              IF Spectrum_Full[nn] THEN BEGIN                Value := Plt_Spec[nn]^^.s[n];                WRITE(refnum, CHR(9), Value);              END;            END;            WRITE(refnum, CHR(13));          END;          close(refnum);			  ASCII_Out_finished := True;			  errcode := FlushVol(NIL,Out_VolRefNum);		      errcode := SetVol(Save_Volume_Name,save_vol);		  end		  else putmessage('in D_ASCII_FORMAT, err in setvol','','','');        END;        IF temp = 5 THEN BEGIN          OutName := 'Spectrum.Dat';          if (CreateFile(OutName, 'Send Work Spectrum to:') = True) OR (File_Cancel_Button =                FALSE) then;          IF (File_Cancel_Button = FALSE) THEN 		  begin		  DisposeDialog(GetSelection);		  exit(D_ASCII_FORMAT);		  end;		  errcode := getvol(Save_Volume_Name,save_vol);		  if errcode = noerr then errcode := SetVol(NIL, Out_VolRefNum);		  if errcode = noerr then begin			  Rewrite(refnum, OutName);          fndrInfo.fdcreator := 'STAT'; { StatView }          fndrInfo.fdtype := 'TEXT';          fndrInfo.fdFlags := 100;          errCode := setfinfo(OutName, 0, fndrInfo);          IF errCode <> noErr THEN BEGIN            PutMessage('setFinfo error just occured', 'in WriteToFile', '', '');			DisposeDialog(GetSelection);            exit(D_ASCII_FORMAT);          END;          WRITE(refnum, 'Channel');          FOR nn := 1 TO 10 DO BEGIN            IF Spectrum_Full[nn] THEN BEGIN              NumToString(nn, str1);              str1 := CONCAT('Spectrum ', str1);              WRITE(refnum, CHR(9), str1);            END;          END;          WRITE(refnum, CHR(13));          FOR n := 1 TO Spectrum_Size DO BEGIN            WRITE(refnum, n);            FOR nn := 1 TO 10 DO BEGIN              IF Spectrum_Full[nn] THEN BEGIN                Value := Plt_Spec[nn]^^.s[n];                WRITE(refnum, CHR(9), Value);              END;            END;            WRITE(refnum, CHR(13));          END;          close(refnum);			  ASCII_Out_finished := True;			  errcode := FlushVol(NIL,Out_VolRefNum);		      errcode := SetVol(Save_Volume_Name,save_vol);		  end		  else putmessage('in D_ASCII_FORMAT, err in setvol','','','');        END;        DisposeDialog(GetSelection);        Mouse_Active_Window; 		      END;	  Procedure Get_WDInfo(VAR VName:str31; VAR DirID:longint; VAR VNum:integer);	VAR	  {async							: boolean;}	  myWDblock						: WDPBRec;	{ VNum: working directory number supplied in call. Returned: VName, volume name;	  DirID, the directory id num; VNum, volume ref number.} 	BEGIN			 myWDblock.ioCompletion := NIL; {always NIL}		     myWDblock.ioVRefNum := VNum; {working directory number coming in}		     myWDblock.ioWDindex := 0;{0 because we are specifying the dir by the WD ref num} 			 myWDblock.ioWDVRefNum := 0; 			 myWDblock.ioWDProcID := 0;	         myWDblock.ioNamePtr := StringPtr(NewPtr(sizeof(str31)));			 {err := PBHGetFInfosync(@myWDblock);}			 err := PBGetWDInfosync(@myWDblock);			 VName := myWDblock.ioNamePtr^; {str31}			 DirID := myWDBlock.ioWDDirid; {longint}			 VNum := myWDBlock.ioWDVRefNum;{volume ref number, integer, comes out}		    DisposePtr(Ptr(myWDblock.ioNamePtr));			 myWDblock.ioNamePtr := NIL;	END;	{Procedure Get_WDInfo;}		PROCEDURE Get_CreationDate(VAR aFilename:fnamestr; VAR aDirID:longint; VAR aVNum:integer);	VAR		myblock						: HParamBlockRec;		{doAsync			: boolean;}		thename :str255;		errcode : integer;	BEGIN		{If you know the Working Dir Num but don't know aDirID and aVNum,the Volume number, call		 Get_WDInfo first}		     			 myblock.ioNamePtr := StringPtr(NewPtr(sizeof(str255)));			 thename := '';			 blockmove(@aFilename,@thename,sizeof(str63));			 {...thename is str255, aFilename is str63}			 myblock.ioNamePtr := @thename;	{stringPtr...to str255}			 myblock.ioCompletion := NIL; {always NIL}			 myblock.ioFDirIndex := -1;			 myblock.ioDirID := aDirID;			 myblock.ioVRefNum := aVNum;	{Vol num not WD num}			 errcode := PBHGetFInfosync(@myblock);{FILES:2-194}		     SecondsToDate(myblock.ioFlCrDat, theDateTime);{a dateTimeRec, global var}		    DisposePtr(Ptr(myblock.ioNamePtr));		     myblock.ioNamePtr := NIL;			(*in calling code define DateAndTimeStr: str255; and do the following:			  DateAndTimeStr := DTRec2Str;			  IF (theDateTime.hour) >= 12 THEN DateAndTimeStr := CONCAT('           ',DateAndTimeStr, ' pm')			  ELSE DateAndTimeStr := CONCAT('           ',DateAndTimeStr, ' am');			*)	END;	{PROCEDURE Get_CreationDate}	  FUNCTION DTRec2Str: str255;        VAR      theHour                       : integer;      str1                          : str255;      str2                          : str255;      str3                          : str255;      str4                          : str255;      str5                          : str255;      str6                          : str255;         { dont want to use the globals of these }    BEGIN      str1 := '';      numtostring(theDateTime.day, str1);      numtostring(theDateTime.month, str2);      numtostring(theDateTime.year, str3);      theHour := theDateTime.hour;      IF (theHour > 12) THEN theHour := theHour - 12      ELSE IF (theHour = 0) THEN theHour := 12; {AM will be on}      numtostring(theHour, str4);      numtostring(theDateTime.minute, str5);      numtostring(theDateTime.second, str6);      DTRec2Str := CONCAT(str1, '/', str2, '/', str3, '/', str4, ':', str5, ':', str6); ;    END; { Function DTRec2Str; }FUNCTION CreateFile(VAR FM: fnamestr; Prompt: str255): Boolean;    { DOES NOT CREATE THE FILE!	  Brings up a file dialog box so that the user can NAME a NEW FILE. }      VAR        Ok:                 Boolean;        Start:              Point;        reply:              SFReply;        err:                OSErr;      BEGIN                  { Create }        WITH Start DO BEGIN          v := 90;          h := 80;        END;		        SFPutFile(Start, Prompt, FM, NIL, reply);		 	DrawAxesFull;			update_full;		    UpDate_SiLi_Window(SiLiWindow) ;  		        WITH reply DO BEGIN          Ok := good;        { reply.Good is false if cancel button is pushed, otherwise true }          File_Cancel_Button := good; { resets if clicked }          IF Ok THEN begin		  		    err := FSMakeFSSpec(reply.vRefNum,0,reply.fName,Out_Spec);		  		  	FM := FName;{reply.FName}			Out_VolRefNum := VRefNum;{reply.VRefNum is a working dir ref num }					OutVol_volnum := Out_VolRefNum;			Get_WDInfo(OutVol_volname,OutVol_DirID,OutVol_volnum);			{...returns volume name in OutVol_volname;volume ref number in OutVol_volnum;DirID in OutVol_DirID}					err := FlushVol(NIL, Out_VolRefNum);		  end;         END;                 { WITH reply...}		CreateFile := Ok;	END;                   { Create }    FUNCTION GetFileName(VAR FJ: fnamestr; VAR theType1, theType2: OsType;                         VAR Prompt: Str255): Boolean;{ Brings up a file selection box so the user can  SELECT a file to open from the list of file names. }      VAR		Start:              Point;        FileType:           ARRAY [0..3] of OSType;		sfPtr             : ConstSFTypeListPtr;        reply:              SFReply;        Ok:                 Boolean;        err:                OSErr;        Dummy_VolRefNum:    Integer;      BEGIN        Dummy_VolRefNum := In_VolRefNum; { working dir number of last file opened }         err := SetVol(NIL, Dummy_VolRefNum);        WITH Start DO BEGIN          v := 90;          h := 80;        END;        FileType[0] := theType1;        FileType[1] := theType2;		sfPtr := @FileType;		  (*StandardGetFile(NIL,2, sfPtr, Streply);		{¥¥New DTSA file spec¥¥}		  File_Cancel_Button := Streply.sfGood;*)		  		        SFGetFile(Start, Prompt, NIL, 2, sfPtr, NIL, reply);		 { IV-73: On exiting from SFGetFile, OpenWD is called. if hierarchical file system,		  the default vol & working directory are set to that of the chosen file;		  In_VolRefNum is then the Working Dir RefNum (not same as dirID which is unique on		  its volume) NOT a volume reference; on a flat system it's the vol refnum.           This can lead to trouble even tho' the "working directory reference numbers		  can always be used in place of volume refernce numbers". Ha!}			DrawAxesFull;			update_full;		    UpDate_SiLi_Window(SiLiWindow) ;		    File_Cancel_Button := reply.Good;		    GetFileName := reply.Good;			if NOT reply.Good Then exit(GetFileName);					  err := FSMakeFSSpec(reply.vRefNum,0,reply.fName,In_Spec);		          WITH reply DO BEGIN          Ok := Good;	{reply.good}          File_Cancel_Button := Good; { reply.Good is false if the cancel button is pushed }          IF Ok THEN BEGIN            FJ := reply.FName;	{}            In_VolRefNum := reply.VRefNum;	{Working Dir RefNum}          END;	   END;	{ WITH reply...}			 			 InVol_volnum := In_VolRefNum;			 Get_WDInfo(InVol_volname,InVol_DirID,InVol_volnum);(*numtostring(InVol_DirID,str1);str1 := concat('InVol_DirID ',str1);numtostring(InVol_volnum,str2);str2 := concat('InVol_volnum ',str2);numtostring(In_VolRefNum,str3);str3 := concat('WD num ',str3,' in GetFileName');putmessage(InVol_volname,str1,str2,str3);*)			GetFileName := Ok;		{Remember that the default vol is the last, not current, In_VolRefNum, a working		 directory number.}        err := FlushVol(NIL, reply.VRefNum);      END;                   { GetFileName } Function Interrupted : Boolean; begin	GetKeys(theKeys);	Interrupted := (theKeys[$37] AND theKeys[$2F]); end; (*    FUNCTION Interrupted     { : Boolean };{    purpose: To detect the interrupt signal (Command-period) from the user;             Looks for Cmd-'.' keyboard input.                Returns true only when command-period is entered,                        false otherwise.              Calls to this function should be imbedded in long, looping               routines where the main event loop will not pick up the               cmd-'.' from the keyboard first and interpret it as               a keydown event.  No real harm is done otherwise; the timing               is such that the test will always return false since the main               event handling routine clears the EventRec.           A typical usage of this function would be:                É                if abort_x = true then exit;                abort_x := Interrupted;                if abort_x = true then exit;                É            Placing groups of these three lines in EACH level of            an algorithm will provide a path back to the main level,            no matter at which level the interrupt occurs.}      VAR        KeyCh:              char;        theEvent:           EventRecord;      BEGIN        Interrupted := FALSE; {set returned value to false} ;        IF GetNextEvent(everyEvent, theEvent) = FALSE THEN exit(Interrupted); { if no event, then          skip}        IF (theEvent.modifiers <> 0) AND (cmdKey <> 0) THEN { Pass only command-chars }          BEGIN          KeyCh := CHR(BITAND(theEvent.message, charCodeMask));          IF KeyCh = '.' THEN Interrupted := True; {Return True when cmd-'.' found}        END;      END;	*)  Function ControlKeyDown : Boolean; begin	GetKeys(theKeys);	ControlKeyDown := (theKeys[$3B] OR theKeys[$3E]); end;  Function ShiftKeyDown :boolean;begin	GetKeys(theKeys);	ShiftKeyDown := theKeys[$38];end;  Function F1Down : Boolean; begin	GetKeys(theKeys);	F1Down := theKeys[$7A]; end; Function F2Down : Boolean; begin	GetKeys(theKeys);	F2Down := theKeys[$78]; end; Function F3Down : Boolean; begin	GetKeys(theKeys);	F3Down := theKeys[$63]; end; Function F4Down : Boolean; begin	GetKeys(theKeys);	F4Down := theKeys[$67]; end; Function F5Down : Boolean; begin	GetKeys(theKeys);	F5Down := theKeys[$60]; end; Function F6Down : Boolean; begin	GetKeys(theKeys);	F6Down := theKeys[$61]; end; Function F7Down : Boolean; begin	GetKeys(theKeys);	F7Down := theKeys[$62]; end; Function F8Down : Boolean; begin	GetKeys(theKeys);	F8Down := theKeys[$64]; end; Function F9Down : Boolean; begin	GetKeys(theKeys);	F9Down := theKeys[$65]; end; Function F10Down : Boolean; begin	GetKeys(theKeys);	F10Down := theKeys[$60]; end; Function F11Down : Boolean; begin	GetKeys(theKeys);	F11Down := theKeys[$67]; end; Function F12Down : Boolean; begin	GetKeys(theKeys);	F12Down := theKeys[$6F]; end; Function F13Down : Boolean; begin	GetKeys(theKeys);	F13Down := theKeys[$69]; end; Function F14Down : Boolean; begin	GetKeys(theKeys);	F14Down := theKeys[$6B]; end; Function F15Down : Boolean; begin	GetKeys(theKeys);	F15Down := theKeys[$71]; end; Function NKPZeroDown : Boolean; begin	GetKeys(theKeys);	NKPZeroDown := theKeys[$51]; end; Function NKP2Down : Boolean; begin	GetKeys(theKeys);	NKP2Down := theKeys[$54]; end; Function NKP8Down : Boolean; begin	GetKeys(theKeys);	NKP8Down := theKeys[$5B]; end; Function NKP4Down : Boolean; begin	GetKeys(theKeys);	NKP4Down := theKeys[$56]; end; Function NKP6Down : Boolean; begin	GetKeys(theKeys);	NKP6Down := theKeys[$58]; end;  Function G6_Del_Down : Boolean; begin	GetKeys(theKeys);	G6_Del_Down := theKeys[$75]; end; Function G6_End_Down : Boolean; begin	GetKeys(theKeys);	G6_End_Down := theKeys[$77]; end; Function G6_PgDn_Down : Boolean; begin	GetKeys(theKeys);	G6_PgDn_Down := theKeys[$79]; end; Function EscDown : Boolean; begin	GetKeys(theKeys);	EscDown := theKeys[$36]; end; Function SpaceBarDown : Boolean; begin	GetKeys(theKeys);	SpaceBarDown := theKeys[$31]; end; Function NKPClearDown : Boolean; begin	GetKeys(theKeys);	NKPClearDown := theKeys[$47]; end; Function NKPEqualDown : Boolean; begin	GetKeys(theKeys);	NKPEqualDown := theKeys[$51]; end; Function CapsLockDown : Boolean; begin	GetKeys(theKeys);	CapsLockDown := theKeys[$39]; end; Function RtnDown : Boolean; begin	GetKeys(theKeys);	RtnDown := theKeys[$24]; end;(* Function OptionKeyDown : Boolean; begin	GetKeys(theKeys);	OptionKeyDown := (theKeys[$3D] OR theKeys[$3A]); end; *) Function CommandPeriod : Boolean; begin	GetKeys(theKeys);	CommandPeriod := (theKeys[$37] AND theKeys[$2F]); end;      {[f-]}PROCEDURE Print_S(theSpectrum  : Integer;                   DataMax      : Real; 				  DataMin      : Real; 				  ChannelMin   : Integer;                  ChannelMax   : Integer; 				  Pix_X_Min    : Integer; 				  Pix_X_Max    : Integer;                  Pix_Y_Min    : Integer; 				  Pix_Y_Max    : Integer;				  Color		   : Integer; 				  PlotSymbol   : Integer;                  Connected    : Integer);    {[f+]}    VAR        Labs               : Labels ;		SlopeLabX          : Real;		SlopeLabY          : Real;		InterceptLabX      : Real;		InterceptLabY      : Real;        channel            : Integer;		Index              : Integer;		TempRect           : Rect;        Last_X             : Integer; 		Last_Y             : Integer;        j                  : Integer;        Xinc               : Real;		Yinc               : Real;        M                  : Real;        temp               : Real;        width              : Integer;        n,nn,offset           : Integer;        left,top           : integer;		str,str1,str2,str3,str4,str5 : str255;       Left_Val, Right_Val, increment: real;      Screen_increment, ch_increment : integer;	  ch_Left_Val, ch_Right_Val		 : integer;      strLeft, strRight             : Str255;      str_1, Str_2, str_3, Str_4, str_5, str_6, str_7, str_8, str_9: Str255;      errCode              : Integer;	  shift_D              : Integer;		{2/17/94}	  Counts_MidScale	   : real;		{2/17/94}PROCEDURE MAX_AND_MIN(Max, Min: Real);         VAR          Index:              Integer;        BEGIN          FOR Index := 1 TO 10 DO BEGIN            IF theSpectrum = Index THEN A^.DataMaxS[Index] := Max;            IF theSpectrum = Index THEN A^.DataMinS[Index] := Min;          END;               { for...}        END;                 {MAX_AND_MIN}FUNCTION Select_Scale(scal_Value : real): real;	VAR		val1, val2, Iscal_value			: longint;		ch_len, indx_z					: integer;		value_stng						: Str255;			BEGIN		Iscal_value := rinttol(scal_value);		NumToString(Iscal_value, value_stng);		ch_len := Ord(value_stng[0]) - 1;		val1 := 1;		for indx_z := 1 to ch_len do			val1 := val1 * 10;		val2 := Iscal_value DIV val1;		Select_Scale := val2 * val1;	END;      BEGIN  { ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥procedure Print_S¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥ }        thePrPort^.gPort.pnSize.h := 2;        thePrPort^.gPort.pnSize.v := 2;        Xinc := (Pix_X_Max - Pix_X_Min) / 10.24;        Yinc := (Pix_Y_Max - Pix_Y_Min) / 10;		(*thePrPort^.gPort.bkColor := blueColor;		thePrPort^.gPort.fgColor := whiteColor;*)Marker_Plot := True;Markers;Marker_Plot := False;		(*thePrPort^.gPort.fgColor := cyanColor;*)       {¥¥ Draw the axis ¥¥}        MoveTo(Pix_X_Min, Pix_Y_Min);        LineTo(Pix_X_Min, Pix_Y_Max); 		        MoveTo(Pix_X_Min, Pix_Y_Max);        LineTo(Pix_X_Max, Pix_Y_Max);		        MoveTo(Pix_X_Min, Pix_Y_Min);        LineTo(Pix_X_Max, Pix_Y_Min);		        MoveTo(Pix_X_Max, Pix_Y_Min);        LineTo(Pix_X_Max, Pix_Y_Max);		        FOR j := 1 TO 10 DO  {     put tics on       Y axis}          BEGIN          MoveTo(Pix_X_Max, rinttol(Pix_Y_Max - j * Yinc));          LineTo(Pix_X_Max - 5, rinttol(Pix_Y_Max - j * Yinc));        END;        FOR j := 1 TO 10 DO  {put tics on Y axis}          BEGIN          MoveTo(Pix_X_Min, rinttol(Pix_Y_Max - j * Yinc));          LineTo(Pix_X_Min + 5, rinttol(Pix_Y_Max - j * Yinc));        END;        FOR j := 1 TO 10 DO  {put tics on X axis}          BEGIN          MoveTo(rinttol(Pix_X_Min + j * Xinc), Pix_Y_Max);          LineTo(rinttol(Pix_X_Min + j * Xinc), Pix_Y_Max - 5);        END;        FOR j := 1 TO 10 DO  {put tics on X axis}          BEGIN          MoveTo(rinttol(Pix_X_Min + j * Xinc), Pix_Y_Min);          LineTo(rinttol(Pix_X_Min + j * Xinc), Pix_Y_Min + 5);        END;        thePrPort^.gPort.pnSize.h := 1;        thePrPort^.gPort.pnSize.v := 1;        IF ChannelMin < 1 THEN ChannelMin := 1;        IF ChannelMax > Spectrum_Size THEN ChannelMax := Spectrum_Size;        IF (Auto_Scale_Display = FALSE) THEN BEGIN          DataMax := V_Scale_Top; { V_Scale_Top and V_Scale_Bottom are globals that }          DataMin := V_Scale_Bottom; { get manipulated in the SiLi_Window section }          IF (Log_Scale_Display = True) THEN BEGIN            IF (DataMin > - 1) OR (DataMin < 1) THEN DataMin := 1;            DataMin := - Log10(ABS(DataMin));		{Ln(ABS(DataMin))}			DataMax := Select_Scale(V_Scale_Top);          END;        END;        IF DataMax <= DataMin + 1E-32 THEN DataMax := DataMin + 1E-32;        IF (Auto_Scale_Display = True) THEN BEGIN          IF (Log_Scale_Display = True) THEN BEGIN            DataMax := Log10(DataMax);		{Ln(DataMax)}            IF (DataMin > - 1) OR (DataMin < 1) THEN DataMin := 1;            DataMin := - Log10(ABS(DataMin));	{Ln(ABS(DataMin))}          END;          IF (Square_Root_Display = True) THEN BEGIN            DataMax := sqrt(DataMax);            DataMin := - sqrt(ABS(DataMin));          END        END;        IF (Bipolar_Display = True) THEN DataMin := - DataMax;        { Label the vertical axis with info from the "top" displayed spectrum. }        MAX_AND_MIN(DataMax, DataMin);        FOR Index := 1 TO 10 DO BEGIN          IF Spectrum_Full[Index] THEN BEGIN            Counts_FullScale := A^.DataMaxS[Index];            Counts_BottomScale := A^.DataMinS[Index];            VLabelColor := Index;          END;        END;                 { for ...}        { Here, Pix_Y_Max is the top of the plotting envioronment }        IF (Bipolar_Display = True) THEN BEGIN          slopeY := - (Pix_Y_Max - (Pix_Y_Max - Pix_Y_Min) / 2) / DataMax;          InterceptY := - (Pix_Y_Max - Pix_Y_Min) / 2;        END        ELSE BEGIN          slopeY := (Pix_Y_Max - Pix_Y_Min) / (DataMax - DataMin);          InterceptY := Pix_Y_Min - slopeY * DataMin;        END;        slopeX := (Pix_X_Max - Pix_X_Min) / (ChannelMax - ChannelMin);        InterceptX := Pix_X_Min - slopeX * ChannelMin;		 		  temp := slopeX * ChannelMin + InterceptX;		  if temp <= Pix_X_Min then temp := Pix_X_Min;        WITH Plt_Spec[theSpectrum]^^ DO BEGIN          IF (Log_Scale_Display = True) THEN            MoveTo(rinttol(temp), rinttol(slopeY * Log10(s[ChannelMin]) + InterceptY))		{Ln(s[ChannelMin])}          ELSE            IF (Square_Root_Display = True) THEN              MoveTo(rinttol(temp), rinttol(slopeY * sqrt(s[ChannelMin]) + InterceptY))            ELSE              IF (Linear_Display = True) THEN                MoveTo(rinttol(temp), rinttol(slopeY * (s[ChannelMin]) + InterceptY) );        END;                 { WITH...}        IF PlotSymbol = 1 THEN BEGIN          thePrPort^.gPort.pnSize.h := 1;          thePrPort^.gPort.pnSize.v := 1;        END;        IF PlotSymbol = 3 THEN BEGIN          thePrPort^.gPort.pnSize.h := 2;          thePrPort^.gPort.pnSize.v := 1;        END;        IF PlotSymbol = 4 THEN BEGIN          thePrPort^.gPort.pnSize.h := 1;          thePrPort^.gPort.pnSize.v := 2;        END;        IF PlotSymbol = 5 THEN BEGIN          thePrPort^.gPort.pnSize.h := 2;          thePrPort^.gPort.pnSize.v := 2;        END;        Last_X := 1;        {¥¥¥¥ Main Plotting loop¥¥¥¥}        WITH Plt_Spec[theSpectrum]^^ DO BEGIN          FOR channel := ChannelMin TO ChannelMax DO BEGIN            IF (Log_Scale_Display = True) THEN              Y_Pixel := rinttol(slopeY * Log_Plot(s[channel]) + InterceptY)            ELSE              IF (Square_Root_Display = True) THEN                Y_Pixel := rinttol(slopeY * Square_Root_Plot(s[channel]) + InterceptY)              ELSE                IF (Linear_Display = True) THEN                  Y_Pixel := rinttol(slopeY * (s[channel]) + InterceptY);            IF (Y_Pixel < Pix_Y_Max) THEN Y_Pixel := Pix_Y_Max;            IF (Y_Pixel > Pix_Y_Min) THEN Y_Pixel := Pix_Y_Min; { Pix_Y_Max here means the bottom of                                                                 the screen as per Quickdraw                                                                 convention }            X_Pixel := rinttol(slopeX * channel + InterceptX);                IF Connected = 0 THEN BEGIN                  IF PlotSymbol = 2 { Draw a plus }                     THEN BEGIN                    colorPPtr^.pnSize.h := 1;                    colorPPtr^.pnSize.v := 1;                    MoveTo(X_Pixel - 2, Y_Pixel);                    LineTo(X_Pixel + 2, Y_Pixel);                    MoveTo(X_Pixel, Y_Pixel - 2);                    LineTo(X_Pixel, Y_Pixel + 2);                  END                  ELSE                    IF PlotSymbol = 6 { Draw a square }                       THEN BEGIN                      colorPPtr^.pnSize.h := 1;                      colorPPtr^.pnSize.v := 1;                      MoveTo(X_Pixel - 2, Y_Pixel - 2);                      LineTo(X_Pixel - 2, Y_Pixel + 2);                      LineTo(X_Pixel + 2, Y_Pixel + 2);                      LineTo(X_Pixel + 2, Y_Pixel - 2);                      LineTo(X_Pixel - 2, Y_Pixel - 2);                    END                    ELSE     { Draw what was chosen above other than 2 or 6 }                      BEGIN                      MoveTo(X_Pixel, Y_Pixel);                      LineTo(X_Pixel, Y_Pixel);                    END;                END;                IF Connected = 1 { line plot }                   THEN BEGIN                  LineTo(X_Pixel, Y_Pixel);                END;            Last_X := X_Pixel;            Last_Y := Y_Pixel;          END;               { for channel...}        END;                 { WITH...}        IF (Bipolar_Display = True) OR (Auto_Scale_Display = True) THEN BEGIN          thePrPort^.gPort.pnSize.h := 1;          thePrPort^.gPort.pnSize.v := 1;		  temp := InterceptX;		  if temp <= Pix_X_Min then temp := Pix_X_Min;           MoveTo(rinttol(temp), rinttol(InterceptY));          LineTo(rinttol(slopeX * ChannelMax + InterceptX), rinttol(InterceptY));        END;           Labs  := Lab^^ ; { Copy the entire label record into a temporary one to allow rescaling }          SlopeLabY := (PrintWindow.Top - PrintWindow.Bottom)/		               (Full_Top_Screen - Full_Bottom_Screen);		  InterceptLabY := PrintWindow.Top - SlopeLabY * Full_Top_Screen;		            SlopeLabX := (PrintWindow.Right - PrintWindow.Left)/		               (Full_Right_Screen - Full_Left_Screen);		  InterceptLabX := PrintWindow.Right - SlopeLabX * Full_Right_Screen;		  		  		  For nn := 1 to MaxLabels do  		  			IF (Labs.S[nn].Exists)  THEN 			   BEGIN			    Labs.S[nn].Box.Top := rinttol(SlopeLabY * Lab^^.S[nn].Box.Top + InterceptLabY);			    Labs.S[nn].Box.Left := rinttol(SlopeLabX * Lab^^.S[nn].Box.Left + InterceptLabX);				NumToString(Labs.S[nn].Box.Top,str1);				NumToString(Labs.S[nn].Box.Left,str2);				{putmessage('top and left are',str1,str2,'');}			   END;		  For nn := 1 to MaxLabels do  	  			IF (Labs.S[nn].Exists)  THEN 			  BEGIN			    TempRect.Left :=  Labs.S[nn].Box.Left ;				TempRect.Top :=   Labs.S[nn].Box.Top ;				SetRect(TempRect, TempRect.Left, 								  TempRect.Top, 								  TempRect.Left + 35, 								  TempRect.Top + 12);				                PutSymbol( TempRect,                           'Monaco', 					       LabelSize,					       [],					       Labs.S[nn].Element,					       Labs.S[nn].Family,					       Labs.S[nn].Greek );			  END;        SetFont('helvetica', 12, [bold]);        MoveTo(rinttol(0.5 * (PrintWindow.Right - PrintWindow.Left)) + PrintWindow.Left - 25,               PrintWindow.Bottom + 30);		if ((NOT Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV) AND (WDS_Active))	then		DrawString('Channel')		else		DrawString('keV');        SetFont('helvetica', 10, [bold]);		      {¥ LEFT ¥}      if ((NOT Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV) AND (WDS_Active))	then begin		  ch_Left_Val := 0;		  ch_Right_Val := Plt_Spec[10]^^.SpectrumStuff.Acq_Info.LastChannel;		  NumToString(ch_Left_Val, strLeft);		  strLeft := Strip_Trailing_Blanks(strLeft);					  NumToString(ch_Right_Val, strRight);		  strRight := Strip_Trailing_Blanks(strRight);					  ch_increment := rinttol((ch_Right_Val - ch_Left_Val) / 10);		  Screen_increment := rinttol((PrintWindow.Right - PrintWindow.Left) / 10.2);			  NumToString(ch_Left_Val + ch_increment, str_1);		  str_1 := Strip_Trailing_Blanks(str_1);		  NumToString(ch_Left_Val + 2 * ch_increment, Str_2);		  Str_2 := Strip_Trailing_Blanks(Str_2);		  NumToString(ch_Left_Val + 3 * ch_increment, str_3);		  str_3 := Strip_Trailing_Blanks(str_3);		  NumToString(ch_Left_Val + 4 * ch_increment, Str_4);		  Str_4 := Strip_Trailing_Blanks(Str_4);		  NumToString(ch_Left_Val + 5 * ch_increment, str_5);		  str_5 := Strip_Trailing_Blanks(str_5);		  NumToString(ch_Left_Val + 6 * ch_increment, str_6);		  str_6 := Strip_Trailing_Blanks(str_6);		  NumToString(ch_Left_Val + 7 * ch_increment, str_7);		  str_7 := Strip_Trailing_Blanks(str_7);		  NumToString(ch_Left_Val + 8 * ch_increment, str_8);		  str_8 := Strip_Trailing_Blanks(str_8);		  NumToString(ch_Left_Val + 9 * ch_increment, str_9);		  str_9 := Strip_Trailing_Blanks(str_9);	  end	  else begin		  IF Calibrate_Energy_Scale THEN			Left_Val := ((ChannelMin * Plt_spec[10]^^.Expt_Info.dE / 1000) - Plt_spec[10]^^.Expt_Info.Energy_Intercept /						1000) / Plt_spec[10]^^.Expt_Info.Energy_Slope		  ELSE Left_Val := ChannelMin * Plt_spec[10]^^.Expt_Info.dE / 1000;		  Left_Val := ABS(Left_Val - Plt_spec[10]^^.Expt_Info.dE / 1000); { take care of a little numerical imprecision}		  RealToString(Left_Val, 4, 2, strLeft);		  strLeft := Strip_Trailing_Blanks(strLeft);			  M := (8000 - ChannelMin) / (8192 - ChannelMin);		  temp := ChannelMax * M + (8000 - M * 8192); {Calculate the value at the 10th tic mark}			  IF Calibrate_Energy_Scale THEN			Right_Val := ((temp * Plt_spec[10]^^.Expt_Info.dE / 1000) - Plt_spec[10]^^.Expt_Info.Energy_Intercept / 1000) /						 Plt_spec[10]^^.Expt_Info.Energy_Slope		  ELSE Right_Val := temp * Plt_spec[10]^^.Expt_Info.dE / 1000;		  RealToString(Right_Val, 4, 2, strRight);		  strRight := Strip_Trailing_Blanks(strRight);		  increment := (Right_Val - Left_Val) / 10;		  Screen_increment := rinttol((PrintWindow.Right - PrintWindow.Left) / 10.2);			  RealToString(Left_Val + increment, 4, 2, str_1);		  str_1 := Strip_Trailing_Blanks(str_1);		  RealToString(Left_Val + 2 * increment, 4, 2, Str_2);		  Str_2 := Strip_Trailing_Blanks(Str_2);		  RealToString(Left_Val + 3 * increment, 4, 2, str_3);		  str_3 := Strip_Trailing_Blanks(str_3);		  RealToString(Left_Val + 4 * increment, 4, 2, Str_4);		  Str_4 := Strip_Trailing_Blanks(Str_4);		  RealToString(Left_Val + 5 * increment, 4, 2, str_5);		  str_5 := Strip_Trailing_Blanks(str_5);		  RealToString(Left_Val + 6 * increment, 4, 2, str_6);		  str_6 := Strip_Trailing_Blanks(str_6);		  RealToString(Left_Val + 7 * increment, 4, 2, str_7);		  str_7 := Strip_Trailing_Blanks(str_7);		  RealToString(Left_Val + 8 * increment, 4, 2, str_8);		  str_8 := Strip_Trailing_Blanks(str_8);		  RealToString(Left_Val + 9 * increment, 4, 2, str_9);		  str_9 := Strip_Trailing_Blanks(str_9);	  end; 		  		  MoveTo(PrintWindow.Left - 7, PrintWindow.Bottom + 15);          RGBForeColor(Axes_Color);          {EraseRect(LeftHLCGPtr^.portPixMap^^.Bounds);}          DrawString(strLeft);		  		  shift_D := 28 - (5 - length(strRight)) * 5;	{2/17/94}		                MoveTo(PrintWindow.Right - shift_D, PrintWindow.Bottom + 15);              DrawString(strRight);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_9);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 2 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_8);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 3 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_7);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 4 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_6);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 5 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_5);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 6 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(Str_4);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 7 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_3);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 8 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(Str_2);              MoveTo(rinttol(((PrintWindow.Right - shift_D) - 9 * Screen_increment)), PrintWindow.Bottom + 15);              DrawString(str_1);        IF (rinttol(Counts_FullScale) <> Counts_FullScale) AND (rinttol(Counts_FullScale) < 50) { no             need for real axis above 50 }           THEN              { Determined whether integer or real }          RealToString(Counts_FullScale, 5, 2, Str) { and setup appropriate format }        ELSE NumToString(rinttol(Counts_FullScale), Str);        width := 6;				shift_D := 8 + LENGTH(Str) * width;	{2/17/94}		        { do some right side justification to pretty things up}		MoveTo(PrintWindow.Left - shift_D, PrintWindow.Top + 5);	{2/17/94}        DrawString(Str);     {¥¥¥¥¥¥¥¥write the upper vertical axis label}        IF (rinttol(Counts_BottomScale) <> Counts_BottomScale) AND (ABS(Counts_BottomScale) < 50) { no             need for real axis above 50 }           THEN              { Determined whether integer or real }          RealToString(Counts_BottomScale, 3, 2, Str) { and setup appropriate format }        ELSE NumToString(rinttol(Counts_BottomScale), Str);		        { do some right side justification to pretty things up}				   shift_D := 8 + LENGTH(Str) * width;	{2/17/94}		MoveTo(PrintWindow.Left - shift_D, PrintWindow.Bottom + 4);	{2/17/94}        DrawString(Str);     {¥¥¥¥¥¥¥¥¥write the lower vertical axis label}				IF NOT Log_Scale_Display THEN BEGIN			Screen_increment := (PrintWindow.Top - PrintWindow.Bottom) DIV 5;	{2/17/94}			increment := (Counts_FullScale - Counts_BottomScale)/5;			for Index := 1 to 4 do begin			Counts_MidScale := Counts_BottomScale + Index * increment;			IF (rinttol(Counts_MidScale) <> Counts_MidScale) AND (ABS(Counts_MidScale) < 50) { no				 need for real axis above 50 }			   THEN              { Determined whether integer or real }			  RealToString(Counts_MidScale, 3, 2, Str) { and setup appropriate format }			ELSE NumToString(rinttol(Counts_MidScale), Str);			shift_D := 8 + LENGTH(Str) * width;	{2/17/94}			MoveTo(PrintWindow.Left - shift_D, PrintWindow.Bottom + 4 + Index * Screen_increment);	{2/17/94}			DrawString(Str);     {¥¥¥¥¥¥¥¥¥write the mid vertical axis labels}			end;		{for Index := 1 to 4 }	{2/17/94}		end;		        SetFont('helvetica', 12, [Bold]);        MoveTo(PrintWindow.Left - 30, PrintWindow.Bottom + 45);		IF NOT No_Header_in_Print then BEGIN	{2/16/94}        IF Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Number > 0 THEN BEGIN          Str :=  Plt_Spec[10]^^.Expt_Info.Specimen_ID ;          DrawString(Str);        END;		n := 0;		offset := 15;        Left := PrintWindow.Left - 30;		Top := PrintWindow.Bottom + 60;        SetFont('helvetica', 10, []);        MoveTo(Left, Top);        Str := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field;		if Length(Str) > 106 then 		BEGIN		  str1 := COPY(str,1,106);		  str2 := COPY(str,107,Length(Str) - 106);		  Str1 := Strip_Trailing_Blanks(Str1);		  Str2 := Strip_Trailing_Blanks(Str2);		  DrawString(str1); n := n+1; moveto(Left,Top + n*offset);		  DrawString(str2); n := n+1; moveto(Left,Top + n*offset); 		END ELSE		begin		  DrawString(str); 		  n := n+1; 		  moveto(Left,Top + n*offset);		end;        RealToString(Plt_Spec[10]^^.Expt_Info.kV, 5, 2, str2);        RealToString(Plt_Spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday, 5, 2, str3);        RealToString(Plt_Spec[10]^^.SpectrumStuff.Acq_Info.Live_Time, 5, 2, str4);        RealToString(Plt_Spec[10]^^.Expt_Info.dE, 5, 2, str5);        Str := CONCAT('Analyst: ', Plt_Spec[10]^^.Expt_Info.Analyst, '      keV: ', str2,                      '      Current: ', str3, '      Live Time: ', str4, '      eV/Channel= ',                      str5);        DrawString(str); n := n+1; moveto(Left,Top + n*offset);         if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then        RealToString(Plt_Spec[10]^^.Expt_Info.Si_Resolution, 5, 2, str1);        if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then        RealToString(Plt_Spec[10]^^.Expt_Info.WDS_Resolution, 5, 2, str1);        str3 := '';		errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);		RdBinaryName := Read_DTSA_Spec.name;		IF errCode = NoErr THEN		  BEGIN			numtostring(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number,str4);		    str3 := CONCAT('Spectrum # ',str4,' From the file: ',RdBinaryName);		  END;  		errCode := FSClose(Hold_RefNum);		errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);		        RealToString(Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle, 5, 2, str2);        Str := CONCAT('Detector Resolution: ', str1, ' eV', '      Take-off angle= ', str2,'         ',str3 );        DrawString(str); n := n+1; moveto(Left,Top + n*offset);						if ShowMarkers then 		 begin		   NumToString(Atomic_Number, Str);		   str1 := CONCAT('Markers for ',A^.Sym[Atomic_Number], ',   ',str);		   DrawString(str1);		 end;		END;	{ IF NOT No_Header_in_Print 2/16/94}      END;                   { procedure Print_S }	  	  PROCEDURE DrawStuff(theWorld: Rect);      VAR        Index:              Integer;      BEGIN        FOR Index := 10 DOWNTO 1 DO BEGIN          IF Spectrum_Full[Index] THEN BEGIN            Print_S(Index,   { array to be plotted }                    Plt_Spec[Index]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts, { DataMax }                    Plt_Spec[Index]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts, { DataMin }                    ChannelMin, { }                    ChannelMax, { }                    theWorld.Left, { Full_Left_Screen, Pix_X_Min }                    theWorld.Right, { Full_Right_Screen, Pix_X_Max }                    theWorld.Bottom, { Full_Bottom_Screen, Pix_Y_Min }                    theWorld.Top, { Full_top_Screen Pix_Y_Max }                    A^.Plot_Color[Index], { }                    A^.Plot_Symbol[Index], { }                    A^.Plot_Connected[Index]); { }          END;        END;                 { for index...}      END;                   {End of procedure}PROCEDURE PrintStuff;      VAR        oldPort:            GrafPtr;       BEGIN	  if ((not demo_DTSA) or (Plt_Spec[10]^^.SpectrumStuff.spectrum_Info.spare2)) then	  begin	   	  		GetPort(OldPort);           IF PrValidate(thePrRec) = True THEN            PutMessage('There is an incompatibility with the current',                       'version of the Printing Manager and the currently installed printer', '',                       '');          thePrPort := PrOpenDoc(thePrRec, NIL, NIL); { Open printing grafport, see II-155, IM}          IF PrError = noErr THEN 		  BEGIN            PrOpenPage(thePrPort, NIL); { start a new page }            IF PrError = noErr THEN 			BEGIN			  PrintWindow.Left := thePrRec^^.prInfo.rPage.Left + 			                      rinttol(0.08 * thePrRec^^.prInfo.rPage.Right);              PrintWindow.Right := thePrRec^^.prInfo.rPage.Right - 			                      rinttol(0.02 * thePrRec^^.prInfo.rPage.Right);              PrintWindow.Top := thePrRec^^.prInfo.rPage.Top + 			                      rinttol(0.02 * thePrRec^^.prInfo.rPage.Bottom);              PrintWindow.Bottom := thePrRec^^.prInfo.rPage.Bottom - 			                        rinttol(0.19 * thePrRec^^.prInfo.rPage.Bottom);              DrawStuff(PrintWindow); { the MCA quickdraw code }            END;            PrClosePage(thePrPort); {terminate the page} 		             PrCloseDoc(thePrPort); {close the printing grafport}          IF (thePrRec^^.prJob.bJDocLoop = bSpoolLoop) AND (PrError = noErr) THEN            PrPicFile(thePrRec, NIL, NIL, NIL, theStatus); {if supported, print spooled documents }        END;        SetPort(oldPort);	   END	   ELSE putmessage('I`m sorry but I can print only spectra supplied with the demo disk.','','','');      END;     {=================================}    FUNCTION GetDNum(theDialog: DialogPtr; item: Integer): Real;      VAR        itemType:           Integer;        itemBox:            Rect;        itemHdl:            Handle;        Str:                Str255;        n:                  Real;      BEGIN        GetDialogItem(theDialog, item, itemType, itemHdl, itemBox);        GetDialogItemText(itemHdl, Str);        n := MyStr2Num(Str);        GetDNum := n;      END;PROCEDURE SetDNum(theDialog: DialogPtr; item: Integer; n: Real);      VAR        itemType:           Integer;        itemBox:            Rect;        itemHdl:            Handle;        Str:                Str255;      BEGIN        GetDialogItem(theDialog, item, itemType, itemHdl, itemBox);        RealToString(n, 5,3, Str);        SetDialogItemText(itemHdl, Str)      END;    FUNCTION GetReal         { (message: Str255; default: real): real };      CONST        NumberID            = 3;      VAR        mylog:              DialogPtr;        item:               Integer;        temp:               real {double_t};      BEGIN        ParamText(message, '', '', '');        mylog := GetNewDialog(3000, NIL, POINTER( - 1));        SetDNum(mylog, NumberID, default);        SelectDialogItemText(mylog, NumberID, 0, 32767);        OutlineButton(mylog, Ok, 16);        REPEAT          ModalDialog(NewModalFilterProc(@DefaultFilter), item);        UNTIL (item = Ok) OR (item = Cancel);        IF item = Ok THEN 		BEGIN          temp := GetDNum(mylog, NumberID);			   IF (temp > - 1E32) AND (temp <= 1E32) THEN GetReal :=  temp 			   ELSE BEGIN				 BeepBeep;				 temp := - 1E-32			   END;        END        ELSE GetReal := default;        DisposeDialog(mylog);        Mouse_Active_Window;      END;PROCEDURE wait           { (Ticks: Longint) };      VAR        SaveTicks:          Longint;      BEGIN        SaveTicks := TickCount + Ticks;        REPEAT        UNTIL TickCount > SaveTicks;      END;	  	  	function Filter (    theDialog : DialogPtr;					 var theEvent  : EventRecord;					 var itemHit   : integer): boolean;		{ ¥¥¥¥¥  Do NOT put this function into the calling procedure, 		         or the address will get trashed when needed ¥¥¥¥¥¥ }								CONST		I_Done                        = 1;		I_Cancel					  = 2;		kVisualDelay				  = 8;		kReturnKey					  = $0D;		kEnterKey					  = $03;		kEscapeKey					  = $1B; 		kPeriodKey					  = $2E;	var			tempRect: Rect;	  DType                         : integer;	  DItem                         : Handle;	  CItem			                : controlhandle;			temp: Longint;			DataLen: Integer;	  finalTicks					: Longint;	  key							: Char;	begin		Filter := FALSE;		str_info := '  1';		itemhit := 0;		if (theEvent.what = MouseDown) then    {Only do on a mouse click}			begin			    dataLen := 3;				Rect_Point := theEvent.where;     {Get the point where the mouse was clicked}				GlobalToLocal(Rect_Point);				if PtInRect(Rect_Point, Rect_I_Spectra) then					begin					  DoubleClick := LClick(Rect_Point, theEvent.modifiers, List_I_Spectra);					  if (DoubleClick) then					  begin						if (not saved_displayed) then 						    if (not Answermessage('You are about to overwrite the unsaved spectrum in work!!!!!',										   'If "It`s OK" I`ll put up your selection.',										   '','')) then DoubleClick := false; 						if DoubleClick then BeepBeep;					  end;						{next call returns cell clicked in, single or double}						List_I_Spectra^^.lastClick := LLastClick(List_I_Spectra);						{next call gets the info from the cell identified in previous call}					    LGetCell(Pointer(ord(@str_info) + 1), 						         dataLen, List_I_Spectra^^.lastClick, 								 List_I_Spectra);										StringToNum(str_info, temp);						itemHit := integer(temp + 10);						Filter := TRUE;					end;    					{End of PtInRect}        END	{ IF (theEvent.what = MouseDown) }	  ELSE	    CASE theEvent.what OF			keyDown, Autokey:	{user pressed a key}			BEGIN				key := Char(BAnd(theEvent.message, charCodeMask));				IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN				  BEGIN				    GetDialogItem(theDialog, I_Done, DType, DItem, tempRect);        			CItem := controlHandle(DItem);							{invert the OK button for user feedback}					HiliteControl(CItem, kControlButtonPart);					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(CItem, 0);					Filter := TRUE;								{event's being handled}					itemHit := I_Done;								{return the default button}				  END;				END; { keyDown, Autokey }			END;{CASE theEvent.what}			end;	procedure D_Spectrum_Picker;	  const		   I_Accept = 1;		   I_x = 2;    { 0,0,19,620}      var 			ExitDialog : boolean; 						jj     : Integer;			bytecount : Longint;			tempRect : Rect;			textRect : Rect;			DType : Integer;			Index : Integer;			index1: Integer;			DItem : Handle;			str_3 : string[3];			sTemp : Str255;			itemHit : Integer;			Ltemp : Longint;			dataBounds : Rect;			cSize : Point;			err  : OSErr;	        str,str1,str2,str3,str4,str5,str6,str7   : str255;			ThrowAway : boolean;			Spec_Stuff :WorkS;	{handle to all spectrumstructures}	procedure Refresh_Dialog; 		var 			otherRect:Rect; 	 		begin 			SetPort(PickWindow);			GetDialogItem(PickWindow,I_Accept,DType,DItem,otherRect);			PenSize(3, 3);			InsetRect(otherRect, -4, -4);			FrameRoundRect(otherRect, 16, 16); 			PenSize(1, 1);			LUpdate(PickWindow^.visRgn,List_I_Spectra);	{should redraw everything}	   end; 	 	 	{Add the strings to the list} 	procedure Add_List_String(theString:str255{fnamestr is too short};  theList:ListHandle); 		var 			theRow:integer;	 		begin 			if (theList <> nil) then 			begin				cSize.h := 0;				theRow := LAddRow(1, 500, theList);	 				cSize.v := theRow;				sTemp:= theString;				LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize,theList);				LDraw(cSize, theList);			end; 	end; 	 	 	begin	{the DITL has two items: the QUIT box, and the editable info box at head of list}			PickWindow := GetNewDialog(1938, nil,  Pointer(-1) );{this is a dialogptr,-1=>frontwindow}            MoveWindow(PickWindow,MaxWindowRect.Left,MaxWindowRect.Bottom-123,TRUE );			ShowWindow(PickWindow);	{makes it visible}			SelectWindow(PickWindow); {makes it the active window & front window, hilights}			SetPort(PickWindow);			SetRect(Rect_I_Spectra,2,20,563,115); { the info box above this is 0,0,19,620 }			tempRect:= Rect_I_Spectra;			tempRect.Right:= tempRect.Right - 15;			if (tempRect.Right<= (tempRect.Left + 15)) then				tempRect.Right := tempRect.Left + 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			InsetRect(tempRect, 1, 1);			SetRect(dataBounds, 0, 0, 1, 0);	{bounds for a 1 col, no row list: LAddRow does}			cSize.h := tempRect.Right - tempRect.Left;			cSize.v := 0;			List_I_Spectra:=  LNew(tempRect, 			                       dataBounds, 								   cSize, 								   0, 								   PickWindow, 								   TRUE, 								   FALSE, 								   FALSE, 								   TRUE);			List_I_Spectra^^.selFlags := lOnlyOne + lNoNilHilite;			LSetDrawingMode(False, List_I_Spectra);            str7 := 'Single click on list item to get info. ¥¥¥Double click¥¥¥ to read it in.';			GetDialogItem(PickWindow, I_x, DType, DItem, textRect);							SetDialogItemText(DItem, str7);{putmessage('in Utilities: RdBinaryName is',RdBinaryName,'','');}			err := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);			RdBinaryName := Read_DTSA_Spec.name;			{ ¥¥¥Do not use the error			       reporting version here since in some cases the file is already open when we				   drop in here and we do not need the error }			jj := 0;		    Restore_Expt_Header( Hold_RefNum );					 					IF (Plt_Spec[10]^^.Expt_info.RefFile) then begin	{¥¥¥¥¥ The Ref_Stuff Handle was made in the CALLING routine UNLESS we come here via	       SCAN in SiLi Window. In that case the handle is not defined so do that.¥¥¥¥¥}			  			  if (Ref_Stuff = NIL) then {must make the handle...since this is a global hdl			                             made in Initialize.p when is this true???} 			  begin			    beepbeep;beepbeep;beepbeep;			  	Ref_Stuff := RefS(NewHandle(sizeof(References_rec)));			  	HLock(Handle(Ref_Stuff));				ThrowAway := true;		      end			  else ThrowAway := false;               For Index := 1 to Maximum_Channels do Plt_Spec[10]^^.S[Index] := 0.0;			   			  err := setfpos_Err(Hold_RefNum,fsfromstart,0,'D_Spectrum_Picker at 2');			  Spectrum_counter := 1;						  bytecount:=sizeof(expt_infoRec) ;              err := FSRead_err(Hold_RefNum, bytecount, 			                    @Plt_Spec[10]^^.Expt_info,'D_Spectrum_Picker at 3');						  bytecount := Sizeof(References_Rec);			  For Index := Plt_spec[10]^^.Expt_Info.FirstSpec to 						 Plt_spec[10]^^.Expt_Info.LastSpect  do			  begin				 SpinCursor;              				 err := FSRead_err(Hold_RefNum, bytecount, @Ref_Stuff^^,'D_Spectrum_Picker at 4');				  str1:='   ';				  jj := jj+1;				  numToString(jj, str);				  realToString(Ref_Stuff^^.LoE_Line,5,2, str4);				  realToString(Ref_Stuff^^.HiE_Line,5,2, str5);				  if jj<10 then str_3:=concat('  ',str[1])				  else if jj<100 then str_3:=concat(' ',str[1],str[2])				  else if jj<1000 then str_3:=concat(str[1],str[2],str[3]);				  Str := CONCAT(str_3, ': ', A^.Sym[Ref_Stuff^^.Atomic_Number],Ref_Stuff^^.Family,				               ' lines ',str4,'ev to ',str5,'ev; from ',Ref_Stuff^^.source);  		          Add_List_String(Str, List_I_Spectra); 		      end; { for Index := ...}			  LSetDrawingMode(TRUE, List_I_Spectra);				  cSize.v := 0;				  LSetSelect(TRUE, cSize, List_I_Spectra);				  ChangeCursor(ArrowC);			End	{ If (RefFile)...}			Else 			Begin			  	Spec_Stuff := WorkS(NewHandle(sizeof(Work_Spectrum)));			  	HLock(Handle(Spec_Stuff));				err := setfpos_err(Hold_RefNum, fsFromstart, 0,'D_Spectrum_Picker at 5');				{Spectrum_counter := 0;}				For Index := Plt_spec[10]^^.Expt_Info.FirstSpec to 							 Plt_spec[10]^^.Expt_Info.LastSpect  do				begin				  SpinCursor;  				  ByteCount := longint(Index-1) * ( sizeof(Spectrum_Structure) +							   Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ) +							   sizeof(Expt_InfoRec) + sizeof(Plot_infoRec);				 {using index...				  Spectrum_Counter := Spectrum_Counter +1;} {# of spectrum displayed}					  NumToString(Index,str1);					  NumToString(ByteCount,str2);					  NumToString(Index,str3);					  Str4 := CONCAT('7:  Spectrum_Counter= ',str1,'  ByteCount= ',str2,' Index= ',str3);				  err := setfpos_err(Hold_RefNum,fsfromStart,bytecount,str4);				  bytecount := sizeof(Spectrum_Structure);				  err := FSread_err(Hold_RefNum, bytecount, @Spec_Stuff^^.SpectrumStuff,Str4);				  bytecount := Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;				  err := setfpos_err(Hold_RefNum, fsFromMark, bytecount,'D_Spectrum_Picker at 8');						   jj := jj+1;						   numToString(jj, str); 						   if jj<10 then str_3:=concat('  ',str[1])						   else if jj<100 then str_3:=concat(' ',str[1],str[2])						   else if jj<1000 then str_3:=concat(str[1],str[2],str[3]);				  Str := CONCAT(str_3, ': ', 								Spec_Stuff^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);				  Add_List_String(Str, List_I_Spectra); {Add in the new string}			   			 end; { For Index := Plt_spec[10]^^.Expt_Info.FirstSpect to 				                Plt_spec[10]^^.Ezpt_Info.LastSpect }				LSetDrawingMode(TRUE, List_I_Spectra);				  cSize.v := 0;				  LSetSelect(TRUE, cSize, List_I_Spectra);	 			  												ChangeCursor(ArrowC);				            end; { else...}			{Setup initial conditions}			Refresh_Dialog; 			 				ExitDialog:=FALSE;		itemhit:=0;{¥¥¥¥¥}	REPEAT			ModalDialog(NewModalFilterProc(@Filter), itemHit); 		  	   IF (ItemHit = I_Accept) then ExitDialog:=TRUE	   ELSE BEGIN		LTemp := itemHit-10; {Ltemp is the "number" of the spectrum clicked}		IF ((LTemp < 999) and (LTemp >0)) then begin				 	  	   IF (Plt_Spec[10]^^.Expt_info.RefFile) THEN BEGIN			 { Spectrum_Counter := LTemp;}			  err := setfpos_err(Hold_RefNum,fsfromstart,0,'D_Spectrum_Picker at 9');			  			  bytecount := sizeof(expt_infoRec) + (longint(LTemp) - 1) * Sizeof(References_Rec);			  err := setfpos_Err(Hold_RefNum,fsfromstart,bytecount,'');			  bytecount := Sizeof(References_Rec);			  err := FSread_err(hold_refnum, bytecount, @Ref_Stuff^^,'');			  if (Ref_Stuff^^.bkg_subtd <> true) and (Ref_Stuff^^.bkg_subtd <> false) then			  begin				  if answermessage('If IT`S OK,',								   'I will assume this reference is background subtracted.','','')				  then Ref_Stuff^^.bkg_subtd := true				  else Ref_Stuff^^.bkg_subtd := false;				  bytecount := -bytecount;				  err := SetFPos_err(hold_refnum, fsFromMark,bytecount,'');				  bytecount := -bytecount;				  err := FSWrite(hold_refnum, bytecount, @Ref_Stuff^^);			  end;			  RealToString(Ref_Stuff^^.FWHM_Mn,5,2,str2);			  RealToString(Ref_Stuff^^.dE,5,2,str3);			  RealToString(Plt_Spec[10]^^.Expt_Info.kV,5,2,str6);			  RealToString(Ref_Stuff^^.area,5,2,str1);			  str7 := CONCAT(' ',str6,'keV, dE= ',str3,'eV, FWHM(Mn) = ',str2,'eV, area = ',str1 );			  			  			  if (DoubleClick)			   then begin			      Spectrum_Counter := LTemp;				  Spec_Displayed := LTemp; 				  For Index := 1 to Maximum_Channels do Plt_Spec[10]^^.S[Index] := 0.0;				  index1 := 0;				  FOR index := rinttol(Ref_Stuff^^.Begin_Energy/Ref_Stuff^^.dE)							  to rinttol(Ref_Stuff^^.End_Energy/Ref_Stuff^^.dE) do begin					  index1:=index1+1;					  Plt_Spec[10]^^.S[index] := Ref_Stuff^^.data[index1];					  end;				  WITH Plt_Spec[10]^^, Expt_Info, SpectrumStuff,Spectrum_Info,acq_info DO					BEGIN					  Begin_Time :=  Ref_Stuff^^.datemade; 					  Spectrum_Number := Spectrum_Counter;					  theoretically_generated := Ref_Stuff^^.generated;					  realToString(Ref_Stuff^^.LoE_Line,5,2, str4);					  realToString(Ref_Stuff^^.HiE_Line,5,2, str5);					  {the following is for SHOW HEADER and info below plot}					  Spectrum_Class := CONCAT(A^.Sym[Ref_Stuff^^.Atomic_Number],											   Ref_Stuff^^.Family,											   ' ',str4,'->',str5,'ev');{25 chars max}					  if  theoretically_generated then 						Spectrum_Comment_Field := Ref_Stuff^^.comments					  else Spectrum_Comment_Field := 						concat('Data from ',Ref_Stuff^^.source,'; ',Ref_Stuff^^.comments); 					END; { WITH...}				  Auto_Scale_Display := False;				  SetControlValue(AutoScale_CtrlHandle, 0);				  Linear_Display := True;							  Spectrum_Full[10] := True;                  UpDate_Max_Min(10);				  V_Scale_Top := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts; 		 			  end;	{If DoubleClick...}			END	{ If (Plt_Spec[10]^^.Expt_info.RefFile)...}			ELSE BEGIN	{ display DTSA spectrum }			  {Spectrum_Counter := LTemp;}			  ByteCount := (Ltemp-1) * (sizeof(Spectrum_Structure) +										Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ) +							sizeof(Expt_InfoRec) + sizeof(Plot_infoRec); 				      			  err := setfpos_err(Hold_RefNum,fsfromStart,bytecount,'D_Spectrum_Picker at 12');			  bytecount := sizeof(Spectrum_Structure) + 4 * Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels);			  err := FSread_err(Hold_RefNum, bytecount, @Spec_Stuff^^.SpectrumStuff,'D_Spectrum_Picker at 13');			   			  str2 := Spec_Stuff^^.SpectrumStuff.Spectrum_Info.Spectrum_Class; 			  RealToString(Spec_Stuff^^.SpectrumStuff.Acq_Info.Begin_Faraday,5,2,str5); 			  RealToString(Spec_Stuff^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle,5,2,str1);			  RealToString(Spec_Stuff^^.SpectrumStuff.Acq_Info.Live_Time,5,2,str4); 			  RealToString(Plt_spec[10]^^.Expt_Info.kV,4,2,str6);			 			  str7 := CONCAT('Class= ',str2,',  Cur=', str5, ' nA,  ',str4,' Secs.,  TOA= ',str1,'¡,   ',str6,' kV' );			  if (DoubleClick) then				  begin				    BlockMove(@Spec_Stuff^^.SpectrumStuff,@Plt_spec[10]^^.SpectrumStuff,bytecount);				    Spectrum_Counter := LTemp;					Spec_Displayed := Spectrum_Counter;											Spectrum_Full[10] := True;					UpDate_Max_Min(10);				  end;								END; { If (Plt_Spec[10]^^.Expt_info.RefFile)...Else Begin...}				        		   if (DoubleClick) then			 begin	 					 CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);					 Refresh_ROIs;							 Update_Full;			  					 SpecWork_has_been_Changed := true;					 saved_displayed := true;					 {the following are because Update_Full does a RGB before exiting} 					 forecolor(blackcolor);					 backcolor(whitecolor);			 end;	{if (DoubleClick)...}						GetDialogItem(PickWindow, I_x, DType, DItem, textRect);							SetDialogItemText(DItem, str7);	    	Refresh_Dialog;					END;	{ if LTEMP...}	   END; { IF (ItemHit = I_Accept)..ELSE BEGIN...}	   	  UNTIL ExitDialog;			If not Plt_Spec[10]^^.Expt_info.RefFile then			       H_UnLock_Dispose( Handle(Spec_Stuff),'D_Spectrum_Picker' )			Else If (ThrowAway) then begin	{ThrowAway true only if here from LLSQ unit}				H_UnLock_Dispose( Handle(Ref_Stuff),'D_Spectrum_Picker' );				beepbeep;beepbeep;beepbeep;beepbeep;			end;		   			   LDispose(List_I_Spectra);				DisposeDialog(PickWindow);	{removes from window list, previous first restored?}				err := FSClose(Hold_RefNum);				err := FlushVol(NIL, Read_DTSA_Spec.vRefNum);				forecolor(bluecolor);                Mouse_Active_Window;			 (*   if not display_ref then UpDate_Max_Min(10);*)                Refresh_ROIs;	END;	{procedure D_Spectrum_Picker...}		  END.                         { of UNIT Utilities }          