UNIT KEVEX_DELTA_PRO_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils,{ PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE KEVEX_DELTA_PRO(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:KEVEX_DELTA_PRO(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='KEVEX DELTA PRO';		{Debugstr('Inside of KEVEX_DELTA_PRO - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE KEVEX_DELTA_PRO(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);    TYPE	TByte                         = PACKED ARRAY [1..1] OF byte;    tBuffer                 = PACKED ARRAY [1..10000] OF signedbyte;    tBufPtr                 = ^tBuffer;    VAR      xx, X_Tilt, TOA               : real;      End_of_File, nn               : longint;      Current_File_Position         : longint;	  FileSize               		: longint;      bytecount                     : longint;	  indexL                        : longint;      n, counter, kk            	: integer;      err                           : integer;      refnum                        : integer;      Value                         : Extended;      theType                       : OSType;      str			                : str255;      errCode                       : OSErr;      reply                         : SFReply;      FStr	                    	: str255;	  strLength                     : TByte;	  tipBufPtr                     : tBufPtr;    BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of ReadTracorFile');}		InPtr^.Specimen_Comment_Field := '';						nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		indexL := 0;        strLength[1] := 21;        BlockMove(@strLength, @str[0], 1);        FOR nn := 1 TO 200 DO { move into the buffer up to 200 characters until the string "File format:  Lotus" found, and register from this}          BEGIN            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            IF str = '"File format:  Lotus"' THEN begin                indexL := indexL + 1; {next char}				LEAVE;			end			ELSE begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(KEVEX_DELTA_PRO);			end;      	  END;		WHILE (tipBufPtr^[indexL] <> $0D {cr} ) DO		{ Spectrum file: }			indexL := indexL + 1; {next char}				indexL := indexL + 1; {next char}	        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $3A {:} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := str;				indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $22 {"} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN 			InPtr^.Specimen_Comment_Field := CONCAT(InPtr^.Specimen_Comment_Field, ' ', str);		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN 			InPtr^.kV := str2num(str);		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN 			X_Tilt := str2num(str);		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN 			TOA := str2num(str);		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN 		  InPtr^.dE := str2num(str);		  IF (InPtr^.dE < 5) OR (InPtr^.dE > 80) THEN InPtr^.dE := 10.0;		indexL := indexL + 1;		WHILE (tipBufPtr^[indexL] <> $0D {cr} ) DO			indexL := indexL + 1; {next char}				indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		IF (LENGTH(str) > 0) THEN  begin			  InPtr^.Begin_Faraday := str2num(str);			  InPtr^.End_Faraday := str2num(str);			end;		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO          			indexL := indexL + 1; { jump over a run of spaces, tabs or lf }        str := '';		REPEAT			indexL := indexL + 1; {next char}		UNTIL (tipBufPtr^[indexL] = $2C {,} );		indexL := indexL + 1; {next char}        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		IF (LENGTH(str) > 0) THEN  begin		  InPtr^.Real_Time := str2num(str);		  InPtr^.Live_Time := str2num(str);		end;				FOR n := 1 to 8 DO begin			WHILE (tipBufPtr^[indexL] <> $0D {cr} ) DO		{ skip 8 lines }				indexL := indexL + 1; {next char}						indexL := indexL + 1; {next char}			end; {FOR}      WITH InPtr^ DO        BEGIN          FOR kk := 1 TO 250 DO            FOR n := 1 TO 250 DO              IF (Specimen_Comment_Field[n] = ' ') AND (Specimen_Comment_Field[n + 1] = ' ') THEN                delete(Specimen_Comment_Field, n, 1);        END; { with }				kk := 1;        REPEAT {еееее This REPEAT part reads in the spectrum еееее}          FStr := ''; {еееее This fragment reads a channel еееее}          WHILE ((tipBufPtr^[indexL] = $20 {sp} ) OR		  		(tipBufPtr^[indexL] = $09 {tab} ) OR				(tipBufPtr^[indexL] = $0A {lf} )  OR				(tipBufPtr^[indexL] = $2C {,} )) DO            indexL := indexL + 1; { jump over a run of spaces/tabs/lfs }          WHILE ((tipBufPtr^[indexL] <> $20 {sp} ) AND		  		 (tipBufPtr^[indexL] <> $09 {tab}) AND				 (tipBufPtr^[indexL] <> $0D {cr} ) AND				 (tipBufPtr^[indexL] <> $0A {lf} ) AND				 (tipBufPtr^[indexL] <> $2C {,} )) DO            BEGIN              FStr := CONCAT(FStr, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;            END; { While }          IF LENGTH(FStr) > 0 THEN            BEGIN              InPtr^.Spec_cts[kk] := str2num(FStr);              kk := kk + 1;            END;          indexL := indexL + 1;        UNTIL indexL >= FileSize; {еееее}		InPtr^.Number_of_Channels := kk;		InPtr^.LastChannel := kk;		theResult := noErr;    END; { еееее KEVEX_DELTA PRO еееее}{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.