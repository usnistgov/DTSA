(*{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]}*){*********************************} UNIT MathWin ;{*********************************}{**********************************} INTERFACE {**********************************} USES    QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Dialogs, Controls, Windows, Script,   Packages, Printing, StandardFile, Spectrum_Structures, Retrace, SegLoad, fenv, fp {SANE, StrLib},TextUtils, Events,  Declarations, INITIALIZE, Global_Functions, Utilities, Physics, Physics_Windows;(*{[f+]}*) PROCEDURE D_Math_Window;PROCEDURE Add_Noise;PROCEDURE D_Noise_Spectra;FUNCTION  PoissonRandomNums(xm: real): real;PROCEDURE D_Smooth_Options;PROCEDURE Smooth; PROCEDURE D_Digital_Filter_Param; PROCEDURE Digital_Filter;PROCEDURE First_Derivative; { Col_1^ in, Col_1^ out. Uses Col_3^ for scratch }(*{[f-]}*){******************************} IMPLEMENTATION {**********************************}(*{[f+]}*){$S MathWin} CONST        I_TextBox = 44;  { info box in main Calculator dialog}		I_WW = 49;       { Edit text in main Calculator dialog}		I_XX = 50;       { Edit text }		I_YY = 51;       { Edit text }		I_ZZ = 52;       { Edit text }VAR		List_I_Spectra                : ListHandle;    Ran3Inext,Ran3Inextp: integer;   Ran3Ma: ARRAY [1..55] OF real;    PROCEDURE D_Smooth_Options;CONST      Smooth_Ops_Accept             = 1;      Smooth_Ops_5_Point            = 3;      Smooth_Ops_7_Point            = 4;      Smooth_Ops_9_Point            = 5;      Smooth_Ops_Gaussian_Convolve  = 6;      Smooth_Ops_Cancel             = 2;	      VAR      GetSelection                 : DialogPtr;             tempRect                     : Rect;                  DType                        : Integer;               Index                        : Integer;               DItem                        : Handle;                CItem			               : ControlHandle;         itemHit                      : Integer;               temp                         : Integer;               Smooth_Ops_ExitDialog        : Boolean;	  where						   : point;	  	procedure Refresh_Dialog; 	 		begin 			SetPort(GetSelection);			GetDialogItem(GetSelection,Smooth_Ops_Accept,DType,DItem,tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1); 	    end;           BEGIN	        GetSelection := GetNewDialog(422, NIL, pointer( - 1)); 	  CenterDialog(GetSelection, TRUE, where);				{¥¥¥new RLM¥¥¥}      ShowWindow(GetSelection);                             SelectWindow(GetSelection);                           SetPort(GetSelection);                                      GetDialogItem(GetSelection, Smooth_Ops_5_Point, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);	  	  Refresh_Dialog;      Smooth_Ops_ExitDialog := False;                             REPEAT                                                  ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);                            GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);         CItem := controlhandle(DItem);                              {Handle it real time}        IF (itemHit = Smooth_Ops_Accept)          THEN                                                    BEGIN              Smooth_Ops_ExitDialog := True;                      END;				        IF (itemHit = Smooth_Ops_Cancel)          THEN                                                    BEGIN			  KludgeBoolean := true;              Smooth_Ops_ExitDialog := True;                END;        IF (itemHit >= Smooth_Ops_5_Point) AND (itemHit <= Smooth_Ops_Gaussian_Convolve)          THEN                                                    BEGIN              FOR Index := Smooth_Ops_5_Point TO Smooth_Ops_Gaussian_Convolve DO {Clear all other                 radios}                BEGIN                  GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                   SetControlValue(controlhandle(DItem), 0);                          END;                                                SetControlValue(CItem, 1);                              END;      UNTIL Smooth_Ops_ExitDialog;                          Index := Smooth_Ops_5_Point;                          REPEAT                                                  GetDialogItem(GetSelection, Index, DType, DItem, tempRect);         temp := GetControlValue(controlhandle(DItem));                           Index := Index + 1;                                 UNTIL (temp <> 0) OR (Index > Smooth_Ops_Gaussian_Convolve);       temp := Index - Smooth_Ops_5_Point;                   IF (temp = 1) THEN Points_for_Smooth := 5;      IF (temp = 2) THEN Points_for_Smooth := 7;      IF (temp = 3) THEN Points_for_Smooth := 9;      IF (temp = 4) THEN Points_for_Smooth := 1;                  { Gaussian convolve }      DisposeDialog(GetSelection);	  Mouse_Active_Window;	  Update_Full; { ¥needed }    END;                                              {End of procedure}   PROCEDURE D_Digital_Filter_Param;CONST      DF_Accept                     = 1;      DF_Center_Lobe                = 6;      DF_Left_Lobe                  = 7;      DF_Right_Lobe                 = 8;      DF_Defaults                   = 10;      DF_Cancel                     = 2;	      VAR      GetSelection                 : DialogPtr;             tempRect                     : Rect;                  DType                        : Integer;               DItem                        : Handle;                CItem			               : ControlHandle;         sTemp                        : Str255;                itemHit                      : Integer;               str  : str255;      DF_ExitDialog                : Boolean;	  where						   : point;	      PROCEDURE Refresh_Dialog;                               VAR        rTempRect                    : Rect;                BEGIN		SetPort(GetSelection);		GetDialogItem(GetSelection,DF_Accept,DType,DItem,tempRect);		PenSize(3, 3);		InsetRect(tempRect, -4, -4);		FrameRoundRect(tempRect, 16, 16); 		PenSize(1, 1); 	          rTempRect := tempRect;                                PenSize(6, 6);		        MoveTo(29, 175);                             { Draw the "top hat" }        LINETO(81, 175);        MoveTo(82, 123);        LINETO(82, 174);        MoveTo(87, 123);         LINETO(139, 123);        MoveTo(140, 123);        LINETO(140, 174);        MoveTo(144, 174);        LINETO(196, 174);        PenSize(1, 1);        tempRect := rTempRect;                              END;    BEGIN                                                   GetSelection := GetNewDialog(454, NIL, pointer( - 1));	  CenterDialog(GetSelection, TRUE, where);				{¥¥¥new RLM¥¥¥}      ShowWindow(GetSelection);                             SelectWindow(GetSelection);                           SetPort(GetSelection);                                                       GetDialogItem(GetSelection, DF_Center_Lobe, DType, DItem, tempRect);      numToString(Center_Lobe, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, DF_Left_Lobe, DType, DItem, tempRect);      numToString(Left_Lobe, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, DF_Right_Lobe, DType, DItem, tempRect);      numToString(Right_Lobe, str);      SetDialogItemText(DItem, str);      Refresh_Dialog;                                       Cancel_Boolean := False;      DF_ExitDialog := False;                               REPEAT                                                  ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);                            GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);         CItem := controlhandle(DItem);                              IF (itemHit = DF_Accept)          THEN                                                    BEGIN              DF_ExitDialog := True;                                Refresh_Dialog;            END;        IF (itemHit = DF_Cancel)          THEN                                                    BEGIN			  KludgeBoolean := True;			  DisposeDialog(GetSelection);                     			  Mouse_Active_Window;			  Cancel_Boolean := True;			  EXIT(D_Digital_Filter_Param);                           END;        IF (itemHit = DF_Defaults)          THEN                                                    BEGIN			if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then			  Left_Lobe := rinttol(Plt_spec[10]^^.Expt_Info.Si_Resolution / (2 * Plt_spec[10]^^.Expt_Info.dE));			if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then			  Left_Lobe := rinttol(Plt_spec[10]^^.Expt_Info.WDS_Resolution / (2 * Plt_spec[10]^^.Expt_Info.dE));			  Right_Lobe := Left_Lobe;              Center_Lobe := 2 * Left_Lobe; 			  GetDialogItem(GetSelection, DF_Center_Lobe, DType, DItem, tempRect);			  numToString(Center_Lobe, str);			  SetDialogItemText(DItem, str);					  GetDialogItem(GetSelection, DF_Left_Lobe, DType, DItem, tempRect);			  numToString(Left_Lobe, str);			  SetDialogItemText(DItem, str);					  GetDialogItem(GetSelection, DF_Right_Lobe, DType, DItem, tempRect);			  numToString(Right_Lobe, str);			  SetDialogItemText(DItem, str);			              Refresh_Dialog;            END;			      UNTIL DF_ExitDialog;                                        GetDialogItem(GetSelection, DF_Center_Lobe, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            StringToNum(sTemp, Center_Lobe);            GetDialogItem(GetSelection, DF_Left_Lobe, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            StringToNum(sTemp, Left_Lobe);            GetDialogItem(GetSelection, DF_Right_Lobe, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            StringToNum(sTemp, Right_Lobe);            IF Left_Lobe <> Right_Lobe              THEN                BEGIN				  BeepBeep;                  putmessage('In this incarnation of the program the two side lobes must have',				             'the same number of Channels to keep the Filter symetric.', '', '');                  Right_Lobe := Left_Lobe;                  D_Digital_Filter_Param;                END;      DisposeDialog(GetSelection);                           Mouse_Active_Window;    END;                                              {End of procedure}  PROCEDURE Smooth;    BEGIN      Smooth_Spectrum(Plt_Spec[10]^^.S, Plt_Spec[9]^^.S, Points_for_Smooth );      UpDate_Max_Min(9);      ChangeCursor(ArrowC);    END;                                              { procedure Smooth }	      	  	    PROCEDURE Cummulate; { Col_1^ in, Col_1^ out. Uses Col_3^ for scratch }    VAR      nn                           : Integer;      Total                        : real;    BEGIN      Total := zero;	  For nn := 1 to Maximum_Channels do Col_3^[nn] := 0.0;      FOR nn := 1 TO Spectrum_Size DO        BEGIN          Total := Total + Col_1^[nn]*Plt_spec[10]^^.Expt_Info.dE;          Col_3^[nn] := Total;        END;	Col_1^[1]:= (Col_3^[1])/2;      FOR nn := 2 TO Spectrum_SIze DO        BEGIN          Col_1^[nn] := (Col_3^[nn]+Col_3^[nn-1])/2;        END;    END;                                              { Procedure Cummulate }  PROCEDURE First_Derivative; { Col_1^ in, Col_1^ out. Uses Col_3^ for scratch }    VAR      nn                           : Integer;    BEGINFor nn := 1 to Maximum_Channels do Col_3^[nn] := 0.0;{ Leftmost points }Col_3^[1] := ( - 25 * Col_1^[1] + 48 * Col_1^[2] - 36 * Col_1^[3]						+ 16 * Col_1^[4] - 3 * Col_1^[5]) / 						(12 * Plt_spec[10]^^.Expt_Info.dE);Col_3^[2] := ( - 25 * Col_1^[2] + 48 * Col_1^[3] - 36 * Col_1^[4]						+ 16 * Col_1^[5] - 3 * Col_1^[6]) / 						(12 * Plt_spec[10]^^.Expt_Info.dE);{ Rightmost points }  nn:=Spectrum_Size;			     Col_3^[nn] := ( - 25 * Col_1^[nn] + 48 * Col_1^[nn - 1]							- 36 * Col_1^[nn - 2] + 16 * Col_1^[nn -3]							- 3 * Col_1^[nn - 4]) / ( - 12 * Plt_spec[10]^^.Expt_Info.dE);  Col_3^[nn-1] := ( - 25 * Col_1^[nn-1] + 48 * Col_1^[nn - 2]							- 36 * Col_1^[nn - 3] + 16 * Col_1^[nn -4]							- 3 * Col_1^[nn - 5]) / ( - 12 * Plt_spec[10]^^.Expt_Info.dE);      FOR nn := 3 TO Spectrum_Size-2 DO        BEGIN                  Col_3^[nn] := (Col_1^[nn - 2] - 8 * Col_1^[nn - 1] + 				                           8 * Col_1^[nn + 1] - Col_1^[nn + 2]) / 										   (12 * Plt_spec[10]^^.Expt_Info.dE);        END;BlockMove(@Col_3^, @Col_1^, Sizeof(Col_1^));	       END;                                              { procedure First_Derivative }  PROCEDURE Second_Derivative; { Col_1^ in, Col_1^ out. Uses Col_3^ for scratch }    VAR      nn                           : Integer;    BEGIN	For nn := 1 to Maximum_Channels do Col_3^[nn] := 0.0;			  { Leftmost points }	  Col_3^[1] := (2 * Col_1^[1] - 5 * Col_1^[2] + 4 * Col_1^[3] 								- Col_1^[4]) / 								(Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);	  Col_3^[2] := (2 * Col_1^[2] - 5 * Col_1^[3] + 4 * Col_1^[4] - Col_1^[5]) / 	                            (Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);              { Rightmost points }				nn:=Spectrum_Size;				                    Col_3^[nn-1] := (2 * Col_1^[nn-1] - 5 * Col_1^[nn - 2]				  							+ 4 * Col_1^[nn - 3] - Col_1^[nn - 4]) / 									   (Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);                  Col_3^[nn] := (2 * Col_1^[nn] - 5 * Col_1^[nn - 1]				  							+ 4 * Col_1^[nn - 2] - Col_1^[nn - 3]) / 								        (Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);      FOR nn := 3 TO Spectrum_Size-2 DO        BEGIN                  Col_3^[nn] := ( - Col_1^[nn - 2] + 16 * Col_1^[nn - 1]				  							- 30 * Col_1^[nn] + 16 * Col_1^[nn + 1]											- Col_1^[nn + 2]) / 									(12 * Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);        END;                      BlockMove(@Col_3^, @Col_1^, Sizeof(Col_1^));    END;                                              { procedure Second_Derivative }  PROCEDURE FastFourierTransform(In_Sp, Out_Sp, isign: Integer);    VAR      ii, JJ, n, nn, mmax, M, j, istep, i: Integer;      wtemp, wr, wpr, wpi, wi, theta: real {double_t};      tempr, tempi                 : real {double_t};    BEGIN      nn := Spectrum_Size;                            { number of points to fft }      IF isign = 1        THEN          BEGIN            FOR i := 1 TO 2 * nn DO theFFTHdl^^.FFTdata[i] := zero;            FOR i := 1 TO nn DO theFFTHdl^^.FFTdata[2 * i - 1] := Plt_Spec[In_Sp]^^.S[i];          END;      n := 2 * nn;      j := 1;      FOR ii := 1 TO nn DO        BEGIN          i := 2 * ii - 1;          IF (j > i)            THEN              BEGIN                tempr := theFFTHdl^^.FFTdata[j];                tempi := theFFTHdl^^.FFTdata[j + 1];                theFFTHdl^^.FFTdata[j] := theFFTHdl^^.FFTdata[i];                theFFTHdl^^.FFTdata[j + 1] := theFFTHdl^^.FFTdata[i + 1];                theFFTHdl^^.FFTdata[i] := tempr;                theFFTHdl^^.FFTdata[i + 1] := tempi;              END;                                    {if (j>i)}          M := n DIV 2;          WHILE ((M >= 2) AND (j > M)) DO            BEGIN              j := j - M;              M := M DIV 2;            END;          j := j + M        END;      mmax := 2;      WHILE (n > mmax) DO        BEGIN          istep := 2 * mmax;          theta := 6.28318530717959 / (isign * mmax);          wpr := - 2.0 * sqr(SIN(0.5 * theta));          wpi := SIN(theta);          wr := 1.0;          wi := zero;          FOR ii := 1 TO (mmax DIV 2) DO            BEGIN              M := 2 * ii - 1;              FOR JJ := 0 TO ((n - M) DIV istep) DO                BEGIN;                  i := M + JJ * istep;                  j := i + mmax;                  tempr := wr * theFFTHdl^^.FFTdata[j] - wi * theFFTHdl^^.FFTdata[j + 1];                  tempi := wr * theFFTHdl^^.FFTdata[j + 1] + wi * theFFTHdl^^.FFTdata[j];                  theFFTHdl^^.FFTdata[j] := theFFTHdl^^.FFTdata[i] - tempr;                  theFFTHdl^^.FFTdata[j + 1] := theFFTHdl^^.FFTdata[i + 1] - tempi;                  theFFTHdl^^.FFTdata[i] := theFFTHdl^^.FFTdata[i] + tempr;                  theFFTHdl^^.FFTdata[i + 1] := theFFTHdl^^.FFTdata[i + 1] + tempi;                END;                                  {for jj}              wtemp := wr;              wr := wr * wpr - wi * wpi + wr;              wi := wi * wpr + wtemp * wpi + wi            END;                                      {for ii}          mmax := istep;        END;                                          {while (n>mmax)}      IF isign = 1        THEN          BEGIN            FOR i := 1 TO (Spectrum_Size DIV 2) DO              BEGIN                Plt_Spec[Out_Sp]^^.S[2 * i] := sqrt(theFFTHdl^^.FFTdata[2 * i] * 								                               theFFTHdl^^.FFTdata[2 * i] + 															   theFFTHdl^^.FFTdata[2 * i + 1] *                                                               theFFTHdl^^.FFTdata[2 * i + 1]);                Plt_Spec[Out_Sp]^^.S[2 * i - 1] := Plt_Spec[9]^^.S[2 * i];                IF Plt_Spec[Out_Sp]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < 				   Plt_Spec[In_Sp]^^.S[i]                  THEN                    Plt_Spec[Out_Sp]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := 					                                         Plt_Spec[In_Sp]^^.S[i];                IF Plt_Spec[Out_Sp]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > 				   Plt_Spec[In_Sp]^^.S[i]                  THEN                    Plt_Spec[Out_Sp]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 					Plt_Spec[In_Sp]^^.S[i];              END;          END;(*      IF isign = - 1        THEN          BEGIN            FOR i := 1 TO Spectrum_Size DO              BEGIN                Plt_Spec[In_Sp]^^.S[i] := theFFTHdl^^.FFTdata[2 * i - 1] / Spectrum_Size;                IF Plt_Spec[In_Sp]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < 				   Plt_Spec[In_Sp]^^.S[i]                  THEN                    Plt_Spec[In_Sp]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := 					Plt_Spec[In_Sp]^^.S[i];                IF Plt_Spec[In_Sp]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > 				   Plt_Spec[In_Sp]^^.S[i]                  THEN                    Plt_Spec[In_Sp]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 					Plt_Spec[In_Sp]^^.S[i];              END;          END;      Plt_Spec[7]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;      Plt_Spec[7]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;      Plt_Spec[8]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;      Plt_Spec[8]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;      FOR i := 1 TO Spectrum_Size - 1 DO        BEGIN          Plt_Spec[7]^^.S[i] := theFFTHdl^^.FFTdata[i];          IF Plt_Spec[7]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_Spec[7]^^.S[i]            THEN Plt_Spec[7]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[7]^^.S[i];          IF Plt_Spec[7]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_Spec[7]^^.S[i]            THEN Plt_Spec[7]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[7]^^.S[i];          Plt_Spec[8]^^.S[i] := theFFTHdl^^.FFTdata[i + 1];          IF Plt_Spec[8]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_Spec[8]^^.S[i]            THEN Plt_Spec[8]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[8]^^.S[i];          IF Plt_Spec[8]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_Spec[8]^^.S[i]            THEN Plt_Spec[8]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[8]^^.S[i];        END;	*)			    END;                                              {FastFourierTransform}FUNCTION ran3(VAR idum: integer): real;  CONST      mbig = 1000000000;  mseed=161803398;  mz=0;  fac=1.0e-9;VAR      i,ii,k,mj,mk: longint;  BEGIN   IF idum < 0 THEN BEGIN      mj := mseed+idum;      IF mj >= 0.0 THEN         mj := mj-mbig*rinttol(mj/mbig)      ELSE       (*  mj := mbig-abs(mj)+mbig*rinttol(abs(mj)/mbig);*)    mj := mj MOD mbig;       Ran3Ma[55] := mj;      mk := 1;      FOR i := 1 TO 54 DO BEGIN         ii := 21*i MOD 55;         Ran3Ma[ii] := mk;         mk := mj-mk;         IF mk < mz THEN mk := mk+mbig;         mj := rinttol{Num2LongInt}(Ran3Ma[ii]);      END;      FOR k := 1 TO 4 DO BEGIN         FOR i := 1 TO 55 DO BEGIN            Ran3Ma[i] := Ran3Ma[i]-Ran3Ma[1+((i+30) MOD 55)];            IF Ran3Ma[i] < mz THEN Ran3Ma[i] := Ran3Ma[i]+mbig         END      END;      Ran3Inext := 0;      Ran3Inextp := 31;      idum := 1   END;   Ran3Inext := Ran3Inext+1;   IF Ran3Inext = 56 THEN      Ran3Inext := 1;   Ran3Inextp := Ran3Inextp+1;   IF Ran3Inextp = 56 THEN Ran3Inextp := 1;   mj := rinttol{Num2LongInt}(Ran3Ma[Ran3Inext]-Ran3Ma[Ran3Inextp]);   IF mj < mz THEN mj := mj+mbig;   Ran3Ma[Ran3Inext] := mj;   ran3 := mj*facEND; FUNCTION gasdev(VAR idum: integer): real;VAR   fac,r,v1,v2: real;BEGIN   IF GasdevIset = 0 THEN BEGIN      REPEAT         v1 := 2.0*ran3(idum)-1.0;         v2 := 2.0*ran3(idum)-1.0;         r := sqr(v1)+sqr(v2);      UNTIL (r < 1.0) AND (r > 0.0);      fac := sqrt(-2.0*ln(r)/r);      GasdevGset := v1*fac;      gasdev := v2*fac;      GasdevIset := 1   END   ELSE BEGIN      GasdevIset := 0;      gasdev := GasdevGset;   ENDEND;{$S MathWindow2}PROCEDURE Calculate ;VAR 	nn, Spectrum_size       : Integer;	tempR1   				: real;	DType    				: Integer;				DItem    				: Handle;    str,str5   				: str255;BEGIN Spectrum_size := Plt_Spec[Clmn1]^^.Expt_Info.Number_of_Channels;if (Clmn3 >10 ) or (Clmn3 < 1 ) then  begin  putmessage('column 3 designation in the calculator got wrong','','','');   exit(Calculate); end;if (Clmn2 >10 ) or (Clmn2 < 1 ) then  begin  putmessage('column 2 designation in the calculator got wrong','','','');  exit(Calculate); end;if (Clmn1 >10 ) or (Clmn1 < 1 ) then  begin  putmessage('column 1 designation in the calculator got wrong','','','');  exit(Calculate); end;if Coperator = 1 then                                   { Copy the header of "A" into "C" }  begin	BlockMove(@Plt_Spec[Clmn3]^^.S, @Col_2^, Sizeof(Col_2^)); 	BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); 	BlockMove(@Col_2^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));   end; if Coperator = 2 then                                         { Rotate "A" and "C" without header }  begin    BlockMove(@Plt_Spec[Clmn1]^^.S, @Col_1^, Sizeof(Col_1^));		BlockMove(@Plt_Spec[Clmn3]^^.S, @Col_2^, Sizeof(Col_2^));	BlockMove(@Col_1^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));	BlockMove(@Col_2^, @Plt_Spec[Clmn1]^^.S, Sizeof(Plt_Spec[Clmn1]^^.S));	UpDate_Max_Min(Clmn1);    end;if Coperator = 3 then    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy "A" into "C" with header }	if Coperator = 4 then                                   { w * "A" into "C" }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }	FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := WW * Plt_Spec[Clmn1]^^.S[nn];  end;  if Coperator = 5 then                                   { A + w = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    FOR nn := 1 TO Spectrum_Size DO	 Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] + WW;   end;if Coperator = 6 then                                   { A + w * B = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] + WW * Plt_Spec[Clmn2]^^.S[nn];  end;if Coperator = 7 then                                   { A - w * B = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] - WW * Plt_Spec[Clmn2]^^.S[nn];  end;if Coperator = 8 then                                   { A * w * B = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] * WW * Plt_Spec[Clmn2]^^.S[nn];  end;if Coperator = 9 then                                   { A / (w * B) = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	  BEGIN	    Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] / (WW * Plt_Spec[Clmn2]^^.S[nn]);		if Plt_Spec[Clmn2]^^.S[nn] = 0 then Plt_Spec[Clmn3]^^.S[nn] := zero;	  END;	  end;if Coperator = 10 then                                   { A squared = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] * Plt_Spec[Clmn1]^^.S[nn];  end;if Coperator = 11 then                                   { A root = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := SQRT(Plt_Spec[Clmn1]^^.S[nn]) ;   end;if Coperator = 12 then                                   { A Poisson Randomized = C }  begin   BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	  begin	    if Plt_Spec[Clmn1]^^.S[nn] > 0.0 then		begin		spincursor;	    Plt_Spec[Clmn3]^^.S[nn] :=  PoissonRandomNums( Plt_Spec[Clmn1]^^.S[nn] ); 		end		else		Plt_Spec[Clmn3]^^.S[nn] := zero;	  end;	  ChangeCursor(ArrowC);   end;if Coperator = 13 then                                   { A Normally Randomized = C }  begin  BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "A" header info to "C" as default}     seed_z := -ABS(seed_z); { force negative }    FOR nn := 1 TO Spectrum_Size DO	  BEGIN	   tempR1 := gasdev(seed_z); { tempR1 now random on ¥open¥ interval (-1,1) }	   Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] + tempR1 * 	                              SQRT(Plt_Spec[Clmn1]^^.S[nn]) ;	  END;     end;if Coperator = 14 then                                   { A 5 point smoothed = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    Smooth_Spectrum(Plt_Spec[Clmn1]^^.S, Plt_Spec[Clmn3]^^.S, 5 );   end;if Coperator = 15 then                                   { A 7 point smoothed = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    Smooth_Spectrum(Plt_Spec[Clmn1]^^.S, Plt_Spec[Clmn3]^^.S, 7 );   end;if Coperator = 16 then                                   { A 9 point smoothed = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    Smooth_Spectrum(Plt_Spec[Clmn1]^^.S, Plt_Spec[Clmn3]^^.S, 9 );   end;if Coperator = 17 then                                   { A Convolved with detector response = C }  begin	 If ( SiLi_Response_Calculated) then  	 BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, Sizeof(Det_Effic_P^))	 Else Detector_efficiency(theBGRec,SiLi_Response_Calculated);    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    Smooth_Spectrum(Plt_Spec[Clmn1]^^.S, Plt_Spec[Clmn3]^^.S, 1 );   end;if Coperator = 18 then                                   { A differentiated once = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    BlockMove(@Plt_Spec[Clmn1]^^.S, @Col_1^, Sizeof(Col_1^));;    First_Derivative;	BlockMove(@Col_1^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));   end;if Coperator = 19 then                                   { A differentiated twice = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    BlockMove(@Plt_Spec[Clmn1]^^.S, @Col_1^, Sizeof(Col_1^));;      Second_Derivative;	BlockMove(@Col_1^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));   end;if Coperator = 20 then                                   { A cumulatively integrated = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    BlockMove(@Plt_Spec[Clmn1]^^.S, @Col_1^, Sizeof(Col_1^));;      Cummulate;	BlockMove(@Col_1^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));   end;if Coperator = 21 then                                   { A cumulatively integrated = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    BlockMove(@Plt_Spec[Clmn1]^^.S, @Col_1^, Sizeof(Col_1^));;  	{putmessage('call Digital_Filter','','','');}     Digital_Filter;	BlockMove(@Col_1^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));  end;if Coperator = 22 then                                   { ln(A) = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    FOR nn := 1 TO Spectrum_Size DO	  BEGIN	   if Plt_Spec[Clmn1]^^.S[nn] >= 1 then	   Plt_Spec[Clmn3]^^.S[nn] := ln(Plt_Spec[Clmn1]^^.S[nn]) else	   Plt_Spec[Clmn3]^^.S[nn] := zero;	  END;   end;if Coperator = 23 then                                   { Exp(A) = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    FOR nn := 1 TO Spectrum_Size DO	  BEGIN	   Plt_Spec[Clmn3]^^.S[nn] := exp(Plt_Spec[Clmn1]^^.S[nn]);	  END;   end;if Coperator = 24 then                                   { Scale A to B and put into C }  begin	 IF ROI^^.Scale.Exists        THEN          BEGIN		 BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }		  Scale_1_Multiplier := zero ;		  Scale_2_Multiplier := zero ;		               FOR nn := ROI^^.Scale.Lo TO ROI^^.Scale.Hi DO              BEGIN                Scale_1_Multiplier := Scale_1_Multiplier + Plt_Spec[Clmn1]^^.S[nn];				Scale_2_Multiplier := Scale_2_Multiplier + Plt_Spec[Clmn2]^^.S[nn] ;              END;			 Scale_2_Multiplier := Scale_2_Multiplier / Scale_1_Multiplier ;		  FOR nn := 1 TO Spectrum_Size DO			BEGIN			 Plt_Spec[Clmn3]^^.S[nn] :=  Scale_2_Multiplier * Plt_Spec[Clmn1]^^.S[nn] ;			END;		 	SetPort(PickWindow);			GetDialogItem(PickWindow,I_XX,DType,DItem,tempRect);			XX := Scale_2_Multiplier;			RealToString(XX,5,5,str);			SetDialogItemText(DItem,str);  						           END		  ELSE 		    BEGIN			  PutMessage('You must setup a "Scale" region of interest (ROI) to use this feature.',			             'Go to the ROI options and do this now.','','');			  exit(Calculate) ;				            END;         end;		if Coperator = 25 then                                   { Shift A  = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info } 	GetDialogItem(PickWindow, I_WW, Dtype, Ditem, tempRect);  	GetDialogItemText(Ditem, str);	Shift_Ev := -MyStr2Num(str);	RealToString(Shift_Ev,5,5,str5);{putMessage('Shift_Ev is',str5,'','');}	Partial_Shift := ABS(Shift_Ev / 	Plt_spec[Clmn3]^^.Expt_Info.dE - rinttol(Shift_Ev / Plt_spec[Clmn3]^^.Expt_Info.dE));	FOR nn := 1 TO Spectrum_Size DO	  BEGIN		Ntemp := nn + rinttol(Shift_Ev / Plt_spec[Clmn3]^^.Expt_Info.dE); 		{ shift an integer number of channels first and leave to do only the less than one channel part }		IF Ntemp <= 1		  THEN Ntemp := 1;		IF Ntemp >= Spectrum_Size		  THEN Ntemp := Spectrum_Size;		Col_2^[nn] {Plt_Spec[Clmn3]^^.S[nn]} := Plt_Spec[Clmn1]^^.S[Ntemp];	  END; 		IF Partial_Shift = 0.0 then			BlockMove(@Col_2^, @Col_1^, Sizeof(Col_2^))		ELSE begin			IF (Shift_Ev < 0)			  THEN                        { Case 1: Shift right }				BEGIN				FOR nn := 2 TO Spectrum_Size-1 DO					BEGIN					  Col_1^[nn] := Col_2^[nn-1] * Partial_Shift + (1.0 - Partial_Shift) * Col_2^[nn];					END;								END;					IF (Shift_Ev > 0)			  THEN                        { Case 2: Shift left }				BEGIN						FOR nn := 2 TO Spectrum_Size-1 DO					BEGIN					  Col_1^[nn] := Col_2^[nn] * (1.0 - Partial_Shift) + Partial_Shift * Col_2^[nn+1];					END;				END;		end;(*	FOR nn := 1 TO Spectrum_Size DO        { Now subtract out the partials }	  BEGIN		Col_1^[nn] {Plt_Spec[Clmn3]^^.S[nn]} := Col_1^[nn] - Partial_Shift * Col_1^[nn];	  END;  	IF (Shift_Ev < 0)	  THEN                        { Case 1: Shift right }		BEGIN		with Plt_Spec[Clmn3]^^ do		begin		  FOR nn := 2 TO Spectrum_Size DO			BEGIN			  Ntemp := nn + rinttol(Shift_Ev / Plt_spec[Clmn1]^^.Expt_Info.dE);			  IF Ntemp <= 2				THEN Ntemp := 2;			  IF Ntemp >= Spectrum_Size				THEN Ntemp := Spectrum_Size;			  Col_1^[nn] := Col_1^[nn] + Partial_Shift * Plt_Spec[Clmn1]^^.S[Ntemp -1];			END;		  END; { with...}		END; 	IF (Shift_Ev > 0)	  THEN                        { Case 2: Shift left }		BEGIN		with Plt_Spec[Clmn3]^^ do begin		  FOR nn := 1 TO Spectrum_Size-1 DO			BEGIN			  Ntemp := nn + rinttol(Shift_Ev / Plt_spec[Clmn1]^^.Expt_Info.dE);			  IF Ntemp <= 1				THEN Ntemp := 1;			  IF Ntemp >= Spectrum_Size-1				THEN Ntemp := Spectrum_Size-1;			  Col_1^[nn] := Col_1^[nn] + Partial_Shift * Plt_Spec[Clmn1]^^.S[Ntemp + 1];			END;		   END;	{with...}		 END;	*)	BlockMove(@Col_1^, @Plt_Spec[Clmn3]^^.S, Sizeof(Plt_Spec[Clmn3]^^.S));	end; { if Coperator = 25 then...   Shift A  = C  }if Coperator = 26 then                                   { FFT(A) = C }  begin    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    FastFourierTransform( Clmn1, Clmn3, 1 );    end;if Coperator = 27 then                                   { A * Response Curve }  begin	 If ( SiLi_Response_Calculated) then 	 BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, Sizeof(Det_Effic_P^))	 Else Detector_efficiency(theBGRec,SiLi_Response_Calculated);     BlockMove(@Det_Effic_P^, @Col_1^, Sizeof(Col_1^)) ;	Convolve_Col1;    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] * Col_1^[nn];    end;if Coperator = 28 then                                   { A / Response Curve }  begin	 If ( SiLi_Response_Calculated) then  	 BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, Sizeof(Det_Effic_P^))	 Else Detector_efficiency(theBGRec,SiLi_Response_Calculated); 	BlockMove(@Det_Effic_P^, @Col_1^, Sizeof(Col_1^)); 	Convolve_Col1;    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }    FOR nn := 1 TO Spectrum_Size DO	IF Det_Effic_P^[nn] > 0.0 then	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn] / Col_1^[nn]	else Plt_Spec[Clmn3]^^.S[nn] := 0.0;    end;if Coperator = 29 then                                   { Mask A = C }  begin	If (WW <> rinttol(WW)) or ((WW<1) or (WW>8190)) then 	  begin 	    putmessage('"w" must be an integer, and a legitimate channel number',	    			'and must be greater than 1.','','');	    exit(Calculate);	  end;	If (ZZ <> rinttol(ZZ)) or ((ZZ<WW) or (ZZ>8190)) then 	  begin 	    putmessage('"z" must be an integer, and a legitimate channel number',	    			'and must be greater than "w".','','');	    exit(Calculate);	  end;    BlockMove(@Plt_Spec[Clmn1]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the header info }	      FOR nn := 1 TO rinttol(WW)-1 DO Plt_Spec[Clmn3]^^.S[nn] := XX;	FOR nn := rinttol(WW) to rinttol(ZZ) DO Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn1]^^.S[nn];	FOR nn := rinttol(ZZ) to Spectrum_Size DO Plt_Spec[Clmn3]^^.S[nn] := YY;    end;if Coperator = 30 then                                   { B - w * (A-B) = C }  begin    BlockMove(@Plt_Spec[Clmn2]^^, @Plt_Spec[Clmn3]^^, Sizeof(Plt_Spec[Clmn3]^^)); { Copy the "B" header info to "C" as default}    FOR nn := 1 TO Spectrum_Size DO	Plt_Spec[Clmn3]^^.S[nn] := Plt_Spec[Clmn2]^^.S[nn] - WW *(Plt_Spec[Clmn1]^^.S[nn] -  Plt_Spec[Clmn2]^^.S[nn]);  end;   ChangeCursor(ArrowC);   BeepBeep;   Spectrum_Full[Clmn1] := True;   Spectrum_Full[Clmn3] := True;   CheckItem(FullMenu, A^.C_Full[Clmn1], Spectrum_Full[Clmn1]);   CheckItem(FullMenu, A^.C_Full[Clmn3], Spectrum_Full[Clmn3]);   UpDate_Max_Min(Clmn3);   Update_Full;      END; { PROCEDURE Calculate }Procedure PutMoreInfo;		var			L            : Longint;            info         : str255;			DType        : Integer;						DItem        : Handle;		str1,str2,str3,str4   : str255;	Begin   StringToNum(str_info, L); {L is the "number" of the list item, ie, position }   if L < 1 then L := 1;     if L > 999 then L := 999;             if (L >=1) and (L <= 999) then  begin   info := 'An error occurred';      if  L = 1  then begin	str1 := '¥¥¥¥ Copy the header information ¥¥¥¥ of the spectrum in column "A" into the spectrum ';	 	str2 := 'in column "C". Leave the actual spectra as they were. ';	info := CONCAT(str1, str2);   end;      if  L = 2  then begin	str1 := 'Make a copy, with header information, of the spectrum in column "A" ';	str2 := 'into the spectrum in column "C" ';	info := CONCAT(str1, str2);   end;   if  L = 3  then begin	str1 := 'Swap the contents, ¥leaving header information as is¥, of the spectrum in column "A" ';	str2 := 'and the spectrum in column "C" ';	info := CONCAT(str1, str2);   end;   if  L = 4  then begin	str1 := 'Multiply the contents of the spectrum in column "A" by the constant "w" ';	str2 := 'and put results in the spectrum in column "C"';	info := CONCAT(str1, str2);   end;      if  L = 5  then begin	str1 := 'Add the contents of the spectrum in column "A" by the constant w ';	str2 := 'and put results in the spectrum in column "C".  ';	info := CONCAT(str1, str2 );	   end;   if  L = 6  then begin	str1 := 'Add the contents of the spectrum in column "A" to the constant "w" times ';	str2 := 'the contents of the spectrum in column "B" and put results in the spectrum ';	str3 := 'in column "C"';	info := CONCAT(str1, str2,str3);   end;   if  L = 7  then begin	str1 := 'From the contents of the spectrum in column "A" subtract the constant "w" times ';	str2 := 'the contents of the spectrum in column "B" and put results in the spectrum ';	str3 := 'in column "C"';	info := CONCAT(str1, str2,str3);   end;   if  L = 8  then begin	str1 := 'Multiply the contents of the spectrum in column "A" by the constant "w" times ';	str2 := 'the contents of the spectrum in column "B" and put results in the spectrum ';	str3 := 'in column "C"';	info := CONCAT(str1, str2,str3);   end;   if  L = 9  then begin	str1 := 'Divide the contents of the spectrum in column "A" by the product of the constant ';	str2 := '"w" times the contents of the spectrum in column "B" and put results ';	str3 := 'in the spectrum in column "C"';	info := CONCAT(str1, str2,str3);   end;   if  L = 10  then begin	str1 := 'Square the contents of the spectrum in column "A" and put results ';	str2 := 'in the spectrum in column "C"';	info := CONCAT(str1, str2 );   end;   if  L = 11  then begin	str1 := 'Take the Square Root of the contents of the spectrum in column "A" and put results ';	str2 := 'in the spectrum in column "C"';	info := CONCAT(str1, str2 );   end;   if  L = 12  then begin	str1 := 'Poisson randomize the contents of the spectrum in column "A" and put results ';	str2 := 'in the spectrum in column "C". Time to compute scales with the number of counts. ';	str3 := 'The algorithmn accepts real values > 0.0 and is extremely accurate.';	info := CONCAT(str1, str2, str3 );   end;   if  L = 13  then begin	str1 := 'Normally randomize the contents of the spectrum in column "A" and put results ';	str2 := 'in the spectrum in column "C". ';	str3 := '';	info := CONCAT(str1, str2, str3 );   end;   if  L = 14  then begin	str1 := 'Do a 5 point least-squares fit to a quadratic polynomial (Savitsky-Golay) ';    str2 := 'and put results in the spectrum in column "C". The weights are -3,12,17,12,-3. ';	str3 := '¥Smoothing operators should be used judiciously¥';	info := CONCAT(str1, str2, str3 );   end;   if  L = 15  then begin	str1 := 'Do a 7 point least-squares fit to a quadratic polynomial on "A" ';    str2 := 'and put results in the spectrum in column "C". The weights are -2,3,6,7,6,3,-2. ';	str3 := '¥Smoothing operators should be used judiciously¥ ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 16  then begin	str1 := 'Do a 9 point least-squares fit to a quadratic polynomial on "A" ';    str2 := 'and put results in the spectrum in column "C". The weights are ';	str3 := '-21,14,39,54,59,54,39,14,-21.  ¥Smoothing operators should be used judiciously¥ ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 17  then begin	str1 := 'Convolute the spectrum in "A" with the detector resolution (Gaussian smoothing) ';    str2 := 'and put results in the spectrum in column "C". Be sure the resolution is what you ';	str3 := 'want by going to the "detector parameters". ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 18  then begin	str1 := 'Differentiate once the spectrum in "A" and put results in the spectrum in column "C". ';    str2 := ' This is a 4 point operator with weights 1,-8,8,-1 ';	str3 := ' ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 19  then begin	str1 := 'Differentiate twice the spectrum in "A" and put results in the spectrum in column "C". ';    str2 := ' This is a 5 point operator with weights -1,16,-30,16,-1 ';	str3 := ' ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 20  then begin	str1 := 'Cumulatively integrate the spectrum in "A" and put results in the spectrum in column "C". ';    str2 := ' This sums a channel with all channels before it. An Aside! Differentiating twice ';	str3 := 'and integrating twice is the equivalent of a 9 point smooth.';	info := CONCAT(str1, str2, str3 );   end;   if  L = 21  then begin	str1 := 'Top-Hat digitally filter the spectrum in "A" and put results in the spectrum in ';    str2 := 'column "C". The filter will use the parameters you specified in the Digital Filter ';	str3 := 'Menu choices. ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 22  then begin	str1 := 'Take the natural logarithmn of the contents of the spectrum in column "A" ';	str2 := 'and put results in the spectrum in column "C". Values <= 1 are evaluated to zero.';	info := CONCAT(str1, str2 );   end;   if  L = 23  then begin	str1 := 'Exponentiate the contents of the spectrum in column "A" ';	str2 := 'and put results in the spectrum in column "C". ¥¥Note that any value >88.722 will ';	str3 := 'exceed the capacity of the 4 byte real number used to display the spectra. ';	info := CONCAT(str1, str2, str3 );   end;   if  L = 24  then begin	str1 := 'Find a multiplier for the spectrum in "A" so that the "Scale" ROI counts ';	str2 := 'in both "A" and "B" are equal. Multiply the spectrum in "A" by this number ';	str3 := 'and put the result in "C". ¥You must have previously ';    str4 := 'defined a "Scale" ROI. Factor will be in scaler box X:';	info := CONCAT(str1, str2, str3, str4 );	   end;   if  L = 25  then begin	str1 := 'Shift the spectrum left or right along the energy axis by "w" eV. a "-" will shift ';	str2 := 'left and a "+" (or no sign) will shift right.  ';	info := CONCAT(str1, str2);	   end;   if  L = 26  then begin	str1 := 'FFT the Spectrum in "A" and put its Power Spectrum in column "C". ';	str2 := 'The power spectrum can be thought of as a sum of sine waves needed to "make" the spectrum, ';	str3 := ' the sine amps are in y, ch 0 is the constant, f=1 is in ch 1 and f=1000 is in ch 1000.';	info := CONCAT(str1, str2, str3);	   end;   if  L = 27  then begin	str1 := 'Multiply the contents of the spectrum in column "A" by the Detector Response Curve ';	str2 := 'and put results in the spectrum in column "C". The response curve has been convolved ';    str3 := 'with the detector resolution.';	info := CONCAT(str1, str2, str3);	   end;   if  L = 28  then begin	str1 := 'Divide the contents of the spectrum in column "A" by the smoothed Detector Response Curve ';	str2 := 'and put results in the spectrum in column "C". If the curve matches your detector ';    str3 := 'the division will produce a spectrum similar to (but noisier) than the specimens.';	info := CONCAT(str1, str2, str3);	   end;    if  L = 29  then begin	str1 := '"Mask" column "A" and put in column "C". From channel 1 up to "w" insert ';	str2 := 'the value "x". Leave the contents of "A" between channel "w" and "z" untouched. ';	str3 := 'From channel "z" up till the spectrum limit insert the value "y".  ';	info := CONCAT(str1, str2, str3 );	   end;    if  L = 30  then begin	str1 := 'Subtract column "B" from column "A" and multiply the result by "w". ';	str2 := 'This result is then subtracted from column "B" and the result is put into column "C". ';	info := CONCAT(str1, str2 );	   end;      	 BackColor(WhiteColor);	 ForeColor(BlackColor);				 	 GetDialogItem(PickWindow, I_TextBox, DType, DItem, tempRect);					 SetDialogItemText(DItem, info);				 			      end;End; { Procedure PutMoreInfo } {===========================================================} 	function myFilter (theDialog: DialogPtr;									var theEvent: EventRecord;									var itemHit: integer): boolean;	CONST		I_Done                        = 1;		I_Cancel					  = 2;		kVisualDelay				  = 8;		kReturnKey					  = $0D;		kEnterKey					  = $03;		kEscapeKey					  = $1B; 		kPeriodKey					  = $2E;	var		  tempRect						: Rect;		  DType                         : integer;		  DItem                         : Handle;		  CItem			                : controlhandle;		  temp							: Longint;		  DataLen						: Integer;		  str_3							: string[3];		  gotClicked 					: Cell;		  ignore 						: Boolean;		  finalTicks					: Longint;		  key							: Char;	begin		myFilter := FALSE;		Do_Calc   := FALSE;		if (theEvent.what = MouseDown) then    {Only do on a mouse click}			begin			    dataLen := 3;				Rect_Point := theEvent.where;     {Get the point where the mouse was clicked}				GlobalToLocal(Rect_Point);				if PtInRect(Rect_Point, Rect_I_Spectra) then { we are in the box of cells }					begin					    { the ordering of double, single click handling is important }         				DoubleClick := LClick(Rect_Point, theEvent.modifiers, List_I_Spectra);						if DoubleClick then { Double click handling }							begin							  str_3 := '   '; { initialization is essential }							  LGetCell(Pointer(ord(@str_3) + 1), dataLen, List_I_Spectra^^.lastClick, List_I_Spectra);							  str_3 := Strip_Trailing_Blanks(str_3); 	 															  StringToNum(str_3, temp);							  itemHit := integer(temp + 100);							  myFilter := TRUE;							  Do_Calc := TRUE;							end;						ignore := LClick(Rect_Point, 0, List_I_Spectra); { single click handling }						gotClicked := LLastClick(List_I_Spectra);						str_info := '   '; 						LGetCell(Pointer(ord(@str_info) + 1), dataLen, gotClicked, List_I_Spectra);												str_info := Strip_Trailing_Blanks(str_info);						PutMoreInfo;												end;    					{End of PtInRect}        END	{ IF (theEvent.what = MouseDown) }	  ELSE	    CASE theEvent.what OF			keyDown, Autokey:	{user pressed a key}			BEGIN				key := Char(BAnd(theEvent.message, charCodeMask));				IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN				  BEGIN				    GetDialogItem(theDialog, I_Done, DType, DItem, tempRect);							{invert the OK button for user feedback}					CItem := controlhandle(DItem);							HiliteControl(CItem, kControlButtonPart);					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(CItem, 0);					myFilter := TRUE;								{event's being handled}					itemHit := I_Done;								{return the default button}				  END;				END; { keyDown, Autokey }			END;{CASE theEvent.what}			end; {===========================================================}  	procedure D_Math_Window;		const		I_Exit = 1;          { Buttons }				Work_Col_1 = 11; { Radio buttons }		S8_Col_1 = 20;		Work_Col_2 = 21;		S8_Col_2 = 30;		Work_Col_3 = 31;		S8_Col_3 = 40;				NumFuncs  = 30; { ¥¥¥¥¥¥¥ Number of functions in the list ¥¥¥¥¥¥ }				var		    tempRect         : Rect;		    ExitDialog       : boolean; 			Index            : Integer;			CItem			 : controlhandle;			DType            : Integer;						DItem            : Handle;						sTemp            : Str255;			itemHit          : Integer;			dataBounds       : Rect;			cSize            : Point;            Func             : Array[1..NumFuncs] of str255;            str,str1,str2,str3,str4,str7   : str255; 			 	 PROCEDURE Refresh_Dialog; 		var 			rTempRect:Rect; 	 		begin 			SetPort(PickWindow);		    BackColor(WhiteColor);            ForeColor(BlackColor);										rTempRect := tempRect;			GetDialogItem(PickWindow,I_Exit,DType,DItem,tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1,1);			MoveTo(11,299);			LineTo(92,299);			LineTo(92,57);			PenSize(3,3);			SetRect(TempRect,10,56,92,299);			FrameRect(TempRect);			PenSize(1,1);			MoveTo(112,299);			LineTo(193,299);			LineTo(193,57);			PenSize(3,3);			SetRect(TempRect,111,56,193,299);			FrameRect(TempRect);			PenSize(1,1);			MoveTo(532,298);			LineTo(613,298);			LineTo(613,56);			PenSize(3,3);			SetRect(TempRect,531,55,613,298);			FrameRect(TempRect);			PenSize(1,1);						tempRect := rTempRect;			LUpdate(PickWindow^.visRgn,List_I_Spectra);						rTempRect:= Rect_I_Spectra;			InsetRect(rTempRect, -1, -1);			FrameRect(rTempRect);			 	end; 	 	 	procedure Add_Row(theString:Str255;  theList:ListHandle); 		var 			theRow:integer;	 		begin 			if (theList <> nil) then 			begin 				cSize.h := 0;				theRow := LAddRow(1, NumFuncs, theList);				cSize.v := theRow;				sTemp:= theString;				LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize,theList);				LDraw(cSize, theList);			end; 	end; 	 	 	begin				    PickWindow := GetNewDialog(1256, nil,  Pointer(-1) ); 			ShowWindow(PickWindow);			SelectWindow(PickWindow);			SetPort(PickWindow);			SetRect(Rect_I_Spectra,206,57,527,300);		    BackColor(WhiteColor);            ForeColor(BlackColor);							tempRect:= Rect_I_Spectra;			tempRect.Right:= tempRect.Right - 15;			if (tempRect.Right<= (tempRect.Left + 15)) then				tempRect.Right := tempRect.Left + 15;			InsetRect(tempRect, -1, -1);			FrameRect(tempRect);			InsetRect(tempRect, 1, 1);			SetRect(dataBounds, 0, 0, 1, 0);			cSize.h := tempRect.Right - tempRect.Left;			cSize.v := 0;			List_I_Spectra:=  LNew(tempRect, 			                       dataBounds, 								   cSize, 								   0, 								   PickWindow, 								   TRUE, 								   FALSE, 								   FALSE, 								   TRUE);			List_I_Spectra^^.selFlags := lOnlyOne + lNoNilHilite;			LSetDrawingMode(False, List_I_Spectra);             str1 := 'Single click on a list item to get more information ¥¥¥Double click¥¥¥ to ';			str2 := 'EXECUTE it. ¥¥Note!! Unless Column B is explicitly an option it is neglected ';			str3 := 'and the header will move from "A" to "C", otherwise, you must decide what to ';            str4 := 'do with the header.';			Str7 := CONCAT(str1,str2,str3,str4);			GetDialogItem(PickWindow, I_TextBox, DType, DItem, tempRect);							SetDialogItemText(DItem, str7);			            Func[1]  := '1    Copy the header of "A" into "C" ';            Func[2]  := '2    Copy "A" into "C" ';			Func[3]  := '3    Rotate "A" and "C" ';			Func[4]  := '4    A * w = C ';			Func[5]  := '5    A + w = C ';			Func[6]  := '6    A + (w * B) = C ';			Func[7]  := '7    A - (w * B) = C ';			Func[8]  := '8    A * (w * B) = C ';			Func[9]  := '9    A / (w * B) = C ';			Func[10] := '10   A squared = C ';			Func[11] := '11   A root = C ';			Func[12] := '12   A Poisson Randomized = C ';			Func[13] := '13   A Normally Randomized = C ';			Func[14] := '14   A 5 point smoothed = C ';			Func[15] := '15   A 7 point smoothed = C ';			Func[16] := '16   A 9 point smoothed = C ';			Func[17] := '17   A Convolved with detector response = C ';			Func[18] := '18   A differentiated once = C ';			Func[19] := '19   A differentiated twice = C ';			Func[20] := '20   A cumulatively integrated = C ';			Func[21] := '21   A top-hat digitally filtered = C ';			Func[22] := '22   Ln(A) = C ';			Func[23] := '23   Exp(A) = C ';			Func[24] := '24   Scale A to B, using "scale" ROI, and put into C';					    Func[25] := '25   Shift A by w eV and put it into C';				Func[26] := '26   FFT (A) and put Power Spectrum into C';				Func[27] := '27   A * Detector Response Curve = C';			Func[28] := '28   A / Detector Response Curve = C';			Func[29] := '29    Mask A and put results in C ';			Func[30] := '30    B - W * (A - B) =  C ';						For Index := 1 to   NumFuncs  do			begin			  Str :=  Func[Index] ;			  Add_Row(Str, List_I_Spectra);  			  cSize.v := 0;			  LSetSelect(TRUE, cSize, List_I_Spectra);			end; { For Index := 1 to NumFuncs }			LSetDrawingMode(TRUE, List_I_Spectra);						For index := 0 to 9 do { zero out the lot }			begin			  GetDialogItem(PickWindow, Work_Col_1 + index, DType, DItem, tempRect);			  SetControlValue(controlhandle(DItem), 0);			  			  GetDialogItem(PickWindow, Work_Col_2 + index, DType, DItem, tempRect);			  SetControlValue(controlhandle(DItem), 0);			  			  GetDialogItem(PickWindow, Work_Col_3 + index, DType, DItem, tempRect); 			  SetControlValue(controlhandle(DItem), 0);			end;			if (Clmn3 = 0) then Clmn3 := 1;						if Clmn3 = 10 then      { now set just the radio buttons we want }			begin			  GetDialogItem(PickWindow, Work_Col_3, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;			if Clmn3 = 9 then 			begin			  GetDialogItem(PickWindow, Work_Col_3 + 1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;			if Clmn3 < 9 then 			begin			  GetDialogItem(PickWindow, Work_Col_3 + Clmn3 + 1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;						if (Clmn2 = 0) then Clmn2 := 10;						if Clmn2 = 10 then 			begin			  GetDialogItem(PickWindow, Work_Col_2, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;			if Clmn2 = 9 then 			begin			  GetDialogItem(PickWindow, Work_Col_2 + 1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;			if Clmn2 < 9 then 			begin			  GetDialogItem(PickWindow, Work_Col_2 + Clmn2 + 1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;						if (Clmn1 = 0) then Clmn1 := 10;						if Clmn1 = 10 then 			begin			  GetDialogItem(PickWindow, Work_Col_1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;			if Clmn1 = 9 then 			begin			  GetDialogItem(PickWindow, Work_Col_1 + 1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;			if Clmn1 < 9 then 			begin			  GetDialogItem(PickWindow, Work_Col_1 + Clmn1 + 1, DType, DItem, tempRect);   			  SetControlValue(controlhandle(DItem), 1);			end;						if (WW <= 0.0) then WW := 1.0;						GetDialogItem(PickWindow,I_WW,DType,DItem,tempRect);			RealToString(WW,5,5,str);			SetDialogItemText(DItem,str); 					GetDialogItem(PickWindow,I_XX,DType,DItem,tempRect);			RealToString(XX,5,5,str);			SetDialogItemText(DItem,str);						GetDialogItem(PickWindow,I_YY,DType,DItem,tempRect);			RealToString(YY,5,5,str);			SetDialogItemText(DItem,str);						GetDialogItem(PickWindow,I_ZZ,DType,DItem,tempRect);			RealToString(ZZ,5,5,str);			SetDialogItemText(DItem,str); 					Refresh_Dialog;						ExitDialog:=FALSE;			Coperator := 0;  { no operation chosen by a double click }			            Do_Calc := False;									repeat				ModalDialog(NewModalFilterProc(@MyFilter), itemHit);				GetDialogItem(PickWindow, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem); 				if (ItemHit > 100) and (ItemHit < 999) then				begin { Handle a Double Click }		          		         Coperator := ItemHit - 100 ;  		        end;	{ if (ItemHit > 100)...}								 				 				if (ItemHit =I_Exit) then				begin					ExitDialog:=TRUE;					Refresh_Dialog;				end;				 								if (ItemHit >=Work_Col_1) and (ItemHit <=S8_Col_1) then				begin					for Index:=Work_Col_1  to S8_Col_1 do					begin						GetDialogItem(PickWindow, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;					SetControlValue(CItem, 1);					Clmn1 := ItemHit - Work_Col_1 + 1;					Clmn1 := Clmn1-2;					if Clmn1=0 then Clmn1 := 9;					if Clmn1=-1 then Clmn1 := 10;				end;								if (ItemHit >=Work_Col_2) and (ItemHit <=S8_Col_2) then				begin					for Index:=Work_Col_2  to S8_Col_2 do					begin						GetDialogItem(PickWindow, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;					SetControlValue(CItem, 1);					Clmn2 := ItemHit - Work_Col_2 + 1;					Clmn2 := Clmn2-2;					if Clmn2=0 then Clmn2 := 9;					if Clmn2=-1 then Clmn2 := 10;				end;								if (ItemHit >=Work_Col_3) and (ItemHit <=S8_Col_3) then				begin					for Index:=Work_Col_3  to S8_Col_3 do					begin						GetDialogItem(PickWindow, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;					SetControlValue(CItem, 1);					Clmn3 := ItemHit - Work_Col_3 + 1;					Clmn3 := Clmn3-2;					if Clmn3=0 then Clmn3 := 9;					if Clmn3=-1 then Clmn3 := 10;				end;											GetDialogItem(PickWindow,I_WW,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			WW := MyStr2Num(sTemp);						GetDialogItem(PickWindow,I_XX,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			XX := MyStr2Num(sTemp);						GetDialogItem(PickWindow,I_YY,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			YY := MyStr2Num(sTemp);						GetDialogItem(PickWindow,I_ZZ,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			ZZ := MyStr2Num(sTemp); 			if Do_Calc then { a double click occurred indicating that calculalation should be done }			  BEGIN			   Calculate ; 			   Refresh_Dialog;			   Do_Calc := False;			  END; { if Do_Calc... }				 			until ExitDialog;		    DisposeDialog(PickWindow); 		end;	     FUNCTION RND: longreal {double}; { Uniform Random number generator }    VAR      temp                         : longreal {double};    BEGIN      {first generator}      seed_x := 171 * (seed_x MOD 177) - 2 * (seed_x DIV 177);      IF seed_x < 0        THEN seed_x := seed_x + 30269;      {second generator}      seed_y := 172 * (seed_y MOD 176) - 35 * (seed_y DIV 176);      IF seed_y < 0        THEN seed_y := seed_y + 30307;      {third generator}      seed_z := 170 * (seed_z MOD 178) - 63 * (seed_z DIV 178);      IF seed_z < 0        THEN seed_z := seed_z + 30323;      {combine these values to get the result}      temp := seed_x / 30269.0 + seed_y / 30307.0 + seed_z / 30323.0;      RND := temp - floor(temp);                      {RND here goes from 0 to +1}    END;  FUNCTION gammln(xx_x: real {double}): longreal {double};    VAR      x, tmp, ser                  : longreal {double};      j                            : Integer;      cof                          : ARRAY [1..6] OF longreal {double};    BEGIN      cof[1] := 76.18009173;      cof[2] := - 86.50532033;      cof[3] := 24.01409822;      cof[4] := -1.231739516;      cof[5] := 0.120858003E-2;      cof[6] := - 0.536382E-5;      x := xx_x;      tmp := x + 5.5;      tmp := (x + 0.5) * ln(tmp) - tmp;      ser := 1.0;      FOR j := 1 TO 6 DO        BEGIN          x := x + 1.0;          ser := ser + cof[j] / x        END;      gammln := tmp + ln(2.50662827465 * ser)    END;  FUNCTION PoissonRandomNums{(xm: real): real};    VAR      em, t, Y, R_term             : longreal {double};      Liem						   : longint;      str,str1,str2,str3				: str255;    BEGIN      IF (xm < 12.0)      THEN      BEGIN            IF (xm <> gloldm)	{starts as -1.0}            THEN             BEGIN                  gloldm := xm;                  glg := exp( - xm)            END;            em :=-1.0;            t := 1.0;            REPEAT              em := em + 1.0;              t := t * RND;            UNTIL (t <= glg)       END       ELSE       BEGIN            IF (xm <> gloldm)	{starts as -1.0}            THEN            BEGIN                  gloldm := xm;                  glsq := sqrt(2.0 * xm);                  glalxm := ln(xm);                  glg := xm * glalxm - gammln(xm);            END;            REPEAT              REPEAT                Y := PI * RND;                Y := SIN(Y) / COS(Y);                em := glsq * Y + xm;              UNTIL (em >= 0.0);              em := floor(em);              R_term := em * glalxm - gammln(em) - glg;              t := 0.9 * (1.0 + sqr(Y)) * exp(R_term);(*str1:=stringof('for xm =',xm,' glg = ',glg);str:= stringof('t = ',t,' RND = ',RND);str2:=stringof('r_term is ',R_term,' glalxm = ',glalxm);str3 :=stringof('Y = ',Y,' em = ',em);putmessage(str1,str,str2,str3);*)            UNTIL (RND <= t);       END;      PoissonRandomNums := em;    END;  PROCEDURE Add_Noise; { Add noise to "work" and put the sum into "results"}    VAR      nn                           : Integer;      tReal                        : real {double};    BEGIN	{with Plt_spec[9]^^ do begin}      FOR nn := 1 TO Spectrum_Size DO        BEGIN		  tReal := Plt_spec[10]^^.S[nn];		  if tReal > 0.0 then          Plt_spec[9]^^.S[nn] := PoissonRandomNums(tReal) else		  Plt_spec[9]^^.S[nn] := 0.0;		  {spinCursor;}        END;		UpDate_Max_Min(9);	  {end;} { with...}    END;                                              { of proc Add_Noise }					procedure D_Noise_Spectra;		const		I_Accept = 1;		I_Cancel = 2;		I_x10 = 7;		I_Bring_Spectrum_Header   = 10;		I_Bring_Experiment_Header = 11;			var			ExitDialog 					: boolean; 			GetSelection 				: DialogPtr;			tempRect 					: Rect;			DType 						: Integer;			Index 						: Integer;			DItem 						: Handle;			CItem			 			: controlhandle;			itemHit 					: Integer;			LongTemp     				: longint;	        Start                       : Point;			Prompt               		: Str255;			Reply                       : StandardFileReply;			nrefnum               		: Integer;			errCode                     : Integer;            bytecount                   : LongInt;			str1					   : str255;			savename                     : fnamestr;			savevol         			 : integer;			save_dirID					 : longint;							procedure Refresh_Dialog; 	 		begin 			SetPort(GetSelection);			GetDialogItem(GetSelection,I_Accept,DType,DItem,tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1); 	    end; 	 	 	begin			GetSelection := GetNewDialog(3720, nil,  Pointer(-1) );			CenterDialog(GetSelection, TRUE, Start);				{¥¥¥new RLM¥¥¥}			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 			GetDialogItem(GetSelection,I_x10,DType,DItem,tempRect);			NumToString(Num_Noise_Spectra,str1);			SetDialogItemText(DItem,str1);						Refresh_Dialog; 			 			ExitDialog:=FALSE;			 			repeat				ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem);				 				if (ItemHit =I_Accept) then				begin					ExitDialog:=TRUE;				end;								if (ItemHit =I_Cancel) then				begin					temprect := GetSelection^.portRect; 					DisposeDialog(GetSelection);					FillWhiteSpace(temprect);					exit(D_Noise_Spectra);				end;				if (ItemHit =I_Bring_Spectrum_Header) then				begin				  Spectrum_Header_Dialog;				  Refresh_Dialog;				end;				if (ItemHit =I_Bring_Experiment_Header) then				begin                  D_EXPT_Hdr;				  Refresh_Dialog;			    end; 			until ExitDialog;			 			GetDialogItem(GetSelection,I_x10,DType,DItem,tempRect);			GetDialogItemText(DItem, str1);						StringToNum(str1, LongTemp );			Num_Noise_Spectra := (LongTemp);      temprect := GetSelection^.portRect;       DisposeDialog(GetSelection);	  FillWhiteSpace(temprect);      WITH Start DO        BEGIN          v := 90;          h := 80;        END;	  Prompt := 'Enter Name for Noise File';	  FM := 'Noise_Results';	  	  StandardPutFile(prompt, FM, reply);		{¥¥New DTSA file spec¥¥}	  IF not Reply.sfgood then exit(D_Noise_Spectra);        WITH Reply DO        BEGIN          File_Cancel_Button := sfgood;  { reply.Good is false if the cancel button is pushed }          IF sfgood            THEN              BEGIN               { Ok := SetVol(NIL, In_VolRefNum) = NoErr; }  {vol ref num is Reply.VRefNum}				Read_DTSA_Spec := reply.sfFile;				RdBinaryName := Read_DTSA_Spec.name;				  InVol_volnum := Read_DTSA_Spec.vRefNum;				  InVol_DirID := Read_DTSA_Spec.parID;				  				  {The volume names in the folowing calls are all StringPtr}				  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}				  errcode := HSetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}				  errcode := HGetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}				  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}				              END;        END;	             Update_Full;				  errCode := FSpCreate(Read_DTSA_Spec, 'DTSA', 'MCAf',smSystemScript);		{¥¥New DTSA file spec¥¥}				    abort_x := False;          { For the cntrl-c exit test logic }                    UnCheck_AllSpectra;                    Spectrum_Full[9] := True;                    CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);			                        {  copy over any fields, screw the spectrum }		        BlockMove(@Plt_Spec[10]^^, @Plt_Spec[9]^^, Sizeof(Plt_Spec[9]^^)); 				Plt_spec[9]^^.Expt_Info.FirstSpec := 1;					Plt_spec[9]^^.Expt_Info.LastSpect := Num_Noise_Spectra;				 errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, nrefnum);				  ByteCount := sizeof(Expt_InfoRec);						errcode := setfpos(nrefnum,fsfromStart,0); 						errCode := FSwrite(nrefnum, bytecount, @Plt_Spec[9]^^.Expt_Info);				  ByteCount := sizeof(Plot_infoRec);						errCode := FSWrite(nrefnum, bytecount, @Plt_Spec[9]^^.Plot_info);     			 	errCode := FSClose(nrefnum);     				errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);								Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := 0;				Spectrum_Counter := 0;								                For Index := Plt_spec[9]^^.Expt_Info.FirstSpec to 				             Plt_spec[9]^^.Expt_Info.LastSpect  do				begin				                    Add_Noise;                  UpDate_Max_Min(9);                  Spectrum_Counter :=  index;				  Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := Spectrum_Counter;							{ this bytecount puts mark at end of spectrum currently displayed: }				  ByteCount := sizeof(Expt_InfoRec) + sizeof(Plot_infoRec) +							 	 (longint(Spectrum_Counter) - 1) * ( sizeof(Spectrum_Structure) +							 	 longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ) ;							errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, nrefnum);							RdBinaryName := Read_DTSA_Spec.name;      	      	     IF errCode <> NoErr THEN begin						 		putmessage('A FS Open error just occured', '', '', '');								Spectrum_Counter := Spectrum_Counter - 1; { reset to incoming value }						  end	 				 ELSE					   BEGIN						errcode := setfpos(nrefnum,fsfromStart,bytecount); {end of preceeding spectrum }						bytecount := sizeof(Spectrum_Structure);   {ie SpectrumStuff}						errCode := FSwrite(nrefnum, bytecount, @Plt_Spec[9]^^.SpectrumStuff);						bytecount :=  longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ;						errCode := FSWrite(nrefnum, bytecount, @Plt_Spec[9]^^.S);					  END;     			 	errCode := FSClose(nrefnum);     				errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                   IF abort_x = True THEN exit(D_Noise_Spectra); { allows cntl "." out of this loop}	                     abort_x := Interrupted;                   IF abort_x = True THEN exit(D_Noise_Spectra);					                    Update_Full;				 					 IF abort_x = True THEN exit(D_Noise_Spectra); 					 end; { For Index := Plt_spec[9]^^.Expt_Info.FirstSpect to 					                     Plt_spec[9]^^.Expt_Info.LastSpect }						        MCA_Spectrum_Active := True ;							 (* RdBinaryName := BinaryName;		  Binary_VolNum_Read := 0;*)		  RdBinaryName := Read_DTSA_Spec.name;		  { Read A spectrum back from the newly written file }		   errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, nrefnum);		  IF errCode <> NoErr			   THEN putmessage('A FS Open error just occured', '', '', '')		   ELSE			 BEGIN			  bytecount := sizeof(Expt_InfoRec);			  errcode := setfpos(nrefnum,fsfromStart,0);			  errCode := FSread(nrefnum, bytecount, @Plt_Spec[10]^^.Expt_Info);			  Displayed_Fst := Plt_spec[10]^^.Expt_Info.FirstSpec;			  Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;			  errcode := setfpos(nrefnum,fsfromStart,0);			  bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts) +						   longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ;			  errCode := FSread(nrefnum, bytecount, @Plt_Spec[10]^^);			  Spectrum_Counter := Plt_spec[10]^^.Expt_Info.FirstSpec;			  Spec_displayed := Spectrum_Counter;			  { always end with this set to the # of spectrum displayed }			 END;		  errCode := FSClose(nrefnum);		  errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                             		  Spectrum_Full[10] := True;		 CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);		 Refresh_ROIs;		 Update_Full;		 SpecWork_has_been_Changed := True;							end;   PROCEDURE Digital_Filter; { Col_1^ in, Col_1^ out. Uses Col[2 and 3]^^.S for scratch }    VAR      n, M, TwoM_Plus_One, TwoN	: Integer;         { 2M+1 channels in central section }      i, C, P, Q, R, Yl, YH, Fl, nn, Z: Integer;         { N channels in side sections }{      For X-ray spectra, it is recommmended to choose M=N.  Thus, there are 4N+1    channels in the top-hat filter, N in each of the two side sections and    2N+1 in the center section.  Since the center section should span an energy    range approximately equal to the FWHM (Full-Width at Half-Maximum) of the    X-ray detector, then N can be calculated as follows:            FWHM       N = ------             2K    Where K is the number of eV per X-ray spectrum channel.    The number of channels filtered equals the number of channels in the center    section (2N+1), requiring a total of 6N+1 channels centered at the peak energy    to be sampled and processed.}    BEGIN	       For nn := 1 to Maximum_Channels do Col_2^[nn] := 0.0;      For nn := 1 to Maximum_Channels do Col_3^[nn] := 0.0;            n := Left_Lobe;            M := n;            P := n;            TwoM_Plus_One := Center_Lobe;            TwoN := 2 * n;            Q := n + M + M + 1;            R := n + M + M + n + 1;            Z := n + M + M + n;			C := M + n + 1;               Yl := 1;      Fl := 1;      YH := Spectrum_Size;	  	                  Col_3^[1] := Col_1^[Yl];          FOR i := 2 TO (YH) DO Col_3^[i] := Col_1^[i] + Col_3^[i - 1];          Col_2^[1] := (Col_3^[Q] - Col_3^[P] - Col_1^[C]  - Col_3^[P] - Col_3^[R] + Col_3^[Q]) / TwoN;          P := P + 1; Q := Q + 1; R := R + 1; C := C + 1;         { advance filter }          FOR i := 1 TO (Spectrum_Size - 1 - Z) DO            BEGIN			 spinCursor;             Col_2^[1 + i] := ((Col_3^[Q] - Col_3^[P] - Col_1^[C])  - 			 				      (Col_3^[P] - Col_3^[i] + Col_3^[R] - Col_3^[Q])) / TwoN;              P := P + 1; Q := Q + 1; R := R + 1; C := C + 1;    { advance filter }            END;                                      { FOR i :=...}               FOR nn := 2 * n + 1 TO Spectrum_Size DO          Col_1^[nn] := Col_2^[nn - 2 * n];      FOR nn := 1 TO 2 * n + 1 DO        BEGIN          Col_1^[nn] := zero;        END;		    END;	  {==============================================================}end. { of UNIT MathWindow }          