unit CitPhysics;{**********************************} INTERFACE {**********************************} 	uses		QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Dialogs, Controls,   		Packages, Printing, StandardFile, fenv, fp {SANE}, SegLoad, Retrace, Windows, {StrLib,} CitInitialize, 		CITZAFCode, CITZAFCode1, Spectrum_Structures, Declarations, INITIALIZE, 		Global_Functions, Utilities, xray ; 	procedure D_Ionization_Cross_Sec;    procedure D_Mass_Absorption_Coef;	procedure D_Mean_Ionization_Pote;	procedure D_Surface_Ionization_F;    procedure D_Charactristic_Fluore;		procedure D_Backscatter_Coefficient;	procedure D_Atomic_Number_Correc;	procedure D_Analytical_Condition;	procedure D_Absorption_Correctio;	procedure D_Continuum_Fluorescen;    procedure D_Continuum_Cross_Sect;		{******************************} IMPLEMENTATION {**********************************}{$S CitPhysics}	procedure D_Continuum_Cross_Sect;	const   									I_Accept = 1;		I_No_Continuum_Cross_Se = 2;		I_Spare_3 = 3;		I_Spare_2 = 4;		I_Spare_1 = 5;		I_Green_Dyson = 6;		I_Hehenkamp_Bocker = 7;		I_Rao_Sahib_Wittry = 8;		I_Smith_Gold = 9;		I_Reed_Ware = 10;		I_Kramers = 11;		I_Small__Kramers_Normal = 12;		I_x = 13;		I_Drawn_line7 = 14;	var		    ExitDialog: boolean;   					GetSelection: DialogPtr;			tempRect: Rect;    					DType: Integer;    					Index: Integer;    					DItem: Handle; 						CItem	: controlhandle;			itemHit: Integer;  					temp: Integer; 			 				procedure Refresh_Dialog;   					var				rTempRect: Rect;     				begin			SetPort(GetSelection);  				rTempRect := tempRect;  				GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);  						InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1);  			 			tempRect := rTempRect;  			end;	begin   									GetSelection := GetNewDialog(420, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);  	    	 			GetDialogItem(GetSelection, I_No_Continuum_Cross_Se, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);  			GetDialogItem(GetSelection, I_Small__Kramers_Normal, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);  			Refresh_Dialog;     				ExitDialog := FALSE;  				repeat  								ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = I_No_Continuum_Cross_Se) then				begin					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);					if (temp = 0) then						begin						end					else						begin						end;				end;			if (ItemHit >= I_Spare_3) and (ItemHit <= I_Small__Kramers_Normal) then				begin					for Index := I_Spare_3 to I_Small__Kramers_Normal do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;		until ExitDialog;					GetDialogItem(GetSelection, I_No_Continuum_Cross_Se, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));			{ No Continuum Cross Section Used }		Index := I_Spare_3;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Small__Kramers_Normal);		temp := Index - I_Spare_3 + 1;			{ I_Spare_3 TO I_Small__Kramers_Normal HERE}		DisposeDialog(GetSelection);	end;    						{End of procedure}{$S CitPhysics24}	procedure D_Continuum_Fluorescen;	const   									I_Accept = 1;		I_Continuum_Fluorescenc = 2;		I_Spare_2 = 3;		I_Spare_1 = 4;		I_Heinrich = 5;		I_Springer = 6;		I_Henoc___COR_2 = 7;		I_x = 8;		I_Drawn_line10 = 9;var 		    ExitDialog : boolean;   					GetSelection : DialogPtr;			tempRect : Rect;    					DType : Integer;    					Index : Integer;    					DItem : Handle; 						CItem	 : controlhandle;			itemHit : Integer;  					temp : Integer; 			 	 	 	procedure Refresh_Dialog;   				var 			rTempRect:Rect;     			 		begin 			SetPort(GetSelection);  				rTempRect := tempRect;  				GetDialogItem(GetSelection,I_Accept,DType,DItem,tempRect);			PenSize(3, 3);  						InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1);  			  						tempRect := rTempRect;  	 	end; 	 	 	begin   							 			GetSelection := GetNewDialog(5022, nil,  Pointer(-1) );  			ShowWindow(GetSelection); 			SelectWindow(GetSelection); 			SetPort(GetSelection);  	 			  			GetDialogItem(GetSelection,I_Continuum_Fluorescenc,DType,DItem,tempRect);  			SetControlValue(controlhandle(DItem), 1);  	 						GetDialogItem(GetSelection,I_Henoc___COR_2,DType,DItem,tempRect);  			SetControlValue(controlhandle(DItem), 1);  	 						Refresh_Dialog;     		  			 			ExitDialog:=FALSE;  		 			 			repeat  					 				ModalDialog(nil, itemHit); 				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect); 				CItem := controlhandle(DItem);				 								if (ItemHit =I_Accept) then				begin										ExitDialog:=TRUE;					Refresh_Dialog;				end;    																if (ItemHit =I_Continuum_Fluorescenc) then				begin					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);										if (temp = 0) then					begin					end     								else    								begin					end;    												end;    												if (ItemHit >=I_Spare_2) and (ItemHit <=I_Henoc___COR_2) then				begin					for Index:=I_Spare_2  to I_Henoc___COR_2 do					begin						GetDialogItem(GetSelection, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;    								SetControlValue(CItem, 1);					ICOR := 0;				end;    												 			until ExitDialog;   					 						GetDialogItem(GetSelection,I_Continuum_Fluorescenc,DType,DItem,tempRect);			temp:= GetControlValue(controlhandle(DItem));			{??? HANDLE THE CHECKBOX RESULT FOR  Continuum Fluorescence not Calculated HERE}						Index:=I_Spare_2;   					repeat  									GetDialogItem(GetSelection, Index, DType, DItem, tempRect);				temp := GetControlValue(controlhandle(DItem));				Index := Index + 1;			until (temp<>0) or (Index >I_Henoc___COR_2);			temp:= Index -I_Spare_2 +1;			{ I_Spare_2 TO I_Henoc___COR_2 HERE}									DisposeDialog(GetSelection);					end;    						{End of procedure}		procedure D_Absorption_Correctio;	const   									I_Accept = 1;		I_Armstrong = 2;		I_Philibert_Simplified = 3;		I_Philibert_Full = 4;		I_Heinrich_Quadratic = 5;		I_Heinrich_Duplex = 6;		I_Love_Scott = 7;		I_Sewell_et_al_1 = 8;		I_Sewell_et_al_2 = 9;		I_Packwood_Brown = 10;		I_Bastin_1984 = 11;		I_Bastin_1986 = 12;		I_Riveros = 13;		I_PAP_Full = 14;		I_PAP_Simp = 15;		I_Spare_2 = 16;		I_Spare_3 = 17;		I_Spare_4 = 18;		I_Spare_5 = 19;		I_Spare_6 = 20;		I_x = 21; 	var		    ExitDialog: boolean;   					GetSelection: DialogPtr;			tempRect: Rect;    					DType: Integer;    					BTemp: Longint;			Index: Integer;    					DItem: Handle; 						CItem	: controlhandle;			itemHit: Integer;  					temp: Integer; 			 		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1); 			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(411, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection); 			{¥¥¥¥¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}		GetDialogItem(GetSelection, I_Philibert_Full, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);		GetDialogItem(GetSelection, I_Spare_4, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);		GetDialogItem(GetSelection, I_Spare_5, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);		GetDialogItem(GetSelection, I_Spare_6, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);			  if IPtc = 1 then	  begin		 GetDialogItem(GetSelection, I_Philibert_Simplified, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);   		 GetDialogItem(GetSelection, I_Philibert_Full, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);   		 GetDialogItem(GetSelection, I_Heinrich_Quadratic, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 		 GetDialogItem(GetSelection, I_Heinrich_Duplex, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 GetDialogItem(GetSelection, I_Love_Scott, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 GetDialogItem(GetSelection, I_Sewell_et_al_1, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 		 GetDialogItem(GetSelection, I_Sewell_et_al_2, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 		 GetDialogItem(GetSelection, I_PAP_Full, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 		 GetDialogItem(GetSelection, I_PAP_Simp, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		       end; 		case IABS of			1:   BTemp := 3;			2:   BTemp := 5;			3:   BTemp := 6;			4:   BTemp := 7;			5:   BTemp := 8;			6:   BTemp := 9;			7:   BTemp := 10;			8:   BTemp := 11;			9:   BTemp := 2;			10:  BTemp := 12;			11:  BTemp := 13;			12:  BTemp := 14;			13:  BTemp := 15;			14:  BTemp := 17;			15:  BTemp := 16;			otherwise BTemp := 2;						end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);							if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Armstrong) and (ItemHit <= I_Spare_6) then				begin					for Index := I_Armstrong to I_Spare_6 do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;		until ExitDialog;			{¥¥¥¥¥¥¥ Get results after dialog ¥¥¥¥¥¥¥¥¥¥}		Index := I_Armstrong;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Spare_6);		temp := Index - I_Armstrong + 1;		case temp of			2:   IABS := 9;			3:   IABS := 1;			4:   IABS := 1;			5:   IABS := 2;			6:   IABS := 3;			7:   IABS := 4;			8:   IABS := 5;			9:   IABS := 6;			10:  IABS := 7;			11:  IABS := 8;			12:  IABS := 10;			13:  IABS := 11;			14:  IABS := 12;			15:  IABS := 13;			16:  IABS := 15;			17:  IABS := 14;			otherwise IABS := 9;		end; { Case }		DisposeDialog(GetSelection);	end;    						{End of procedure}{$S CitPhysics2}	procedure D_Analytical_Condition;	const   							  		I_Accept = 1;		I_x = 2;		I_x3 = 3;		I_x5 = 4;		I_x7 = 5;		I_x9 = 6;		var		    ExitDialog: boolean;   		 			GetSelection: DialogPtr; 			tempRect: Rect;    		 			DType: Integer;    		 			DItem: Handle; 			 			sTemp          : Str255; 			 			itemHit        : Integer;  		              str,str1      : str255; 					 		procedure Refresh_Dialog;   					var				rTempRect: Rect;     				begin			SetPort(GetSelection);  	 			rTempRect := tempRect;  	 			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);  			 			InsetRect(tempRect, -4, -4); 			FrameRoundRect(tempRect, 16, 16);  			PenSize(1, 1);  			   			tempRect := rTempRect;  	 		end;	begin   							 		GetSelection := GetNewDialog(427, nil, Pointer(-1)); 		ShowWindow(GetSelection); 		SelectWindow(GetSelection); 		SetPort(GetSelection);  	   		GetDialogItem(GetSelection, I_x7, DType, DItem, tempRect);		if not Manual_Mode then		RealToString( Plt_spec[10]^^.Expt_Info.kV , 5, 2, str)		else		RealToString( E0 , 5, 2, str);		SetDialogItemText(DItem, str);		GetDialogItem(GetSelection, I_x9, DType, DItem, tempRect);		if not Manual_Mode then		RealToString( Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle , 5, 2, str1)		else		RealToString( T0 , 5, 2, str1);		SetDialogItemText(DItem, Str1); 		Refresh_Dialog;     		 		ExitDialog := FALSE;  		 		repeat  					 			ModalDialog(nil, itemHit); 			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);  				 			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE; 					Refresh_Dialog;				end;    				  		until ExitDialog;   		  		GetDialogItem(GetSelection, I_x7, DType, DItem, tempRect);		GetDialogItemText(DItem, sTemp);		E0 := MyStr2Num(sTemp);		GetDialogItem(GetSelection, I_x9, DType, DItem, tempRect);		GetDialogItemText(DItem, sTemp);		T0 := MyStr2Num(sTemp);  		DisposeDialog(GetSelection); 	end;    						{End of procedure}{$S CitPhysics46}	procedure D_Atomic_Number_Correc;	const		I_Accept = 1;		I_Duncumb_Reed = 2;		I_Love_Scott = 3;		I_Philibert_Tixier = 4;		I_Myklebust_Fiori = 5;		I_PAP = 6;		I_pz_Integration = 7;		 		I_Duncumb_Reed_1 = 8;		I_Duncumb_Reed_2 = 9;		I_Duncumb_Reed_3 = 10;		I_Love_Scott_1 = 11;		I_Myklebust_Fiori_1 = 12;		I_August = 14;		        	var		    ExitDialog: boolean; 			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			BTemp: Longint;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1); 			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(412, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection); 			{¥¥¥¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}					GetDialogItem(GetSelection, I_Myklebust_Fiori, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255); 		GetDialogItem(GetSelection, I_Myklebust_Fiori_1, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);  		case ISTP of			1:  BTemp := 2;			2:  BTemp := 4;			3:  BTemp := 5;			4:  BTemp := 3;			5:  BTemp := 6;			6:  BTemp := 7;			otherwise BTemp := 2;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1); 		case IBKS of			1:  BTemp := 8;			2:  BTemp := 9;			3:  BTemp := 10;			4:  BTemp := 11;			5:  BTemp := 14;			6:  BTemp := 12;			7:  BTemp := 13;			otherwise BTemp := 8;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Duncumb_Reed) and (ItemHit <= I_pz_Integration) then				begin					for Index := I_Duncumb_Reed to I_pz_Integration do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;			if (ItemHit >= I_Duncumb_Reed_1) and (ItemHit <= I_August) then				begin					for Index := I_Duncumb_Reed_1 to I_August do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;		until ExitDialog;			{¥¥¥¥¥¥¥¥¥¥¥¥Get results after dialog¥¥¥¥¥¥¥¥¥}		Index := I_Duncumb_Reed;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_pz_Integration);		temp := Index - I_Duncumb_Reed + 1;		case temp of			2:  ISTP := 1;			3:  ISTP := 4;			4:  ISTP := 2;			5:  ISTP := 3;			6:  ISTP := 5;			7:  ISTP := 6; 			otherwise ISTP := 1;		end; { Case }		Index := I_Duncumb_Reed_1;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_August);		temp := Index - I_Duncumb_Reed_1 + 1;		case temp of			2:  IBKS := 1;			3:  IBKS := 2;			4:  IBKS := 3;			5:  IBKS := 4;			6:  IBKS := 6;			7:  IBKS := 7;			8:  IBKS := 5;			otherwise IBKS := 1;		end; { Case }if istp = 6 then ibks := 0; {for phi-rho-z integration there is no seperate bs correction }		DisposeDialog(GetSelection);	end;    						{End of procedure}	procedure D_Backscatter_Coefficient;	const   									I_Accept = 1;		I_Not_Needed = 2;		I_Spare_3 = 3;		I_Spare_2 = 4;		I_Spare_1 = 5;		I_PAP = 6;		I_Love_Scott = 7;		I_Heinrich = 8; 		var		    ExitDialog: boolean;   					GetSelection: DialogPtr;			tempRect: Rect;    					DType: Integer;    					Index: Integer;    					BTemp: Longint;			DItem: Handle; 						CItem	: controlhandle;			itemHit: Integer;  					temp: Integer; 			 				procedure Refresh_Dialog;   					var				rTempRect: Rect;     				begin			SetPort(GetSelection);  				rTempRect := tempRect;  				GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);  						InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1);  			 			tempRect := rTempRect;  			end;	begin   									GetSelection := GetNewDialog(5016, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);  	 			{¥¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥} 		GetDialogItem(GetSelection, I_Spare_2, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);		GetDialogItem(GetSelection, I_Spare_3, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255); 		case IBSC of			0: 				BTemp := 2;			1: 				BTemp := 8;			2: 				BTemp := 7;			3: 				BTemp := 6;			4: 				BTemp := 5;			otherwise				BTemp := 8;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Not_Needed) and (ItemHit <= I_Heinrich) then				begin					for Index := I_Not_Needed to I_Heinrich do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;		until ExitDialog;			{¥¥¥¥¥¥¥¥¥Get results after dialog¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}		Index := I_Not_Needed;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Heinrich);		temp := Index - I_Not_Needed + 1;		case temp of			2: 				IBSC := 0;			5: 				IBSC := 4;							6: 				IBSC := 3;			7: 				IBSC := 2;			8: 				IBSC := 1;  			otherwise				IBSC := 1;		end; { Case }		DisposeDialog(GetSelection);	end;    						{End of procedure}	procedure D_Charactristic_Fluore;	const   									I_Accept = 1;		I_Spare_3 = 2;		I_Spare_2 = 3;		I_Spare_1 = 4;		I_Armstrong_modified_Reed = 5;		I_Reed = 6;		I_Spare_27 = 7;		I_Spare_19 = 8;		I_Nockolds = 9;		I_Twigg_Fraser = 10;		I_Philibert_Tixier = 11;		I_Armstrong_Buseck = 12;		I_x = 13;		I_x16 = 14;		I_x18 = 15;		I_Drawn_line9 = 16;		I_Drawn_line8 = 17;	var		    ExitDialog: boolean;   					GetSelection: DialogPtr;			tempRect: Rect;    					DType: Integer;    					Index: Integer;    					DItem: Handle; 						CItem	: controlhandle;			itemHit: Integer;  					temp: Integer; 			 		procedure Refresh_Dialog;   					var				rTempRect: Rect;     				begin			SetPort(GetSelection);  				rTempRect := tempRect;  				GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);  						InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1);  			 			tempRect := rTempRect;  			end;	begin   									GetSelection := GetNewDialog(421, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection); 			{¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥}		GetDialogItem(GetSelection, I_Armstrong_modified_Reed, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		GetDialogItem(GetSelection, I_Armstrong_Buseck, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);							if (ItemHit = I_Accept) then				begin										ExitDialog := TRUE;					Refresh_Dialog;				end;    							if (ItemHit >= I_Spare_3) and (ItemHit <= I_Reed) then				begin					for Index := I_Spare_3 to I_Reed do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;    								SetControlValue(CItem, 1);					ICOR := 0;				end;    							if (ItemHit >= I_Spare_27) and (ItemHit <= I_Armstrong_Buseck) then				begin					for Index := I_Spare_27 to I_Armstrong_Buseck do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;    								SetControlValue(CItem, 1);					ICOR := 0;				end;    						until ExitDialog;   							Index := I_Spare_3;   				repeat  								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Reed);		temp := Index - I_Spare_3 + 1;			{ I_Spare_3 TO I_Reed HERE}		Index := I_Spare_27;  				repeat  								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Armstrong_Buseck);		temp := Index - I_Spare_27 + 1;			{ I_Spare_27 TO I_Armstrong_Buseck HERE}		DisposeDialog(GetSelection);	end;    						{End of procedure}		procedure D_Surface_Ionization_F;	const		I_Accept = 1;		I_Not_Needed = 2;		I_Reuter = 9;	var		    ExitDialog: boolean; 			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 			BTemp: Longint;		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1); 			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(5017, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);  			{¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}		case IPHI of			0:  BTemp := 2;			1:  BTemp := 9;			2:  BTemp := 8;			3:  BTemp := 7;			4:  BTemp := 6;			5:  BTemp := 5;			6:  BTemp := 4;			7:  BTemp := 3;			otherwise BTemp := 9;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Not_Needed) and (ItemHit <= I_Reuter) then				begin					for Index := I_Not_Needed to I_Reuter do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;		until ExitDialog;		Index := I_Not_Needed;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Reuter);		temp := Index - I_Not_Needed + 1;		case temp of			2:  IPHI := 0;			3:  IPHI := 7;			4:  IPHI := 6;			5:  IPHI := 5;			6:  IPHI := 4;			7:  IPHI := 3;			8:  IPHI := 2;							9:  IPHI := 1; 			otherwise IPHI := 1;		end; { Case }		DisposeDialog(GetSelection);	end;    						{End of procedure} 	procedure D_Mean_Ionization_Pote;	const   							  		I_Accept = 1;		I_Spare = 2;		I_Bloch = 3;		I_Heinrich = 4;		I_Wilson = 5;		I_Springer = 6;		I_Ruste_Zeller = 7;		I_Duncumb_Da_Casa = 8;		I_Berger_Seltzer = 9;		I_x = 10;		I_Drawn_line1 = 11;	var		    ExitDialog: boolean;  			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			BTemp: Longint;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1); 			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(415, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection); 			{¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}		GetDialogItem(GetSelection, I_Spare, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);{Dim the radio}		case IMIP of			1:  BTemp := 9;			2:  BTemp := 8;			3:  BTemp := 7;			4:  BTemp := 6;			5:  BTemp := 5;			6:  BTemp := 4;			7:  BTemp := 3;			otherwise BTemp := 9;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Spare) and (ItemHit <= I_Berger_Seltzer) then				begin					for Index := I_Spare to I_Berger_Seltzer do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);					ICOR := 0;				end;		until ExitDialog;		Index := I_Spare;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Berger_Seltzer);		temp := Index - I_Spare + 1;		case temp of			2:  IMIP := 1;			3:  IMIP := 7;			4:  IMIP := 6;			5:  IMIP := 5;			6:  IMIP := 4;			7:  IMIP := 3;			8:  IMIP := 2;			9:  IMIP := 1;			otherwise IMIP := 1;		end; { Case }		DisposeDialog(GetSelection);	end;    						{End of procedure}	procedure D_Mass_Absorption_Coef;	const		I_Accept = 1;		I_Input_Selected_MAC_S = 2;		I_Calculate_from_Heinri = 3;		I_Calculate_from_FRAME = 4;		I_Read_From_CITZAF_File = 5;	var		    ExitDialog: boolean; 			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 			BTemp: Longint;		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1); 			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(5018, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection); 			{¥¥¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}		GetDialogItem(GetSelection, I_Calculate_from_FRAME, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255);{Dim the radio}		GetDialogItem(GetSelection, I_Input_Selected_MAC_S, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  { Grey out the radio box since not implemented }		HiliteControl(CItem, 255); 		case IMAC of			1: 				BTemp := 5;			2: 				BTemp := 3;			3: 				BTemp := 4;			otherwise				BTemp := 5;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		GetDialogItem(GetSelection, I_Read_From_CITZAF_File, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = I_Input_Selected_MAC_S) then				begin					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);					if (temp = 0) then						begin							IMAC_Input := True;						end					else						begin							IMAC_Input := False;						end;				end;			if (ItemHit >= I_Calculate_from_Heinri) and (ItemHit <= I_Read_From_CITZAF_File) then				begin					for Index := I_Calculate_from_Heinri to I_Read_From_CITZAF_File do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);				end;		until ExitDialog;		Index := I_Calculate_from_Heinri;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Read_From_CITZAF_File);		temp := Index - I_Calculate_from_Heinri + 1;		case temp of			2: 				IMAC := 2;			3: 				IMAC := 3;			4: 				IMAC := 1;			otherwise				IMAC := 1;		end; { Case }		DisposeDialog(GetSelection);	end;    						{End of procedure} {$S CitPhysics452}	procedure D_Ionization_Cross_Sec;	const   							  		I_Accept = 1;		I_No_Cross_Sections_Use = 2;		I_Spare_5 = 3;		I_Spare_4 = 4;		I_Spare_3 = 5;		I_Spare_2 = 6;		I_Spare_1 = 7;		I_Jakoby = 8;		I_Casnati = 9;		I_Brown = 10;		I_Lotz_1_25 = 11;		I_Drawin = 12;		I_Mott_Massey = 13;		I_Gryzinski = 14;		I_Worthington_Tomlin = 15;		I_Green_Cosslett = 16;		I_Sigma_K = 17;		I_Hutchins = 18;		I_Fabre = 19;		I_Spare_6 = 20;		I_Spare_521 = 21;		I_Spare_423 = 22;		I_Spare_325 = 23;		I_Spare_227 = 24;		I_Spare_129 = 25;		I_Brown31 = 26;		I_Sigma_L = 27;		I_Bethe__Powell = 28;		I_Spare_435 = 29;		I_Spare_337 = 30;		I_Spare_239 = 31;		I_Spare_141 = 32;		I_Bethe__Fiori = 33;		I_Brown44 = 34;		I_x = 35;		I_x47 = 36;		I_x49 = 37;		I_x51 = 38;		I_Drawn_line6 = 39;		I_Drawn_line5 = 40;	var		ExitDialog: boolean;   		    			GetSelection: DialogPtr;			tempRect: Rect;    					DType: Integer;    					Index: Integer;    					DItem: Handle; 						CItem	: controlhandle;			itemHit: Integer;  					temp: Integer; 			  				procedure Refresh_Dialog;   					var				rTempRect: Rect;     				begin			SetPort(GetSelection);  				rTempRect := tempRect;  				GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);  						InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1);  			 			tempRect := rTempRect;  			end;	begin   									GetSelection := GetNewDialog(5019, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);  	 					GetDialogItem(GetSelection, I_No_Cross_Sections_Use, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);  			GetDialogItem(GetSelection, I_Fabre, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);  			GetDialogItem(GetSelection, I_Bethe__Powell, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);  			GetDialogItem(GetSelection, I_Brown44, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);  			Refresh_Dialog;     				ExitDialog := FALSE;  				repeat  								ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);							if (ItemHit = I_Accept) then				begin										ExitDialog := TRUE;					Refresh_Dialog;				end;    							if (ItemHit = I_No_Cross_Sections_Use) then				begin					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);					if (temp = 0) then						begin						end     								else    									begin						end;    							end;    							if (ItemHit >= I_Spare_5) and (ItemHit <= I_Fabre) then				begin					for Index := I_Spare_5 to I_Fabre do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;    								SetControlValue(CItem, 1);					ICOR := 0;				end;    							if (ItemHit >= I_Spare_6) and (ItemHit <= I_Bethe__Powell) then				begin					for Index := I_Spare_6 to I_Bethe__Powell do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;    								SetControlValue(CItem, 1);					ICOR := 0;				end;    							if (ItemHit >= I_Spare_435) and (ItemHit <= I_Brown44) then				begin					for Index := I_Spare_435 to I_Brown44 do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;    								SetControlValue(CItem, 1);					ICOR := 0;				end;    						until ExitDialog;   							GetDialogItem(GetSelection, I_No_Cross_Sections_Use, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));			{??? HANDLE THE CHECKBOX RESULT FOR  No Cross Sections Used HERE}		Index := I_Spare_5;   				repeat  								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Fabre);		temp := Index - I_Spare_5 + 1;			{ I_Spare_5 TO I_Fabre HERE}		Index := I_Spare_6;   				repeat  								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Bethe__Powell);		temp := Index - I_Spare_6 + 1;			{ I_Spare_6 TO I_Bethe__Powell HERE}		Index := I_Spare_435; 				repeat  								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Brown44);		temp := Index - I_Spare_435 + 1;			{ I_Spare_435 TO I_Brown44 HERE}		DisposeDialog(GetSelection);	end;    						{End of procedure}end.    							{End of unit}