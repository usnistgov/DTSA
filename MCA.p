 {[j=30/55,:+,u+,r+,o=100,k+,n+,#+,v+,q+,b+,d-]} {[f-]}      {********************************} Program  DTSA; {*********************************}                                { Started  7/2/88  } 															                                   { by C.E. Fiori }        {National Institute of Standards and Technology, Gaithersburg MD 20899}		                   { Telephone 301-975-3926 }					                                  {  C.R. Swyt }              { National Institutes of Health, Bethesda, MD 20892  }                           { Telephone 301-496-2599 }                             { and R.L. Myklebust }        {National Institute of Standards and Technology, Gaithersburg MD 20899}					       { Telephone 301-975-3906 }					                    { Languages: MPW Pascal V3.3, and MPW ASSEMBLER }  USES 	 QuickDraw, QuickdrawText, Types, OSUtils, Events, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Windows, Controls,  Packages, Printing, StandardFile, Serial, Fonts, Resources, fenv, fp {SANE}, PasLibIntf, SegLoad, TextEdit, Dialogs, TextUtils, Finder, Retrace, Palettes, Spectrum_Structures,  Declarations, INITIALIZE, Global_Functions, Utilities, CurveFit, Sandia, Physics_Windows, Physics, SiLiWin, Calibrate, Choices, Tools,   Menus_D, Linear_Least_Squares, Connect, AcquirePlugins {SDD}, FilePlugins {RLM};   {[f+]}     TYPE	T_ROI       = ROI_Data_Structure;		var  			temp                  : Integer; 			  			mm				      : Integer;			Temp_Roi              : T_ROI;			str1		          : str255; 	  {$S cf}   PROCEDURE _DataInit; EXTERNAL; { This must not be in MAIN segment }{$S Main1}    	    PROCEDURE Read_AutoLaunch_Data(The_File_Name: Str255);      VAR        refnum			             : integer;        bytecount                    : LongInt;		errCode                      : osErr;      BEGIN	    putmessage('starting from MCA file: ',The_File_Name,'','');              MCA_Spectrum_Active := True ;	          RdBinaryName := The_File_Name;			  Binary_VolNum_Read := Read_DTSA_Spec.vRefNum;			 (* errCode := FSMakeFSSpec(Binary_VolNum_Read, 0, RdBinaryName, Read_DTSA_Spec);*)			  refnum := Hold_RefNum;			  bytecount := sizeof(Expt_InfoRec);			  errcode := setfpos(Hold_RefNum,fsfromStart,0);			  errCode := FSread(Hold_RefNum, bytecount, @Plt_Spec[10]^^.Expt_Info);			  Displayed_Fst := Plt_spec[10]^^.Expt_Info.FirstSpec;			  Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;			  errcode := setfpos(Hold_RefNum,fsfromStart,0);			  bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts) +						  longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;			  errCode := FSread(Hold_RefNum, bytecount, @Plt_Spec[10]^^);			  Spectrum_Counter := Plt_spec[10]^^.Expt_Info.FirstSpec;			  Spec_displayed := Spectrum_Counter;			  { always end with this set to the # of spectrum displayed }			 		  errCode := FSClose(Hold_RefNum);		  errCode := FlushVol(NIL, 0);                             		  Spectrum_Full[10] := True;		 CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);		 Refresh_ROIs;		 SpecWork_has_been_Changed := True;		 saved_displayed := true;		 Update_full;      END;    PROCEDURE Read_AutoLaunch_Preferences(The_File_Name: Str255);      VAR       { errCode                      : osErr;}      BEGIN	    putmessage('starting from Prefs','','','');      (*  mytype := 'MCAp';         errCode := FSOpen(The_File_Name, 0, theRefnum);        IF errCode = ioErr          THEN PutMessage('Could not open the file. I/O error', '', '', '');        IF errCode = nsvErr          THEN PutMessage('Could not open the file. No such volume', '', '', '');        IF errCode = fnfErr          THEN PutMessage('Could not open the file. File not found', '', '', '');        IF errCode = tmfoErr          THEN PutMessage('Could not open the file. Too many files open', '', '', '');        IF (errCode = noErr) OR (errCode = opWrErr)          THEN            BEGIN               ReadPreferences;            END; 		 *)      END;                                            {Read_AutoLaunch_Preferences}    PROCEDURE DoFinderOpen;                           {Dispatch a finder open for 'MCAp' files}      VAR		err		 	 				 : OSerr;      BEGIN        IF (FileInfo.ftype = 'MCAp')          THEN            BEGIN              IF FSpOpenDF(PrefSpec, fsRdWrPerm, Hold_RefNum) <> noErr                THEN                  BEGIN                    ErrG := FSClose(Hold_RefNum);                    PutMessage('Problem in getting file name', '', '', '');                    Exit(DoFinderOpen);                  END;              			     PutMessage('Autolaunch from Preferences.',' File name is: ',FileInfo.fName,'');                 Read_AutoLaunch_Preferences(FileInfo.fName);			end;        IF (FileInfo.ftype = 'MCAf') THEN 			begin			  err := FSMakeFSSpec(FileInfo.vRefNum, 0, FileInfo.fName, Read_DTSA_Spec);              IF FSpOpenDF(Read_DTSA_Spec, fsRdPerm, Hold_RefNum) <> noErr                THEN                  BEGIN                    ErrG := FSClose(Hold_RefNum);                    PutMessage('Problem in getting file name', '', '', '');                    Exit(DoFinderOpen);                  END;              			     PutMessage('Autolaunch from DTSA file.',' File name is: ',FileInfo.fName,'');                 Read_AutoLaunch_Data(FileInfo.fName);            END;      END;(*Procedure GetTheAppFiles;VARI        	 : integer;strz, stry	 : str255;begin        CountAppFiles(Message, count);                {See if implicit launch}		numtostring(count,strz);		numtostring(Message,stry);		PutMessage('Autolaunch count is: ',strz,' Message is: ',stry);        IF count <> 0          THEN            FOR I := 1 TO count DO              BEGIN                IT := I;                GetAppFiles(IT, FileInfo);            {If so, cycle through all files}                IF Message = AppOpen                  THEN begin				    				  	DoFinderOpen;				  end;                {ELSE IF Message=AppPrint THEN DoFinderPrint;}                ClrAppFiles(IT);                      {Signal that file is finished}              END;        IF Message = AppPrint          THEN ExitToShell;end;*)  {еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}             {еееееееееее}  PROCEDURE Do_Full(myEvent: EventRecord); {еееееееееее}	 { Handle mouse down events in the upper window based on the window and other Booleans } {еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}    VAR		slopeY                       : Real; 		b                            : Real; 		val                          : Real; 		diff                         : Real; 		theBottom                    : Integer;         		theTop                       : Integer; 		counts                       : ARRAY [1..10] OF Real;		offset                       : Integer;		j, k, Index, n               : Integer;		slopeX                       : Real;		thePt,theOldPt				 : Point;		temp_X, Temp_Y               : Integer;        str  : str255;					  PROCEDURE H_Expand_Contract;  	  BEGIN		if Mouse_Function_Expand then Get_New_Range( 1 ) {in Tools:1 means expand}		else Get_New_Range( 2 );		ChannelMax :=  Chan_num + New_Range div 2 ;								ChannelMin :=  Chan_num - New_Range div 2 + 1 ;						  		IF ChannelMin < 1		 THEN Begin		 	ChannelMin := 1;			ChannelMax := New_Range;		 end;	    IF ChannelMax > Spectrum_Size		 THEN begin		 	ChannelMax := Spectrum_Size;			ChannelMin :=  Spectrum_Size - New_Range;		 end;		 		IF SiLi_Window_Active THEN 		BEGIN		 UpDate_SiLi_Window(SiLiWindow);		 Update_SiLi_Thumbs;	{in SiliWin.p}		END;		IF StripPeak_Window_Active		 THEN Update_Strip_Peak(Strip_PeakWindow);		IF Calibrate_Window_Active		 THEN Update_Calibrate(Calibrate_GetSelection);		Update_Full;		mouse_active_window;	  END;	{PROCEDURE H_Expand_Contract;}	  PROCEDURE V_ContractExpand;	  	  BEGIN		 if Mouse_Vert_Expand then diff :=  (V_Scale_Top - V_Scale_Bottom) / 3 		 else if Mouse_Vert_Contract then diff :=  (V_Scale_Top - V_Scale_Bottom) * 1.0 ;		 V_Scale_Top := val + diff;		 V_Scale_Bottom := val - diff;		 Scale_Changed_Event := True;		   		 UpDate_SiLi_Window(SiLiWindow);		 Update_SiLi_Thumbs;		 Update_Full;				mouse_active_window;	  END;BEGIN	IF (FrontWindow = MAINPtr) then exit(Do_Full); 	 	IF (BackPlane <> NIL) THEN BEGIN		IF DragLabel THEN BEGIN			slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen );			GetMouse(thePt);			theOldPt:=thePt;			HideCursor;			InValRect(Lab^^.S[Active_Peak_Label].Box);			BeginUpdate(BackPlane);				UPDATE_FULL;				mouse_active_window;			EndUpdate(BackPlane);			RGBForeColor(PeakLabel_Color);			PutSymbol(Lab^^.S[Active_Peak_Label].Box, 					'Monaco', LabelSize, [], 					Lab^^.S[Active_Peak_Label].Element, 					Lab^^.S[Active_Peak_Label].Family, 					Lab^^.S[Active_Peak_Label].Greek);			REPEAT				GetMouse(thePt);				IF (thePt.h<>theOldPt.h) OR (thePt.v<>theOldPt.v) THEN BEGIN					Chan_num := rinttol(slopeX * thePt.h + ChannelMin - slopeX * 13 ); 					IF Chan_num < ChannelMin THEN Chan_num := ChannelMin;					IF Chan_num > ChannelMax THEN Chan_num := ChannelMax;					IF Chan_num < 1 THEN Chan_num := 1;					IF Chan_num > Spectrum_Size THEN Chan_num := Spectrum_Size;					IF (Lab^^.S[Active_Peak_Label].Exists) THEN BEGIN						k := Chan_num;						if Chan_num < Lab^^.S[Active_Peak_Label].Channel - Lab_Left_Limit then 									 k := Lab^^.S[Active_Peak_Label].Channel - Lab_Left_Limit;						if Chan_num > Lab^^.S[Active_Peak_Label].Channel + Lab_Right_Limit then 									 k := Lab^^.S[Active_Peak_Label].Channel + Lab_Right_Limit;															 						Lab^^.S[Active_Peak_Label].ShiftedChannel := k;												Lab^^.S[Active_Peak_Label].XCenter := 								rinttol(( k - ChannelMin + slopeX * 13) / slopeX);						Lab^^.S[Active_Peak_Label].YCenter := (thePt.v - theOldPt.v) +								 Lab^^.S[Active_Peak_Label].YCenter;								 					    if Lab^^.S[Active_Peak_Label].YCenter < BackPlaneRect.Top + 25 then 						   Lab^^.S[Active_Peak_Label].YCenter := BackPlaneRect.Top + 25;					    if Lab^^.S[Active_Peak_Label].YCenter > BackPlaneRect.Bottom - 50 then 						   Lab^^.S[Active_Peak_Label].YCenter := BackPlaneRect.Bottom - 50;					    if Lab^^.S[Active_Peak_Label].XCenter > BackPlaneRect.Right - 2 then 						   Lab^^.S[Active_Peak_Label].XCenter := BackPlaneRect.Right - 2;					    if Lab^^.S[Active_Peak_Label].XCenter < BackPlaneRect.Left + 40 then 						   Lab^^.S[Active_Peak_Label].XCenter := BackPlaneRect.Left + 40;								 						Lab^^.S[Active_Peak_Label].Box.Left  := 								Lab^^.S[Active_Peak_Label].XCenter - 20;						Lab^^.S[Active_Peak_Label].Box.Top   := 								Lab^^.S[Active_Peak_Label].YCenter - 6;														SetRect(Lab^^.S[Active_Peak_Label].Box, 								Lab^^.S[Active_Peak_Label].Box.Left, 								Lab^^.S[Active_Peak_Label].Box.Top, 								Lab^^.S[Active_Peak_Label].Box.Left + 35, 								Lab^^.S[Active_Peak_Label].Box.Top + 15);																		OffScreen_2_OnScreen;						RGBForeColor(PeakLabel_Color);						PutSymbol(Lab^^.S[Active_Peak_Label].Box, 								'Monaco', LabelSize, [], 								Lab^^.S[Active_Peak_Label].Element, 								Lab^^.S[Active_Peak_Label].Family, 								Lab^^.S[Active_Peak_Label].Greek);					END;					theOldPt:=thePt;				END;			UNTIL (not Button);			SetPort(grafPtr(BackPlane));			Lab^^.S[Active_Peak_Label].Active:=False;			Active_Peak_Label:=0;			UPDATE_FULL;				mouse_active_window;			ShowCursor;		END{drag_label} ELSE IF DragBox THEN BEGIN			GetMouse(thePt);			theOldPt:=thePt;			HideCursor;			temp_X := BoxRect.Right - BoxRect.Left; { get the current size of the little box }			temp_Y := BoxRect.Bottom - BoxRect.Top;						REPEAT 				GetMouse(thePt);				IF (thePt.h<>theOldPt.h) OR (thePt.v<>theOldPt.v) THEN BEGIN					OffSetRect(BoxRect,(thePt.h-theOldPt.h),(thePt.v-theOldPt.v));					   					   if BoxRect.Top < BackPlaneRect.Top + 17 then					     BEGIN						  BoxRect.Top := BackPlaneRect.Top + 17;						  BoxRect.Bottom := BoxRect.Top + temp_Y;						 END;						 					   if BoxRect.Bottom > BackPlaneRect.Bottom - 24 then 					     BEGIN						  BoxRect.Bottom := BackPlaneRect.Bottom - 24;						  BoxRect.Top := BoxRect.Bottom - temp_Y;						 END;						 					   if BoxRect.Right > BackPlaneRect.Right - 2 then					     BEGIN						  BoxRect.Right := BackPlaneRect.Right - 2;						  BoxRect.Left := BoxRect.Right - temp_X;						 END;						 					   if BoxRect.Left < BackPlaneRect.Left + 17 then					     BEGIN						  BoxRect.Left := BackPlaneRect.Left + 17;                          BoxRect.Right := BoxRect.Left + temp_X;						 END;						 					FOR Index := 1 TO 8 DO counts[Index] := (Plt_Spec[Index]^^.S[Chan_num]);					offset := 11;					n := 2;					MoveTo(BoxRect.Left + 4, BoxRect.Top + 10);					OffScreen_2_OnScreen;												RGBBackColor(BackGround_Color);					RGBForeColor(Axes_Color);					SetFont('geneva', 9, []);  					DrawString('Spec#      Counts '); 					FrameRect(BoxRect);					FOR j := 1 TO 8 DO BEGIN						IF Spectrum_Full[j] THEN BEGIN							MoveTo(BoxRect.Left + 4, BoxRect.Top + n* offset);							RGBForeColor(SpectrumColor[j]);							NumToString(j, Str);							DrawString(Str);							DrawString('       ');							IF rinttol(counts[j]) <> counts[j] THEN { Determine whether integer or real }								RealToString(counts[j], 5, 2, Str) { and setup appropriate format }							ELSE								NumToString(rinttol(counts[j]), Str);							DrawString(Str);							n := n + 1;						END;					END; { J Loop }					theOldPt:=thePt;				END;			UNTIL (not Button);			UPDATE_FULL;				mouse_active_window;			ShowCursor;		END{drag_box} ELSE IF (SiLi_Window_Active) OR (StripPeak_Window_Active) THEN 		BEGIN					IF (Mouse_Function_Expand) or (Mouse_Function_Contract) THEN H_Expand_Contract;			 			theTop := Full_Top_Screen + 35;			theBottom := theTop + Full_Bottom_Screen; { get into global coords }			slopeY :=  (V_Scale_Top - V_Scale_Bottom) / (theTop - theBottom );			b := V_Scale_Bottom - slopeY * theBottom;			val := slopeY * MouseLocation.v + b;		   IF ((Mouse_Vert_Contract) or (Mouse_Vert_Expand)) AND (SiLi_Window_Active) AND (NOT Bipolar_Display) THEN V_ContractExpand;		END ELSE IF (ID_Window_Active and not DragLabel ) THEN BEGIN			IF Button then Get_Nearest_Peak;			UPDATE_FULL;				mouse_active_window;		END;	END;                                        {End for if (BackPlane<>nil)}END;                                              {End of procedure}      {ееееееееееееееее} PROCEDURE GetXYMouse(myEvent: EventRecord); {ееееееееееееееееееее}    VAR      n                            : Integer;      slopeX                       : real;	  BEGIN	     	    IF (FrontWindow = MAINPtr) or		   (FrontWindow = Header_Info_Window) then exit(GetXYMouse);	{ Get out if we have no business here }	   		IF Mouselocation.v < 20 then Begin ChangeCursor(ArrowC); exit(GetXYMouse); End;				{ ееееее This is where chan_num is defined for the whole program ееееее }		        slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen );            Chan_num := rinttol(slopeX * Mouselocation.h + ChannelMin - slopeX * 13 ); 			            IF Chan_num < ChannelMin THEN Chan_num := ChannelMin;            IF Chan_num > ChannelMax THEN Chan_num := ChannelMax;            IF Chan_num < 1 THEN Chan_num := 1;            (*IF Chan_num > Spectrum_Size THEN Chan_num := Spectrum_Size;*)			IF Chan_num > 8192 THEN Chan_num := 8192;	{ еее } ShowCursorValues(myEvent);  { ееее In Global_Functions ееее }	{ All of the below are еWINDOWSе except for the Calibrate window, which is a modal dialog. Study }{ this structure as it is different from the way all the other dialogs are handled. A non-modal }{ dialog has its own event loop, while a modal's is in the main loop. All lower windows }{ are T=365, B=471, L=8, R=633 } 			             IF (  (Mouselocation.v > MaxWindowRect.Bottom-123) and (not SelectWindow_Occurred) )			                                     { ееSelectWindow_Occurredее allows only one window }   			     THEN BEGIN						 { activate per border crossing }                          IF SiLi_Window_Active                            THEN                              BEGIN                               { The mouse has moved from the top }                                SelectWindow(SiLiWindow);         { to a lower window. We must find }								ROI_Window_Active       := False; { which of the lowers was active }								StripPeak_Window_Active := False; { when the mouse left, and }								Calibrate_Window_Active := False; { reactivate it. Ditto for following }								Simplex_Results_Active  := False;								ID_Window_Active        := False;                             END;                          IF ROI_Window_Active                            THEN                              BEGIN								SelectWindow(ROIWindow);								SiLi_Window_Active      := False;								StripPeak_Window_Active := False;								Calibrate_Window_Active := False;								Simplex_Results_Active  := False;								ID_Window_Active        := False;                             END;                          IF StripPeak_Window_Active                            THEN                              BEGIN                                SelectWindow(Strip_PeakWindow);								ROI_Window_Active       := False;								SiLi_Window_Active      := False;								Calibrate_Window_Active := False;								Simplex_Results_Active  := False;								ID_Window_Active        := False;                              END;                          IF Calibrate_Window_Active                            THEN                              BEGIN                                SelectWindow(Calibrate_GetSelection);								ROI_Window_Active       := False;								SiLi_Window_Active      := False;								StripPeak_Window_Active := False;								Simplex_Results_Active  := False;								ID_Window_Active        := False;                              END;                          IF ID_Window_Active                            THEN                              BEGIN                                SelectWindow(Main_ID_Window);								ROI_Window_Active       := False;								SiLi_Window_Active      := False;								StripPeak_Window_Active := False;								Calibrate_Window_Active := False;								Simplex_Results_Active  := False;                              END;                          IF Simplex_Results_Active                            THEN                              BEGIN                                SelectWindow(TextWindow);								ROI_Window_Active       := False;								SiLi_Window_Active      := False;								StripPeak_Window_Active := False;								Calibrate_Window_Active := False;								ID_Window_Active        := False;                              END;							                            SelectWindow_Occurred := True;           END	{IF Mouselocation.v >MaxWindowRect.Bottom-123 ...}             ELSE IF (Mouselocation.v < MaxWindowRect.Bottom-123) AND         { Mouse moved from a lower window to the }               (SelectWindow_Occurred = True)  AND     { upper, which now has to be selected. }			   (Mouselocation.v > 20)              THEN                BEGIN                  SelectWindow(BackPlane);                  SelectWindow_Occurred := False;                END; { If all the above was false then the mouse has stayed in the upper window }								{ее Now perform any action in the upper window dictated from one of the following lower windows }{ which were previously active, which was active is remembered by the window booleans }            IF (Mouselocation.v < MaxWindowRect.Bottom-123)    AND 			   (Mouselocation.v > 20)     AND 			   (ROI_Window_Active)        THEN 			     BEGIN				  SetUp_ROIs;				  SelectWindow(BackPlane);				{  ROI_Window_Active       := true;}				  SiLi_Window_Active      := False;				  StripPeak_Window_Active := False;				  Calibrate_Window_Active := False;				  Simplex_Results_Active  := False;				  ID_Window_Active        := False;				                    SelectWindow_Occurred := False;				 END;				 			IF (Mouselocation.v < MaxWindowRect.Bottom-123)    AND 			   (Mouselocation.v > 20)     AND 			   (ID_Window_Active)         THEN                   BEGIN				  ROI_Window_Active       := False;				  SiLi_Window_Active      := False;				  StripPeak_Window_Active := False;				  Calibrate_Window_Active := False;				  Simplex_Results_Active  := False;				  {ID_Window_Active        := true;}                  SelectWindow_Occurred := False;				 END;            IF (NOT Fit_Invisibly) AND			   (ROI^^.Peak[1].Exists) AND	{added 9/27/95 because we no longer de-activate			     							 fitting and quants when ROIS cleared}			   (Simplex_Results_Active)   AND  { This logic puts the results of a window curve fit }			   (Mouselocation.v < MaxWindowRect.Bottom-123)    AND  { up when the region is clicked }               (Button) AND (Mouselocation.v > 20) THEN                BEGIN                                                   FOR n := 1 TO Number_of_PeakRois - 1 DO                    BEGIN                      IF (Chan_num >= ROI^^.Peak[n].Lo) AND (Chan_num <= ROI^^.Peak[n].Hi)                        THEN Chosen_Region := n;                      Simplex_Output_Handler(3);                    END;					  SelectWindow(BackPlane);                      SelectWindow_Occurred := False;                END;    END;(*    PROCEDURE AUTO_Marker_Type_in(Chcode,LineCode: integer );      VAR        Charac                       : str255;        Test_Text                    : str255;       BEGIN  	   {The assumption has been that the user will precede or follow a single letter or number	    element name with a space. I often hit return instead. Others may do this also.		So...this is changed.}                IF (Ord(Chcode) = 32)  OR 		  ((Ord(Chcode) > 64) AND 		   (Ord(Chcode) < 91)) OR 		  ((Ord(Chcode) > 96) AND 		   (Ord(Chcode) < 123)){ it's a letter } OR 		  ((Ord(Chcode) > 47) AND (Ord(Chcode) < 58)) { it's a number }  OR		  ((Ord(Chcode) = 13) and (length(Marker_Input_text) = 1))          THEN BEGIN		      IF (Ord(Chcode) = 13) then Charac := ' '			  ELSE Charac := Chr(Chcode);               Marker_Input_text := CONCAT(Marker_Input_text, Charac);              IF length(Marker_Input_text) = 2                THEN                  BEGIN                    Atomic_Number := AtSymbol_To_Znum(Marker_Input_text);                    IF (Atomic_Number < 3)                      THEN Atomic_Number := 3;                    IF (Atomic_Number > 95)                      THEN Atomic_Number := 95;                    IF (Atomic_Number >= 3) AND (Atomic_Number <= 95)                      THEN 					    begin						  AutoROI_Data( Atomic_Number,  LineCode); 						end;                      Marker_Input_text := '';                  END;              IF length(Marker_Input_text) > 2                THEN Marker_Input_text := '';            END;      END;  { PROCEDURE AUTO_Marker_Type_in } *)(*Procedure check_serial_port;	BEGIN	   IF SerGetBuf(myDCInfo.portIn, ipCount) = noErr THEN		 IF ipCount > 0 THEN		  BEGIN			 if ipCount > 32000 THEN beepbeep;			 SpinCursor;			 {CharCounter is initialized to 0 above;Serial_active =>T;			  we 1st get in here with CharCounter=0 then CharCounter=>ipCount;			  then we get in here with next line T and do Read_Buffer}			 if CharCounter = ipCount then 			 begin			   numtostring(ipcount,str);			   putmessage('in mca ipcount before read_buffer is',str,'','');			   Read_Buffer ;			   CharCounter := 0;			   ChangeCursor(ArrowC);			 end			 else CharCounter := ipCount;		  END;		END;*)Procedure Aquisition_stuff;CONST{SDD3}   C_Stop			 = 5;				{ Stop Acquisition						}  VAR  		indexer          : Integer;{SDD3}	StopChar		 : Char;	BEGIN	   if (Kill_citZAF) then	   begin		 Close_citZAF;		 Kill_citZAF := False;	   end;		 {SDD}		GetKeys(theKeys);{SDD}		Quick_Exit:=false;{SDD}		FOR indexer:=0 to 127 DO IF (theKeys[indexer]) THEN Quick_Exit:=true;  {SDD}		IF ((not Quick_Exit){SDD}			or (theKeys[55]) 				{CloverKey		} {SDD}			or (theKeys[56]) 				{ShiftKey		} {SDD}			or (theKeys[57]) 				{CapslockKey	} {SDD}			or (theKeys[58])) THEN BEGIN	{OptionKey		}{SDD3}			IF (CallAcquirePlugIns(acquireUpdate,-1)) THEN BEGIN	{Check all Active PlugsIns}{SDD3}				IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.FixupMenus) THEN BEGIN{SDD3}					gAcquirePlugIns[gDTSACurrentPlugIn]^.FixupMenus:=FALSE;{SDD3}					GetItemCmd(GetMenu(152),C_Stop,StopChar);{SDD3}					mResult := MenuKey(StopChar); 		{Force a Stop menu Selection}{SDD3}					theMenu := HiWord(mResult); 		{Get the menu list number}{SDD3}					theItem := LoWord(mResult); 		{Get the menu item number}{SDD3}					Handle_My_Menu(doneFlag, theMenu, theItem, theInput);{SDD3}				END;{SDD3}				Refresh_ROIs;{SDD3}				Update_Full;							{SDD3}				Update_ROI_Window(ROIWindow);{SDD3}				mouse_active_window;{SDD3}			END;{SDD}		END;	END;  FUNCTION GetMainEvent: Boolean; { It is a good idea if this function is in the segment $S MAIN                               ееееееееееееееееееееееееееееееееееееееее }    VAR      gotEvent                      : Boolean;    BEGIN      IF hasWNE { multifinder in control }         THEN        BEGIN          gotEvent := WaitNextEvent(EveryEvent, myEvent, 60, NIL);        END      ELSE { no multifinder }        BEGIN          SystemTask;          gotEvent := GetNextEvent(EveryEvent, myEvent);        END;      IF myEvent.what = mouseUp THEN MouseUp_Waiting := true;      GetMainEvent := gotEvent;    END;Procedure mousedownevent;	BEGIN		IF (code = inMenuBar)		  THEN                        {See if a menu selection}			BEGIN                     {Get the menu selection and handle it}			  mResult := MenuSelect(myEvent.where); {Do menu selection}			  theMenu := HiWord(mResult); {Get the menu list number}			  theItem := LoWord(mResult); {Get the menu list item number}			  Handle_My_Menu(doneFlag, theMenu, theItem, theInput); {Handle the menu}			END;                      {End of inMenuBar}		IF (code = InDrag)		  THEN                        {See if in a window drag area}			BEGIN                     {Do dragging the window}			  tempRect := qd.screenbits.bounds; {Get screen area, l,t,r,b, drag area}			  Setrect(tempRect, tempRect.left + 10, tempRect.top + 25,					  tempRect.Right - 10, tempRect.bottom - 10);			  DragWindow(whichWindow, myEvent.where, tempRect); {Drag the window}			  OffScreen_2_OnScreen;			(*  GetPort(GrafPtr(SavePort));				  SetPort(RoiWindow);				  InValRect(whichWindow^.portRect);				  Update_ROI_Window(RoiWindow);			  SetPort(GrafPtr(SavePort));*)			 END;                      {End of InDrag}		IF (code = inGoAway)	{See if in a window goaway area}		{ GoAway box is in Show Header or Results window}		  THEN BEGIN                     {goaway button}			  IF TrackGoAway(whichWindow, myEvent.where)			  THEN BEGIN               {Is mouse in GoAway box}				  HideWindow(whichWindow);	{moves the window behind}				  If whichWindow = Header_Info_Window				  then begin					 DisposeWindow(Header_Info_Window);					 Header_Info_Window := NIL;				  end;				(*  SetPort(RoiWindow);				  InValRect(whichWindow^.portRect);				  Update_ROI_Window(RoiWindow);*)			   END;                {End of TrackGoAway}			END;                      {End of InGoAway} 																IF (code = inContent) THEN BEGIN		IF WaitMouseUp THEN { Prevents clicks getting ahead of the action....... }			IF (whichWindow = SiLiWindow) THEN BEGIN	{the mousedown was in the Sili wind}				SetPort(SiLiWindow);				Mouse_Active_Window;	{calls FrontWindow, sets xActive true} 				Do_SiLi_Window(myEvent);			END			ELSE BEGIN				IF (whichWindow <> FrontWindow) THEN SelectWindow(whichWindow);				SetPort(whichWindow); 				Mouse_Active_Window;									 				if (whichWindow = BackPlane) then Do_Full(myEvent)				else if (whichWindow = Header_Info_Window) then Do_Header_Information(myEvent, theInput){Tools.p}				else if (whichWindow = Main_ID_Window) then Do_ID_Window(myEvent)				else if (whichWindow = TextWindow) then Do_Text_Window(myEvent)				else if (whichWindow = ROIWindow) then Do_ROI_Window(myEvent)				else if (whichWindow = Calibrate_GetSelection) then Do_Calibrate(myEvent, whichWindow) 				else if (whichWindow = Strip_PeakWindow) then Do_Strip_Peak(myEvent);									 			END;                {End of else} 		END;                      {End of inContent}	END;Procedure Keyevent;  VAR  	indexer          : Integer;	kk, JJ, ii, nn   : Integer;   LABEL 100 ;		BEGIN                        WITH myEvent DO               {Check for menu command keys}                          BEGIN 						   GetKeys(thekeys);                            Chcode := Bitand(message, Charcodemask); {Get character}                            ch := Chr(Chcode);        {Change to ASCII}							 						if NKP8Down then  begin							ScaleUp;							exit(Keyevent);						end;						if NKP2Down then  begin							ScaleDown;							exit(Keyevent);						end;						if F2Down then  Rotate_W_R;                        if F3Down then  D_Per_Tab_Buttons;                         if F4Down then  PrintStuff;												if F5Down then  						 BEGIN						   If (Simplex_Active) then Begin							   CompareGen_To_Work(theBGRec); 							   IF (SiLi_Response_Calculated = False) { if a new spectrum in work...}							   THEN BEGIN								 GenFromWork(theBGRec);	{gets theGenRec values from Work }								 Detector_efficiency(theBGRec,SiLi_Response_Calculated);							   END;						   End;						   is_batch := False;						   Do_A_Fit; {sets Results_added to False}						 END;  						if F6Down then  Add_A_Fit;						if F7Down then  See_A_Fit;						if F8Down then  ClearWork;						if F9Down then  						  BEGIN						   KludgeBoolean := TRUE; { temp boolean so resp into results button is grey if BG subt.}						   Called_for_Generate   := False;						   Called_for_Work_Spec  := True;										   Spectrum_Header_Dialog;						   Mouse_Active_Window;                          END;						if F10Down then  						  BEGIN							KludgeBoolean := TRUE;{ temp boolean so resp into results button is grey if BG subt.}							Called_for_Generate   := False;							Called_for_Work_Spec  := True;											D_Expt_Hdr;							Mouse_Active_Window;						  END;						(*if F11Down then  Convert_File_Format ; *)											if not ((G6_Del_Down) or (G6_End_Down) or (G6_PgDn_Down)) then					begin							Quick_Exit:=false; 		    				FOR indexer:=$40 to $5F DO  { keep the numeric keypad away from Marker_Type_in}								IF (theKeys[indexer]) THEN Quick_Exit:=TRUE; 							 						if not Quick_Exit then                        if not (Odd(modifiers DIV Cmdkey)) then 						 Marker_Type_in( Chcode,0 );  { get letters or numbers for the KLM markers }					                             IF (Ord(Chcode) = 30) and not (Odd(modifiers DIV Optionkey))                              THEN                                BEGIN                                  UpArrow := True;                                  Markers;                                END;                            IF (Ord(Chcode) = 31) and not (Odd(modifiers DIV Optionkey))                              THEN                                BEGIN                                  DownArrow := True;                                  Markers;                                END;                            IF (Ord(Chcode) = 29) and not (Odd(modifiers DIV Optionkey))                              THEN                                BEGIN                                  RightArrow := True;                                  Markers;                                END;                            IF (Ord(Chcode) = 28) and not (Odd(modifiers DIV Optionkey))                              THEN                                BEGIN                                  LeftArrow := True;                                  Markers;                                END;															IF Ord(Chcode) = 30 {up arrow}                              THEN                                BEGIN                                  IF (Odd(modifiers DIV Optionkey))                                    THEN 									  Begin									    Ceiling := Ceiling - rinttol(0.05 * Ceiling);										if  Ceiling <= 0 then Ceiling := 1;										Markers;									  end;                                END;															IF Ord(Chcode) = 31 {down arrow}                              THEN                                BEGIN                                  IF (Odd(modifiers DIV Optionkey))                                    THEN 									  Begin									    Ceiling := Ceiling + rinttol(0.05 * Ceiling);										if rinttol(0.05 * Ceiling)=0 then Ceiling := Ceiling + 5;										Markers;									  end;                                END;								                     end  { if not G6_Del_Down or G6_End_Down or G6_PgDn_Down then ... }					else					begin					  if G6_Del_Down  then temp  := 1;					  if G6_End_Down  then temp  := 2;					  if G6_PgDn_Down then temp  := 3; 					  Marker_Type_in( Chcode, temp); 					  (*AUTO_Marker_Type_in( Chcode, temp);*) 					  Kill_Quants;					  Simplex_active := False;					  LLSQ_active := False;			FOR kk := 1 TO Max_Rois DO { First do an Energy Sort based on the Lower Limit } 		   FOR JJ := kk+1 to Max_Rois do		   begin             if (ROI^^.Peak[kk].Exists) AND (ROI^^.Peak[JJ].Exists) then 			  if ROI^^.Peak[kk].Lo > ROI^^.Peak[JJ].Lo then			  begin			    Temp_Roi := ROI^^.Peak[kk];                ROI^^.Peak[kk] := ROI^^.Peak[JJ];                ROI^^.Peak[JJ] := Temp_Roi; 			  end;		   end;        100:	mm := Number_of_PeakRois;		FOR kk := 1 TO mm DO { Now combine any that overlap, for ALL elements chosen } 		FOR JJ := kk + 1 to mm do		begin		     if (ROI^^.Peak[kk].Exists) AND (ROI^^.Peak[JJ].Exists) then 			 if ROI^^.Peak[kk].Hi+8 > ROI^^.Peak[JJ].Lo then		{ееееoverlapееее}			 begin			  			   if ROI^^.Peak[kk].Hi > ROI^^.Peak[JJ].Hi then { JJ is completely nested, so dump it }			   begin				  FOR ii := JJ TO mm DO 					begin					   ROI^^.Peak[ii] := ROI^^.Peak[ii + 1];					   ROI^^.Peak[ii].ROI := ii;					end;					   Number_of_PeakRois := Number_of_PeakRois-1;				  goto 100;  			   end;			                  ROI^^.Peak[kk].Hi := ROI^^.Peak[JJ].Hi;				ROI^^.Peak[kk].ROI := kk;				FOR ii := JJ TO mm DO 				begin					 ROI^^.Peak[ii] := ROI^^.Peak[ii + 1];					 ROI^^.Peak[ii].ROI := ii;				end;				   Number_of_PeakRois := Number_of_PeakRois-1;			   goto 100;  			 end;	{if (ROI^^.Peak[kk].Exists...}  		  end;	{FOR kk := 1 TO mm...} 			  if (ROI^^.Peak[1].Exists) then Use_manual_rois := true; 			  Refresh_ROIs;			  Update_Full;			  GetPort(GrafPtr(SavePort));			  SetPort(ROIWindow);			  InvalRect(ROIWindow^.portRect);			  SetPort(GrafPtr(SavePort));					  		end; { if not ((G6_Del_Down) or (G6_End_Down) or (G6_PgDn_Down)) then....... }						 if Interrupted thenbeginnumtostring(Plain_VolNum,str);if Plain_Boolean thenstr := CONCAT('PlainName: ',PlainName,{'FileVar= ', Plain,}'Plain_VolNum= ',str) elsestr := 'Plain_Boolean is OFF';numtostring(Spread_VolNum,str1);if Spread_Boolean thenstr1 := CONCAT('SpreadName: ',SpreadName,{'FileVar= ',Spread,}'Spread_VolNum= ',str1) elsestr1 := 'Spread_Boolean is OFF';putmessage(str,str1,'','');end;	if (NKPClearDown) AND (NKPEqualDown) then { Clear all the Peak ROI`s}	   begin               FOR nn := 1 TO Max_Rois DO                BEGIN                  ROI^^.Peak[nn].Lo := 1;                  ROI^^.Peak[nn].Hi := 1;                  ROI^^.Peak[nn].Value := zero;                  ROI^^.Peak[nn].Exists := False;                  ROI^^.Peak[nn].ROI := nn;                END;			  Use_manual_rois := false;		(*    Kill_Quants;			  Simplex_active := False;			  LLSQ_active := False;		....once these are setup they know the ROIs		*)              Number_of_PeakRois := 1;              Refresh_ROIs;              Update_Full;			  GetPort(GrafPtr(SavePort));			  SetPort(ROIWindow);			  InvalRect(ROIWindow^.portRect);			  SetPort(GrafPtr(SavePort));       	end;	                            IF (Odd(modifiers DIV Cmdkey))                              THEN                    {See if Command key is down}                                BEGIN                                                   mResult := MenuKey(ch); {See if menu selection}                                  theMenu := HiWord(mResult); {Get the menu list number}                                  theItem := LoWord(mResult); {Get the menu item number}                                  IF (theMenu <> 0)                                    THEN              {See if a list was selected}                                      Handle_My_Menu(doneFlag, theMenu, theItem, theInput);                                   IF ((ch = 'x') OR (ch = 'X')) AND (theInput <> NIL)                                    THEN                                                    TECut(theInput); {Handle a Cut in a TE area}                                  IF ((ch = 'c') OR (ch = 'C')) AND (theInput <> NIL)                                    THEN                                                    TECopy(theInput); {Handle a Copy in a TE area}                                  IF ((ch = 'v') OR (ch = 'V')) AND (theInput <> NIL)                                    THEN                                               TEPaste(theInput); {Handle a Paste in a TE area}                                                        END                                                 ELSE                                IF (theInput <> NIL)                                  THEN                                                    TEKey(ch, theInput); 							                           END;                        {End for with}                      	END;Procedure UDateEvent;  VAR  	indexer          : Integer;	BEGIN		whichWindow := WindowPtr(myEvent.message); {Get the window the update is for}		indexer := GetWRefCon(whichWindow);		CASE (indexer) OF			12:	BEGIN { 12 := $C SiLi Window}				  {  if SiLi_Window_Active then 					BEGIN	}					   SiLi_Window_Active      := True;					   ROI_Window_Active       := False;					   StripPeak_Window_Active := False;					   Calibrate_Window_Active := False;					   Simplex_Results_Active  := False;					   ID_Window_Active        := False;					   UpDate_SiLi_Window(whichWindow);					{END;}				END;			13:	BEGIN { 13 := $D BACKPLANE }					BeginUpdate(whichWindow);					 DrawAxesFull;					 Update_Full;					 mouse_active_window;					EndUpdate(whichWindow);				END;																  							  			38:	BEGIN { 38 := $26 }					if ID_Window_Active then BEGIN																												   ROI_Window_Active       := False;					   SiLi_Window_Active      := False;					   StripPeak_Window_Active := False;					   Calibrate_Window_Active := False;					   Simplex_Results_Active  := False;					   Update_ID_Window(whichWindow);					END;				END;			39:	BEGIN  { 39 := $27 CurveFit.p, the little simplex window at bottom}					if (Simplex_Results_Active) then 					BEGIN																				   ROI_Window_Active       := False;					   SiLi_Window_Active      := False;					   StripPeak_Window_Active := False;					   Calibrate_Window_Active := False;					   ID_Window_Active        := False;					   Update_Text_Window(whichWindow);					END;				END;			42: BEGIN { 42 := $2A } { Acquire Window, Do nothing }					ROI_Window_Active       := False;					SiLi_Window_Active      := False;					StripPeak_Window_Active := False;					Calibrate_Window_Active := False;					Simplex_Results_Active  := False;					ID_Window_Active        := False;				END;			43:	BEGIN { 43 := $2B ROI window}					if ROI_Window_Active then 					BEGIN													   SiLi_Window_Active      := False;					   StripPeak_Window_Active := False;					   Calibrate_Window_Active := False;					   Simplex_Results_Active  := False;					   ID_Window_Active        := False;					   Refresh_ROIs;					   Update_ROI_Window(whichWindow);					END;				END;				46:	BEGIN { 46 := $2E Header info window}				    ROI_Window_Active       := False;	{this was commented out?}					SiLi_Window_Active      := False;					StripPeak_Window_Active := False;					Calibrate_Window_Active := False;					Simplex_Results_Active  := False;					ID_Window_Active        := False;					BeginUpdate(whichWindow);					 DrawAxesFull;					 Update_Full;					 mouse_active_window;					EndUpdate(whichWindow); 				END;			51:	BEGIN { 51 := $33 Header info window}					if Calibrate_Window_Active then 					BEGIN													   SiLi_Window_Active      := False;					   StripPeak_Window_Active := False;					   ROI_Window_Active	   := False;					   Simplex_Results_Active  := False;					   ID_Window_Active        := False;					   Update_Calibrate(whichWindow);					   Update_Full;		  			   mouse_active_window;					END;				END;						   111: BEGIN { 111 := $6F Alpha window, Do nothing}					ROI_Window_Active       := False;					SiLi_Window_Active      := False;					StripPeak_Window_Active := False;					Calibrate_Window_Active := False;					Simplex_Results_Active  := False;					ID_Window_Active        := False;				END;		  4001: BEGIN { 4001 := $FA1 Strip_PeakWindow}					if StripPeak_Window_Active then 					BEGIN					  ROI_Window_Active       := False;					  SiLi_Window_Active      := False;					  Calibrate_Window_Active := False;					  Simplex_Results_Active  := False;					  ID_Window_Active        := False;					  Update_Strip_Peak(whichWindow);					END;				END;									OTHERWISE BEGIN				ROI_Window_Active       := False;				SiLi_Window_Active      := False;				StripPeak_Window_Active := False;				Calibrate_Window_Active := False;				Simplex_Results_Active  := False;				ID_Window_Active        := False;				END;			END;		InitCursor;	END;	Procedure SetStackSize (stkSize:	longint);{var bytecount:longint;}Begin	{ At application startup the heap limit is set to give the stack 8k bytes(ii-17). If	  we reduce this limit by stacksize we give the stack more room.}	 SetApplLimit (Ptr (longint (GetApplLimit) - stkSize));	(* bytecount := longint(@stkSize);*) End; {SetStackSize}  {еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}  {еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}  {еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}  {$S Main}   BEGIN          {ееееееееееееее Start of main program еееееееееееееееее}   	{UnloadSeg(@_DataInit); }	{ii-59}  	SetStackSize(250000);   	MaxApplZone;	{ ii-30: expands the heap zone to the limit }    InitGraf(@qd.thePort); 	{ initializes QuickDraw }    InitFonts;                                            InitWindows;                                          InitMenus;                                                TEInit;                                               InitDialogs(NIL);                                 	InitCursor;    For index := 1 to 101 do MoreMasters;	{ allocates blocks of master ptrs in the heap zone}	MCA_Home_Res_RefNum := CurResFile; { ееее MUST ееее be done before any putMessage!!!!!!!!!! }    Start_Up := True;    DebugerON  := false;	    FlushEvents(everyEvent, 0);    wasDown := False;                                     doneFlag := False;                                    Init_My_Menus;                                        theInput := NIL;		CheckBits;   	AssignMemory;	{ее All global variables must be assigned or space allocated is this routineее}    (*SetupDataComm;*)   { Load in some values in case there is no preferences file }	ScreenArea := qd.screenBits.Bounds;  { get the maximum size of screen in use by this computer}								{ set maximum size available for DTSA windows (global variable) }	MaxWindowRect := ScreenArea;	MaxWindowRect.left := 0;	MaxWindowRect.top := 20;	{SetRect(MaxWindowRect,0,20,ScreenArea.right,ScreenArea.bottom); }		                                            	 	if F1Down then 	SetRect(MaxWindowRect,0,20,640,480);  { Start up for 13" screeen, 640X480}	if F2Down then 	SetRect(MaxWindowRect,0,20,640,400);  { Start up for NoteBook Computer}    demo_DTSA := {TRUE} False;	{if F15Down then demo_DTSA := FALSE;} {In regular DTSA you can make a demo spectrum	by editing the SPECTRUM header with the option key down}	Private := false; 	ErrorSound(NIL); { to prevent hangs when clicks outside dialogs cause the dialogs sounds				       to conflict fataly with the cute sounds }	    		 	      Init_Header_Information;    {Init_ID_Window;}    Init_Text_Window;    {Init_ROI_Window;}    Init_Calibrate;                                   { modeless dialog }    {Init_Strip_Peak;}	Init_My_Windows;    Init_SiLi_Window;		Init_BackPlane; 		     Open_Text_Window;    Open_ROI_Window;	    Open_Strip_Peak;   { Open_Calibrate;}    Open_ID_Window;	    Open_BackPlane;	    Open_Sili_Window; 		SiLi_Window_Active      := TRUE;    SetControlValue(AutoScale_CtrlHandle, 1);  { cannot be in "Initialize" Unit- The SiLi											 window must be open or Oh Ho Ho off to the											 debugger you go }		Simplex_Results_Active  := False;	ROI_Window_Active       := False;	StripPeak_Window_Active := False;	Calibrate_Window_Active := False;	ID_Window_Active        := False;	SelectWindow_Occurred   := False;	     MCA_file_boolean := false;	save_work_open:=false; 	               Physics_Initialize;	error := GetVol(Default_Volume_Name, Default_Volume_Ref_Num);	error := GetVol(Binary_Volume_Name, Binary_Volume_Ref_Num); 		    Protoinits;    Initialize_MAIN;	{defines the main window...the window for text stuff}  	    Update_ROI_Window(RoiWindow);	Update_ID_Window(Main_ID_Window);	ignoreError := SysEnvirons (sysEnvironsVersion, environs1);	if environs1.machineType < 0 then begin		hasWNE := false;		putmessage('Using a Finder earlier than 6.0 is not advisable, the program',		           'has not been tested under these conditions, we advise you to update',				   'your system files','');	end 	else 	begin{SDD	hasWNE := TrapAvailable(_WaitNextEvent, ToolTrap);}{SDD	hasWNE := TrapAvailable(_WaitNextEvent);}						{only for MPW 3.3}	end; 		  BackColor(WhiteColor);	  ForeColor(BlackColor);					  inBackground := false;	      Start_Up := False;      Spectrum_Full[10] := True;      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]); 	  	   SiLi_Response_Calculated := false;	   Pref_Name:= 'Preferences.MCA';	   Pref_VolNum := 0;	   GetPreferences;{in Tools.p; calls ReadPreferences (in GlobalFunctions).	   				   If there is no pref file, nothing special is done.}    SelectWindow(BackPlane);    getmouse(Mouselocation);	LocalToGlobal(Mouselocation);	    dummy_Boolean := False;    ipCount := -1;  	CharCounter := 0;  	(*GetTheAppFiles;*){beepbeep;}    Update_SiLi_Thumbs; {get an initial value for SiLi_Energy_Value for energy scrollBar}	Activate := FALSE;  { serial port server }{beepbeep;}	IF (Det_Effic_P^[300] = 0) THEN SiLi_Response_Calculated := false	ELSE  SiLi_Response_Calculated := true;	(*IF (SiLi_Response_Calculated = False)  	  THEN Detector_efficiency(theGenRec,SiLi_Response_Calculated);	BlockMove(@Det_Effic_P^, @Gen_ResponseFnc^, Sizeof(Gen_ResponseFnc^));	BlockMove(@Det_Effic_P^, @Bkg_ResponseFnc^, Sizeof(Bkg_ResponseFnc^));*)	{SDD}OpenAcquirePlugIns;{RLM}OpenFilePlugIns; {   numtostring(sizeof(References_Rec),str);	putmessage('sizeof(References_Rec) is',str,'','');  }	    Show_Disclaimer;	{In Tools}   (* putmessage('This is a Demo of DTSA Ver. 2.0 designed to give you',  			'a flavor of Ver. 2.0 which will be issued soon.',			'Some functions are fully operational while others do nothing.',			'Most of what you see will be operational in Ver. 2.0.');	*)   { еееееее } REPEAT{ ееееееееееееееееееее Start of main event loop еееееееееееееееееееееееееееееее}       seed_x := {Num2Integer} (TickCount - Ticks);       {first seed for RND}      IF (theInput <> NIL)        THEN                                          {See if a TE is active}          TEIdle(theInput);                           {Blink the cursor if everything is ok }			ChangeCursor(ArrowC);		    getmouse(Mouselocation);			LocalToGlobal(Mouselocation);		    GetXYMouse(myEvent);               { This is used to auto Select the windows by                                                 mouse position, ROI generation etc }	CASE Blink_Timer of	    1{0, 30, 50}: BEGIN { check the serial port 3 times a second }  			  (*if SERIAL_Active then			    check_serial_port;*)	{SerGetBuf is an Mac proc}		    END;				20,40,59:		BEGIN	 		Aquisition_stuff;		 		END; 			END;	{ CASE Blink_Timer of...}		  if ((Blink_Timer = 1) or (Blink_Timer = 30)) and (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.Acquiring) then 		begin		  Refresh_ROIs;		  {Update_ROI_Window(ROIWindow);}		end; 	 			       IF GetMainEvent         THEN BEGIN          if myEvent.what =  osEvt {app4Evt} then DoApp4Event;              		   code := FindWindow(myEvent.where, whichWindow);				  {defines whichWindow and sets code = part of window ie menu bar, etc or				   if in system window}           IF code = inSysWindow THEN SystemClick(myEvent , whichWindow); {should be called if code = inSysWindow}					   IF (FrontWindow = MAINPtr) and (code <> inGoAway) then		   BEGIN		   	HandleMainEvent(myEvent, theInput);		   END;		   BEGIN            Is_A_Dialog := IsDialogEvent(myEvent);    {See if a modeless dialog event}            IF Is_A_Dialog THEN                                    			  BEGIN                                 				Do_Calibrate(myEvent, whichWindow);	{the only modeless dialog} 			  END                                   			 ELSE                                    			 BEGIN                                              CASE myEvent.what OF                {Decide type of event}				  				  nullEvent:				   Begin				    if IsAppWindow(FrontWindow) then TEIdle(theInput);				   end; 				  MouseDown:                         					BEGIN                       mousedownevent;				    END;                            {End of MouseDown}                    Keydown, AutoKey:                 {Handle key inputs}                      BEGIN                           {Get the key and handle it}						Keyevent; 					  END;                            {End for KeyDown,AutoKey}	                    UpDateEvt:BEGIN 					    UDateEvent;					{Update event for a еwindowе }                      END;                            {End of UpDateEvt}					                      DiskEvt:                          {Disk inserted event}                      BEGIN                           {Handle a disk event}                      END;                            {End of DiskEvt}                    ActivateEvt:                      {Window activated event}                      BEGIN                           {activation}                        whichWindow := WindowPtr(myEvent.message); {Get the window to be activated}                        IF Odd(myEvent.modifiers)                          THEN Begin                  {Make sure it is Activate and not DeActivate}                            SelectWindow(whichWindow); {Activate the window by selecting it}                            Mouse_Active_Window;							InitCursor;						  end;                      END;                            {End of ActivateEvt}					  					  osEvt:		{ OSEvent}					   CASE BSR(myEvent.message, 24) of 					     MouseMovedMessage : Begin						  window := FrontWindow;						   IF BAnd(myEvent.message, resumeMask) <>0 then						     Begin							  inBackground := False;							  DoActivate ( Window );							  InitCursor;							 End							 ELSE							 Begin							  InBackground := True;							  DoDeactivate(window);							 end;						 end;					   end;                    OTHERWISE                                               BEGIN                       { see what other events are coming in, there are many }                      END;                            {End of otherwise}                  END;                                {End of case}                END;                                  {End for not a modeless dialog event}              END;{ IF (FrontWindow = MAINPtr) then HandleSandiaEvent(myEvent, theInput).... }      END;                                         {end of GetNextEvent}      Blink_Timer := Blink_Timer + 1;      IF Blink_Timer > 61        THEN Blink_Timer := 1;      seed_z := {Num2Integer} (TickCount - Ticks);                    { third seed for RND }      qd.RandSeed := seed_z;	      UNTIL doneFlag;                                   {End of the event loop}	{SDD}	doneFlag:=CallAcquirePlugIns(acquireClose,-1);		{ Send Close to all plugins}     (* MyClosePort; *)                                    	{ Deactivate the serial port, if used }     IF ChangePixDepth then     	err := SetDepth(MainDevice, Pix_depth, 1, 1);	{Reset the monitor}     WriteDeskScrap;  	IF thePrRec <> NIL THEN		H_UnLock_Dispose(Handle(thePrRec),'thePrRec in MCA');  END.                                                {End of MCA}