{[j=30/55,:+,u+,r+,o=160,k+,n+,#+,v+,q+,b+,d-]}{[f-]}{*********************************} UNIT Physics_Windows;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Controls, Memory, Retrace, SegLoad, Dialogs,   Packages, Windows, Events, TextUtils, Printing, StandardFile, fenv, fp, Spectrum_Structures, Declarations, INITIALIZE,  Global_Functions, Utilities, Physics, xray; PROCEDURE Set_Response_Bool(var theHdl:SiLi_RecHdl; var theboolean:boolean);PROCEDURE Detector_Parameters;PROCEDURE D_Expt_Hdr;PROCEDURE Spectrum_Header_Dialog;PROCEDURE D_Generate_Input;PROCEDURE D_Output_Opts;PROCEDURE D_Thin_X_Sects;PROCEDURE D_Bulk_X_Sects;PROCEDURE Clear_The_Headers(Clear_expt,Clear_spect:boolean);PROCEDURE D_RefExpt_Hdr;PROCEDURE D_Ref_Hdr;PROCEDURE WtFrac_to_Oxide(Val_Cat : longint; 	                          nn, Z_Val : integer;				         VAR Symbol : Str_5; 						 	 WP_Cat : real {double_t};						 VAR WP_Oxide : real {double_t});PROCEDURE Oxide_to_WtFrac(VAR Symbol : Str_5;								nn : integer;								VAR Z_Val : integer;								VAR Val_Cat : longint;								VAR WP_Cat,WP_Oxy : real {double_t};								WP_Oxide : real {double_t});Procedure Open_Database;Procedure Create_Database;Procedure Add_to_Database;PROCEDURE Remove_from_Database(index_r : longint);FUNCTION GFilter(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: Integer): boolean;  {******************************} IMPLEMENTATION {**********************************}{[f+]}{$S Physics_Windows}  CONST    I_Accept                      = 1;    I_TextBox                     = 25;    EBox_Wk                       = 14;    EBox_Rslt                     = 15;    EBox_1                        = 16;    EBox_2                        = 17;    EBox_3                        = 18;    EBox_4                        = 19;    EBox_5                        = 20;    EBox_6                        = 21;    EBox_7                        = 22;    EBox_8                        = 23;    I_TextBox2                    = 24;    Edit_Text_Item                = 61;  VAR    Option_Picker                 : DialogPtr;   { cList                         : ListHandle;    Rect_I_List1                  : Rect;}    Spec_chooser_List             : ListHandle;    Spec_chooser_rect             : Rect;    ExitDialog                    : boolean;    Response_InTo_Results         : boolean;    G_Input                       : DialogPtr;    GetSelection                  : DialogPtr;    thePtr                        : SiLi_RecPtr;    theRange_keeper               : integer;    Do_a_Calc, Accept_All         : boolean;	  PROCEDURE Set_Response_Bool {(VAR theHdl:SiLi_RecHdl; theboolean:boolean)} ;{ This compares theGenRec or theBGRec to theValues. It is called in D_Si_Li_Parameters for   background subtraction; called if accept in the main dialog for generate and expt header.}	VAR		iidx			: integer;		    BEGIN      WITH theHdl^^ DO        BEGIN          IF (theValues.Detector.Spec <> Detector.Spec) OR		  	 (theValues.Detector.ID <> Detector.ID) OR			 (theValues.BN_Thickness <> BN_Thickness) OR			 (theValues.SiN_Thickness <> SiN_Thickness) OR			 (theValues.Mylar <> Mylar) OR			 (theValues.Moxtek <> Moxtek) OR			 (theValues.Paralene <> Paralene) OR			 (theValues.Diamond <> Diamond) OR			 (theValues.Quantum <> Quantum) OR			 (theValues.Si_Resolution <> Si_Resolution) OR			 (theValues.WDS_Resolution<> WDS_Resolution) OR			 (theValues.Detector_Thickness <> Detector_Thickness) OR			 (theValues.Si_Thickness <> Si_Thickness) OR (theValues.Au_Thickness <> Au_Thickness) OR			 (theValues.Be_Thickness <> Be_Thickness) OR			 (theValues.Ice_Thickness <> Ice_Thickness) OR			 (theValues.C_Thickness <> C_Thickness) OR			 (theValues.Al_Thickness <> Al_Thickness) OR			 (theValues. Detector_tilt <> Detector_tilt) OR			 (theValues.dE <> dE) OR			 (theValues.number_of_channels > number_of_channels) THEN            theboolean := FALSE          ELSE theboolean := true;          iidx := rinttol(1740.0/theValues.dE);          if Det_Effic_P^[iidx] <= 0.0 then theboolean := FALSE;        END; { WITH theHdl^^...} (* if theHdl = theGenRec then   if SiLi_Response_Calculated = false then  putmessage('for theGenRec Si_liResponse is false','remove this message from Physics_windows','','')   else  putmessage('for theGenRec Si_liResponse is true','remove this message from Physics_windows','','') else if theHdl = theBgRec then   if theboolean = false then  putmessage('for theBgRec SiLi_Buffer_Calculated is false','remove this message from Physics_windows','','')   else  putmessage('for theBgRec SiLi_Buffer_Calculated is true','remove this message from Physics_windows','','');*)    END; { PROCEDURE Set_Response_Bool}  PROCEDURE D_Particle_Geometry;        CONST      I_Accept                      = 1;      I_Cancel                      = 2;      I_Help                        = 3;      I_Thin_Film__Thick_poli       = 4;      I_Rectangular_Prism_Par       = 5;      I_Tetragonal_Prism_Part       = 6;      I_Triangular_Prism_Part       = 7;      I_Square_Pyramid_Partic       = 8;      I_Side_Scattered_Correc       = 9;      I_Checkboxx10                 = 10;      I_Checkboxx11                 = 11;      I_Checkboxx12                 = 12;      I_Checkboxx13                 = 13;      I_Checkboxx14                 = 14;      I_Checkboxx15                 = 15;      I_Checkboxx16                 = 16;      I_Checkboxx17                 = 17;      I_Checkboxx18                 = 18;      I_Checkboxx19                 = 19;      I_Checkboxx20                 = 20;      I_Checkboxx21                 = 21;      I_x                           = 22;      I_xDensity                    = 26;      I_x31                         = 27;      I_x33                         = 28;      I_x35                         = 29;      I_x37                         = 30;      I_x39                         = 31;      I_x41                         = 32;      I_x43                         = 33;      I_x45                         = 34;      I_x47                         = 35;      I_x49                         = 36;      I_x51                         = 37;      I_x53                         = 38;      I_x55                         = 39;      I_xThickness_Diam             = 41;    VAR      ExitDialog                    : boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      {This is an update routine for non-controls in the dialog}      {This is executed after the dialog is uncovered by an alert}        PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN      GetSelection := GetNewDialog(7050, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);  (*             Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density             Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness   *)      {Setup initial conditions}      GetDialogItem(GetSelection, I_xDensity, DType, DItem, tempRect);      SetDialogItemText(DItem, 'gmpercc');      GetDialogItem(GetSelection, I_x31, DType, DItem, tempRect);      SetDialogItemText(DItem, 'numInt');      GetDialogItem(GetSelection, I_x33, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x35, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x37, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x39, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x41, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x43, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x47, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x51, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x53, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_x55, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      GetDialogItem(GetSelection, I_xThickness_Diam, DType, DItem, tempRect);      SetDialogItemText(DItem, 'Edit Text');      Refresh_Dialog;      ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        {Handle it real time}        IF (itemHit = I_Accept) THEN          BEGIN            {?? Code to handle this button goes here}            ExitDialog := true;          END;        IF (itemHit = I_Cancel) THEN          BEGIN            {?? Code to handle this button goes here}          END;        IF (itemHit = I_Help) THEN          BEGIN            {?? Code to handle this button goes here}          END;        IF (itemHit = I_Thin_Film__Thick_poli) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Rectangular_Prism_Par) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Tetragonal_Prism_Part) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Triangular_Prism_Part) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Square_Pyramid_Partic) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Side_Scattered_Correc) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx10) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx11) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx12) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx13) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx14) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx15) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx16) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx17) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx18) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx19) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx20) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;        IF (itemHit = I_Checkboxx21) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN              END            ELSE              BEGIN              END;          END;      UNTIL ExitDialog;      {Get results after dialog}      GetDialogItem(GetSelection, I_Thin_Film__Thick_poli, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Thin Film, Thick polished specimen HERE}      GetDialogItem(GetSelection, I_Rectangular_Prism_Par, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Rectangular Prism Particle HERE}      GetDialogItem(GetSelection, I_Tetragonal_Prism_Part, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Tetragonal Prism Particle HERE}      GetDialogItem(GetSelection, I_Triangular_Prism_Part, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Triangular Prism Particle HERE}      GetDialogItem(GetSelection, I_Square_Pyramid_Partic, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Square Pyramid Particle HERE}      GetDialogItem(GetSelection, I_Side_Scattered_Correc, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Side Scattered Corrected Particle HERE}      GetDialogItem(GetSelection, I_Checkboxx10, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx11, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx12, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx13, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx14, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx15, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx16, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx17, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx18, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx19, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx20, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_Checkboxx21, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));      {??? HANDLE THE CHECKBOX RESULT FOR  Checkbox HERE}      GetDialogItem(GetSelection, I_xDensity, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  gmpercc  HERE}      GetDialogItem(GetSelection, I_x31, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  numInt  HERE}      GetDialogItem(GetSelection, I_x33, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x35, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x37, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x39, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x41, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x43, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x45, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x47, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x49, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x51, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x53, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_x55, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      GetDialogItem(GetSelection, I_xThickness_Diam, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      {??? HANDLE THE STRING ENTERED FOR  Edit Text  HERE}      DisposeDialog(GetSelection);    END;  {$S Physics_Windows1}  PROCEDURE D_Display_Parameters;    CONST      Display_Accept                = 1;      Display_Cancel                = 2;      Display_eV_5                  = 3;      Display_eV_10                 = 4;      Display_eV_20                 = 5;      Display_eV_40                 = 6;      Display_eV_80                 = 7;      Display_eV_xx                 = 8;      Display_256                   = 9;      Display_512                   = 10;      Display_1024                  = 11;      Display_2048                  = 12;      Display_4096                  = 13;      Display_8192                  = 14;      Display_EDIT_Box              = 15;    VAR      Display_GetSelection          : DialogPtr;      {Name of dialog}      Display_Rect                  : Rect;           {Temporary tectangle}      Display_DType                 : integer;      Display_Index                 : integer;      Display_DItem                 : Handle;      Display_CItem                 : controlhandle;      Display_CTempItem             : controlhandle;      Display_itemHit               : integer;      Display_temp                  : integer;        {Get selection, Display_temp holding}      sTemp                         : str255;      Display_ExitDialog            : boolean;    PROCEDURE Refresh_Dialog;            VAR        Index                         : integer;        str                           : str255;      BEGIN        SetPort(Display_GetSelection);        OutlineButton(Display_GetSelection, 1, 16); { outline the accept button }		        GetDialogItem(Display_GetSelection, Display_EDIT_Box, Display_DType, Display_DItem, tempRect);        RealToString(theValues.dE, 5, 2, str);        SetDialogItemText(Display_DItem, str);        GetDialogItem(Display_GetSelection, Display_eV_xx, Display_DType, Display_DItem, Display_Rect);        Display_CItem := controlhandle(Display_DItem);        SetControlValue(Display_CItem, 1);        FOR Index := Display_eV_5 TO Display_eV_80 DO {:= 3 to 7 }          BEGIN            GetDialogItem(Display_GetSelection, Index, Display_DType, Display_DItem, Display_Rect);            Display_CTempItem := controlhandle(Display_DItem);            IF (theValues.dE = 5.0 * (2 ** (Index - 3))) THEN              BEGIN                SetControlValue(Display_CTempItem, 1);                SetControlValue(Display_CItem, 0); { turn off Display_eV_xx }              END            ELSE SetControlValue(Display_CTempItem, 0);          END; { FOR index ...}        FOR Index := Display_256 TO Display_8192 DO {9 to14}          BEGIN            GetDialogItem(Display_GetSelection, Index, Display_DType, Display_DItem, Display_Rect);            Display_CItem := controlhandle(Display_DItem);            IF (theValues.number_of_channels = 2 ** (Index - 9) * 256) THEN SetControlValue(Display_CItem, 1)            ELSE SetControlValue(Display_CItem, 0);          END; { FOR index ...}      END; {PROCEDURE Refresh_Dialog;}    BEGIN {PROCEDURE D_Display_Parameters...}      Display_GetSelection := GetNewDialog(417, NIL, Pointer( - 1));      ShowWindow(Display_GetSelection);      SelectWindow(Display_GetSelection);      SetPort(Display_GetSelection);      {еееееееее Setup initial conditions еееееееееее}      Refresh_Dialog; { puts up the dialog with theValue values }      Display_ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), Display_itemHit);        GetDialogItem(Display_GetSelection, Display_itemHit, Display_DType, Display_DItem, Display_Rect); {Get item information}        Display_CItem := controlhandle(Display_DItem);        IF (Display_itemHit <= Display_eV_xx) AND (Display_itemHit >= Display_eV_5) THEN          BEGIN            FOR Display_Index := Display_eV_5 TO Display_eV_xx DO              BEGIN { all to off }                GetDialogItem(Display_GetSelection, Display_Index, Display_DType, Display_DItem, Display_Rect);                Display_CTempItem := controlhandle(Display_DItem);                SetControlValue(Display_CTempItem, 0);              END; { FOR Display_Index... }            SetControlValue(Display_CItem, 1); { this is the itemhit }            IF (Display_itemHit < Display_eV_xx) THEN              BEGIN                GetDialogItem(Display_GetSelection, Display_EDIT_Box, Display_DType, Display_DItem, tempRect);                SetDialogItemText(Display_DItem, ' ');              END;          END;        IF (Display_itemHit = Display_Cancel) THEN          BEGIN            DisposeDialog(Display_GetSelection);            exit(D_Display_Parameters);          END;        IF (Display_itemHit >= Display_256) AND (Display_itemHit <= Display_8192) THEN          BEGIN            IF (called_for_generate OR (MCA_Spectrum_Active = FALSE)) THEN              BEGIN                FOR Display_Index := Display_256 TO Display_8192 DO                  BEGIN                    GetDialogItem(Display_GetSelection, Display_Index, Display_DType, Display_DItem, Display_Rect);                    Display_CTempItem := controlhandle(Display_DItem);                    SetControlValue(Display_CTempItem, 0);                  END;                SetControlValue(Display_CItem, 1); { for the itemhit }              END            ELSE              putmessage('Sorry, the number of channels cannot be changed',                         'for an existing WORK spectrum, which already has a defined ', 'number of channels.', '');          END;        IF (Display_itemHit = Display_Accept) THEN          BEGIN            Display_ExitDialog := true;            IF called_for_generate THEN              BEGIN                Display_Index := Display_256 - 1;                REPEAT                  Display_Index := Display_Index + 1;                  GetDialogItem(Display_GetSelection, Display_Index, Display_DType, Display_DItem, Display_Rect);                  Display_CItem := controlhandle(Display_DItem); {Change dialog handle to control handle}                  Display_temp := GetControlValue(Display_CItem);                UNTIL (Display_temp = 1) OR (Display_Index = Display_8192);                IF (Display_temp = 1) THEN                  BEGIN                    theValues.number_of_channels := 2 ** (Display_Index - 9) * 256;                    (*Spectrum_Size := theValues.number_of_channels; *)                    theRange_keeper := Display_Index - 4; {not leaving the display as it was}                  END { if (Display_temp = 1) then begin...}                ELSE                  BEGIN                    Display_ExitDialog := FALSE;                    putmessage('Something is wrong!', 'I found all Number of Channels buttons off!', '', '');                  END;              END; { if called_....}            Display_Index := Display_eV_5 - 1;            REPEAT              Display_Index := Display_Index + 1;              GetDialogItem(Display_GetSelection, Display_Index, Display_DType, Display_DItem, Display_Rect);              Display_CItem := controlhandle(Display_DItem);              Display_temp := GetControlValue(Display_CItem);            UNTIL (Display_temp = 1) OR (Display_Index = Display_eV_xx);            IF (Display_temp = 1) THEN              BEGIN                IF (Display_Index <> Display_eV_xx) THEN theValues.dE := 5.0 * (2 ** (Display_Index - 3))                ELSE                  BEGIN                    GetDialogItem(Display_GetSelection, Display_EDIT_Box, Display_DType, Display_DItem, tempRect);                    GetDialogItemText(Display_DItem, sTemp);                    theValues.dE := MyStr2Num(sTemp);                  END;              END { IF (Display_temp = 1)...}            ELSE              BEGIN                Display_ExitDialog := FALSE;                putmessage('Something is wrong!', 'I found all eV/Ch buttons off!', '', '');              END;          END; { IF (Display_itemHit = Display_Accept)...}      UNTIL Display_ExitDialog;      DisposeDialog(Display_GetSelection);    END; {End of procedure D_Display_Parameters}  {===========================================================}    PROCEDURE Open_Database;    VAR      Index                         : integer;      Startx                        : Point;      FileType                      : ARRAY [0..1] of OSType;	  sfPtr                         : ConstSFTypeListPtr;      reply                         : SFReply;      errCode                       : integer;      bytecount                     : longint;      str2                          : str255;      D_refnum                      : integer;    BEGIN { Open_Database }      IF NOT (DataBase_Open) OR (OpenNew_Database) THEN        BEGIN          myprompt := 'Open Composition File';          WITH Startx DO            BEGIN              v := 90;              h := 80;            END;          FileType[0] := 'DTSA';          FileType[1] := 'MCAd';		  sfPtr := @FileType;          SFGetFile(Startx, myprompt, NIL, 2, sfPtr, NIL, reply);          {Database_dirID := reply.VRefNum ;}          IF (reply.good) THEN            BEGIN              Database_Name := reply.FName;              Database_dirID := reply.VRefNum;              DataBase_Open := true;              OpenNew_Database := FALSE;			  if Comp_handles then              FOR Index := 1 TO Number_of_Entries DO                H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');			  Comp_handles := false;            END          ELSE            BEGIN              OpenNew_Database := FALSE;              ExitDialog := true;              exit(Open_Database);            END;        END; {if NOT (Database_Open) OR (OpenNew_Database) }      DrawAxesFull;      update_full;      UpDate_SiLi_Window(SiLiWindow);      IF (DataBase_Open = true) THEN        BEGIN          errCode := FSOpen_err(Database_Name, Database_dirID, D_refnum, '');          IF errCode <> NoErr THEN            BEGIN              putmessage('Error on Open', '', '', '');              IF errCode = fnOpnErr THEN putmessage(' File not open', '', '', '');              IF errCode = rfNumErr THEN putmessage(' Bad reference number', '', '', '');              IF errCode = extFSErr THEN putmessage(' External File System', '', '', '');              DataBase_Open := FALSE;              ExitDialog := true;              exit(Open_Database);            END;        END      ELSE        BEGIN          ExitDialog := true;          exit(Open_Database);        END;      bytecount := 4;      errCode := FSRead_err(D_refnum, bytecount, @Number_of_Entries, '');      IF Number_of_Entries > 50 THEN Number_of_Entries := 50;      Mouse_Active_Window;	        (*IF FreeMem < SizeOf(Comp_Rec) THEN        BEGIN          putmessage('Not enough memory available to run program at Database', '', '', '');          ExitToShell;        END;*)		      str2 := '  ';	  if not Comp_handles then      FOR Index := 1 TO Number_of_Entries DO        BEGIN          {Test_a_Handle(Handle(Comp_Data[Index]), 'Comp_Data[index]');}          Comp_Data[Index] := Comp_RecHdl(NewHandle(SizeOf(Comp_Rec)));          MoveHHi(Handle(Comp_Data[Index]));          HLock(Handle(Comp_Data[Index]));          bytecount := SizeOf(Comp_Rec);          errCode := FSRead_err(D_refnum, bytecount, @Comp_Data[Index]^^, '');        END;	  Comp_handles := true;      errCode := FSClose(D_refnum);      errCode := FlushVol(NIL, Database_dirID);    END; { Open_Database }  {===========================================================}  PROCEDURE Create_Database;    VAR      errCode                       : integer;      Startx                        : Point;      reply                         : SFReply;      bytecount                     : longint;      D_refnum                      : integer;    BEGIN      Database_Name := 'Comp_Database';      myprompt := 'Create Composition Database';      WITH Startx DO        BEGIN          v := 90;          h := 80;        END;      SFPutFile(Startx, myprompt, Database_Name, NIL, reply);      DrawAxesFull;      update_full;      UpDate_SiLi_Window(SiLiWindow);      Database_Name := reply.FName;      Database_dirID := reply.VRefNum;      IF (reply.good) THEN        BEGIN          errCode := Create(Database_Name, Database_dirID, 'DTSA', 'MCAd');          errCode := FSOpen_err(Database_Name, Database_dirID, D_refnum, '');          IF errCode = NoErr THEN            BEGIN              DataBase_Open := true;              errCode := setfpos_err(D_refnum, FSFromSTART, 0, '');              Number_of_Entries := 0;              bytecount := 4;              errCode := FSWrite_err(D_refnum, bytecount, @Number_of_Entries, '');              errCode := FSClose(D_refnum);              errCode := FlushVol(NIL, Database_dirID);            END          ELSE putmessage('The file did not open', '', '', '');        END;    END; { Create_Database }  {===========================================================}  PROCEDURE Add_to_Database;    VAR      index1                        : longint;      errCode                       : integer;      bytecount                     : longint;      D_refnum                      : integer;    BEGIN      IF (DataBase_Open) AND (Comp_handles) THEN        BEGIN          errCode := FSOpen(Database_Name, Database_dirID, D_refnum);          errCode := SetFPos(D_refnum, FSFromSTART, 0);          bytecount := 4;          errCode := FSRead(D_refnum, bytecount, @index1); {last spec number}          index1 := index1 + 1; {new last spec number}          errCode := SetFPos(D_refnum, FSFromSTART, 0);          errCode := FSWrite(D_refnum, bytecount, @index1);          errCode := SetFPos(D_refnum, fsfromLEOF, 0);		  bytecount := SizeOf(Comp_Rec);		  errCode := FSWrite(D_refnum, bytecount, @Comp_Data[index1]^^);          errCode := FSClose(D_refnum);          errCode := FlushVol(NIL, Database_dirID);        END      ELSE        BEGIN          putmessage('You do not have a Composition Database File open.', '', '', '');        END;    END;  {===========================================================}    PROCEDURE Remove_from_Database {(index_r : longint)};			{index_r is the number of the item to be removed}    VAR	  index1, index					: longint;      errCode                       : integer;      bytecount, pos_count          : longint;      D_refnum                      : integer;    BEGIN      IF (DataBase_Open) AND (Comp_handles) THEN        BEGIN          errCode := FSOpen(Database_Name, Database_dirID, D_refnum);          errCode := SetFPos(D_refnum, FSFromSTART, 0);          bytecount := 4;          errCode := FSRead(D_refnum, bytecount, @index1); {last spec number}		  index1 := index1 - 1; {new last spec number}		  		 (* bytecount := SizeOf(Comp_Rec);		  pos_count := bytecount * (index_r - 1) + 4;		  errCode := SetFPos(D_refnum, FSFromSTART, pos_count);*)		  		  		  if (index_r <= index1) AND (index_r > 0) then		  for index := index_r to index1 do		    begin			  Comp_Data[index]^^ := Comp_Data[index + 1]^^;			end;		  Comp_Data[index1 + 1]^^.C_Name := '';		  errCode := SetFPos(D_refnum, FSFromSTART, 0);		  bytecount := 4;          errCode := FSWrite(D_refnum, bytecount, @index1);		  bytecount := SizeOf(Comp_Rec);		  for index := 1 to index1 do		    errCode := FSWrite(D_refnum, bytecount, @Comp_Data[index]^^);		  errCode := GetFPos(D_refnum, pos_count);		  errCode := SetEOF(D_refnum, pos_count);          errCode := FSClose(D_refnum);          errCode := FlushVol(NIL, Database_dirID);        END      ELSE        BEGIN          putmessage('You do not have a Composition Database File open.', '', '', '');        END;    END;  {===========================================================}  PROCEDURE Calc_the_Angles;        VAR      a, B, c, X, y, az, E, Z       : real {double_t};    BEGIN  { Geom. has the values from the strings in the dialogs; theGenRec^^ gets the values for    generating or, obviously the Plt_Spec[10]^^...when you ACCEPT in the dialogs.}      az := geom.Azimuthal_angle / (360 / Pi2);      X := geom.X_Tilt_angle / (360 / Pi2);      y := geom.Y_Tilt_angle / (360 / Pi2);      E := geom.elevation_angle / (360 / Pi2);      a := Cos(X) * Cos(y) * Cos(az) * Cos(E);      B := Cos(X) * Cos(y) * Sin(az) * Cos(E);      c := Sin(y) * Cos(az) * Cos(E) + Sin(X) * Cos(y) * Cos(E) * Sin(az);      Z := (Sin(y) * Cos(az) * Cos(E) + Sin(X) * Cos(y) * Cos(E) * Sin(az)) / sqrt(a * a + B * B + c * c);      { Geom.Beam_Entry_Angle is in the plane of the beam and detector }      geom.Beam_Entry_Angle := 2 * ArcTan(sqrt((1 - Z) / (1 + Z))) * (360 / Pi2);      geom.Angle_of_TakeOff := geom.elevation_angle + 90.0 - geom.Beam_Entry_Angle;    END; { Calc_the_Angles }  PROCEDURE Clear_The_Headers {(Clear_expt,Clear_spect:boolean)} ;        VAR      nn                            : integer;    BEGIN      { Initialize all of the "work" spectrum fields  }      WITH Plt_spec[10]^^ DO        BEGIN          IF Clear_expt THEN            WITH Expt_Info DO              BEGIN                Specimen_ID := ''; { String[50] }                Specimen_Comment_Field := '';                MCA_Filename := ' ';              {  FirstSpec := 1;                LastSpect := 1;} {these shouldn't be changed}                Analyst := ''; { String[50] }                Detector.Spec := EDS; { SiLi }                Detector.ID := 1; { SiLi }                Azimuth := -90.0; { Real, degrees }                Elevation := 0.0; { Real, degrees }                Detector_Area := 0.0; { Real, cm sq }                Detector_Thickness := 0.0; { Real, mm }                C_Thickness := 0.0; { Real, um }                Al_Thickness := 0.0;                Ice_Thickness := 0.0 {MyStr2Num('12.3')} ; { Real, um }                Au_Thickness := 0.0 {MyStr2Num('12.3')} ; { Real, um }                Be_Thickness := 0.0 {MyStr2Num('12.3')} ; { Real, um }                Si_Thickness := 0.123; { Real, um }                Si_Resolution := 123.4;                WDS_Resolution := 15.0;                BN_Thickness := 0.0;                SiN_Thickness := 0.0;                Mylar := 0.0;                Moxtek := 0.0;                Paralene := 0.0;                Diamond := 0.0;                Quantum := 0.0;                Detector_tilt := 90;                dE := 10.0; { Real }                Energy_Slope := 1.0;                Energy_Intercept := 0.0;                number_of_channels := Spectrum_Size;                kV := 12.3456; { Real }              END; { with Expt_Info }          IF Clear_spect THEN            BEGIN              WITH SpectrumStuff.Spectrum_Info DO                BEGIN                  BkgSubtracted := FALSE;                  Spectrum_Comment_Field := ''; { Str255 }                  Spectrum_number := 1;                  Spectrum_Class := ''; { String[10] }                  Theoretically_Generated := FALSE; { Boolean }                  This_is_a_Standard := FALSE;                  Take_Off_Angle := 12.34; { Real, degrees }                  Spec_Detector_Distance := 12.34; { Real, mm }                  Specimen_Thickness := 0.00001; { Real, cm }                  Specimen_Density := 0.0; { Real, g/cm sq. }                  Number_of_Elements := 0; { Integer }                  FOR nn := 1 TO 15 DO                    BEGIN                      Element_Info[nn].Atomic_Number := 0 {6};                      Element_Info[nn].Weight_Fraction := 0.0;                      Element_Info[nn].Valence := 0.0;                    END;                END; { with SpectrumStuff.Spectrum_Info }              WITH SpectrumStuff.Acq_Info DO                BEGIN                  Probed_Area := 0.0; { Real, cm sq. }                  X_Position := 0.0; { Real, um }                  Y_Position := 0.0; { Real, um }                  Begin_Faraday := 1.0; { Real, nA }                  End_Faraday := 1.0; { Real, nA }                  (*GetDateTime(SpectrumStuff.Acq_Info.Begin_Time)*); { temp load in current dateTime}                  Real_Time := 1.0; { real secs }                  Live_Time := 1.0; { real secs }                  Slow_Channel_Counts := 0; { Longint }                  Medium_Channel_Counts := 0; { Longint }                  Fast_Channel_Counts := 0; { Longint }                  RequestedLiveTime := 0; { Longint }                  ActualLiveTime := 0; { Longint }                  Acquiring := FALSE; { Boolean }                END; { with SpectrumStuff.Acq_Info }            END; { If clear_spect...}        END;    END; { PROCEDURE Clear_The_Headers...}  PROCEDURE PutSInfo;    VAR      L                             : longint;      info                          : str255;      info2                         : str255;      DType                         : integer;      DItem                         : Handle;    BEGIN      StringToNum(str_info, L); {L is the "number" of the list item, ie, position }      IF L < 1 THEN L := 1;      IF L > 999 THEN L := 999;      info := ' ';      info2 := ' ';      IF (L >= 1) AND (L <= 999) THEN        BEGIN          numtostring(L, info);          info2 := ' ';          {putmessage('The item number in the list is ',info,'','');}          GetDialogItem(GetSelection, Edit_Text_Item, DType, DItem, tempRect);          SetDialogItemText(DItem, info);  (*                                 Boiler plate template   Conc_DB^^.comments := ''; for nn := 1 to 15 do begin  Conc_DB^^.at_no[nn]  := 0 ;  Conc_DB^^.conc[nn]    := 0.0;  Conc_DB^^.Valence[nn] := 0.0; end;  Conc_Database  =   record         refnum                   : Longint;      Name                     : String[50];      spare1                   : Integer;      spare2                   : Integer;      comments                 : str255;      At_No                    : Array[1..15] of integer;      Conc                     : Array[1..15] of real;      Valence                  : Array[1..15] of real;   end;   if  L = xxx  then begin    str1 := ' ';  str2 := ' '; str3 := ' '; info := CONCAT(str1, str2, str3 );    str1 := ' ';    str2 := ' ';    str3 := ' ';    info2 :=  CONCAT(str1, str2, str3 );    end;*)        END;    END; { Procedure PutSInfo }	  FUNCTION GFilter {(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: Integer): boolean};	CONST		I_Done                        = 1;		I_Cancel					  = 2;		kVisualDelay				  = 8;		kReturnKey					  = $0D;		kEnterKey					  = $03;		kEscapeKey					  = $1B; 		kPeriodKey					  = $2E;    VAR      tempRect                      : Rect;	  DType                         : integer;	  DItem                         : Handle;	  CItem			                : controlhandle;      temp                          : Longint;      DataLen                       : Integer;      str_3                         : STRING[3];      gotClicked                    : Cell;      ignore                        : boolean;	  finalTicks					: Longint;	  key							: Char;    BEGIN      GFilter := FALSE;      IF (theEvent.what = MouseDown) THEN {Only do on a mouse click}        BEGIN          DataLen := 3;          Rect_Point := theEvent.where; {Get the point where the mouse was clicked}          GlobalToLocal(Rect_Point);          IF PtInRect(Rect_Point, Rect_I_List1) THEN { we are in the box of cells }            BEGIN              { the ordering of double, single click handling is important }              DoubleClick := LClick(Rect_Point, theEvent.modifiers, cList);              IF DoubleClick THEN { Double click handling }                BEGIN                  str_3 := '   '; { initialization is essential }                  LGetCell(POINTER(ord(@str_3) + 1), DataLen, cList^^.lastClick, cList);                  str_3 := Strip_Trailing_Blanks(str_3);                  StringToNum(str_3, temp);                  itemHit := Integer(temp + 100);                  GFilter := True;                END;              ignore := LClick(Rect_Point, 0, cList); { single click handling }              gotClicked := LLastClick(cList);              str_info := '   ';              LGetCell(POINTER(ord(@str_info) + 1), DataLen, gotClicked, cList);              str_info := Strip_Trailing_Blanks(str_info);              {PutGInfo;}            END; {End of PtInRect}        END	{ IF (theEvent.what = MouseDown) }	  ELSE	    CASE theEvent.what OF			keyDown, Autokey:	{user pressed a key}			BEGIN				key := Char(BAnd(theEvent.message, charCodeMask));				IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN				  BEGIN				    GetDialogItem(theDialog, I_Done, DType, DItem, tempRect);        			CItem := controlhandle(DItem);							{invert the OK button for user feedback}					HiliteControl(CItem, kControlButtonPart);					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(CItem, 0);					GFilter := TRUE;								{event's being handled}					itemHit := I_Done;								{return the default button}				  END;				IF (key = Char(kEscapeKey)) OR											{user pressed Esc key}					(Boolean(BAnd(theEvent.modifiers, cmdKey)) AND					(key = Char(kPeriodKey))) THEN											{user pressed Cmd-pd}				  BEGIN			{handle as if user clicked Cancel}					GetDialogItem(theDialog, I_Cancel, DType, DItem, tempRect);					CItem := controlhandle(DItem);							{invert the Cancel button for user feedback}					HiliteControl(CItem, kControlButtonPart);					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(CItem, 0);					GFilter := TRUE;								{event's being handled}					itemHit := I_Cancel;							{return the Cancel button}				  END;		{of Cancel}				  				END; { keyDown, Autokey }			END;{CASE theEvent.what}		    END;  FUNCTION Parse_Oxide(VAR Symbol: Str_5; VAR Num_Cat, Num_Oxy: longint): integer;    VAR      lmax, Z_Value                 : integer;      Oxy_sym, Cat_sym              : STRING[2];      sTem                          : Str_5;    FUNCTION IsaLetter(chr: char): boolean; {operates on a single character}      { Purpose:    if chr is an upper or lower case letter, returns TRUE,                   otherwise, returns false.}      BEGIN        IF ((ord(chr) > 64) AND (ord(chr) < 91)) OR ((ord(chr) > 96) AND (ord(chr) < 123)) THEN IsaLetter := true        ELSE IsaLetter := FALSE      END; {of IsaLetter}    FUNCTION IsaNumber(chr: char): boolean; {operates on a single character}       {Purpose:    if chr is a number, returns TRUE,                   otherwise, returns false.}      BEGIN        IF (ord(chr) > 47) AND (ord(chr) < 58) THEN IsaNumber := true        ELSE IsaNumber := FALSE      END; {of IsaNumber}    BEGIN {Main Function}      (* first, perform several checks on the input data *)      lmax := length(Symbol);      IF (lmax = 0) THEN        BEGIN          Parse_Oxide := 0;          exit(Parse_Oxide);        END;      IF (lmax = 1) THEN        BEGIN          IF (Symbol[1] = ' ') THEN            BEGIN              Parse_Oxide := 0;              exit(Parse_Oxide);            END;        END;      IF (IsaNumber(Symbol[lmax]) = true) THEN {Last char is a number}        BEGIN          sTem := copy(Symbol, lmax, 1);          StringToNum(sTem, Num_Oxy);          lmax := lmax - 1;          IF (ord(Symbol[lmax]) > 96) AND (ord(Symbol[lmax]) < 123) THEN Symbol[lmax] := char(ord(Symbol[lmax]) - 32);          Oxy_sym := copy(Symbol, lmax, 1);        END      ELSE        IF (IsaLetter(Symbol[lmax]) = true) THEN {last char is a letter}          BEGIN            IF (ord(Symbol[lmax]) > 96) AND (ord(Symbol[lmax]) < 123) THEN Symbol[lmax] := char(ord(Symbol[lmax]) - 32);            Oxy_sym := copy(Symbol, lmax, 1);            Num_Oxy := 1;          END        ELSE exit(Parse_Oxide);      lmax := lmax - 1;      IF (IsaNumber(Symbol[lmax]) = true) THEN {Char is a number}        BEGIN          sTem := copy(Symbol, lmax, 1);          StringToNum(sTem, Num_Cat);          lmax := lmax - 1;        END      ELSE        IF (IsaLetter(Symbol[lmax]) = true) THEN { char is a letter}          Num_Cat := 1        ELSE exit(Parse_Oxide);      IF (lmax = 1) THEN        BEGIN          IF (ord(Symbol[lmax]) > 96) AND (ord(Symbol[lmax]) < 123) THEN Symbol[lmax] := char(ord(Symbol[lmax]) - 32);          Cat_sym := copy(Symbol, 1, 1);        END      ELSE        IF (lmax = 2) THEN          BEGIN            IF (ord(Symbol[2]) > 64) AND (ord(Symbol[2]) < 91) THEN Symbol[2] := char(ord(Symbol[2]) + 32);            IF (ord(Symbol[1]) > 96) AND (ord(Symbol[1]) < 123) THEN Symbol[1] := char(ord(Symbol[1]) - 32);            Cat_sym := copy(Symbol, 1, 2);          END;    {numtostring(Num_Cat,str);    putmessage('Element symbol is ',Cat_sym,' Num_Cat is ',str);}      Z_Value := AtSymbol_To_Znum(Cat_sym);	  if Z_Value = -3 then Cat_sym := '  ';  {numtostring(Z_Value,str);  putmessage('Z_Value = ',str,'','');}      Parse_Oxide := Z_Value;    END; {Main Function}  PROCEDURE Oxide_to_WtFrac {(VAR Symbol : Str_5; nn : integer; VAR Z_Val : integer; VAR Val_Cat : longint; VAR WP_Cat,WP_Oxy :                             double_t; WP_Oxide : double_t)} ;    VAR      Num_Cat, Num_Oxy, Val_Oxy     : longint;      Formula_Wt                    : real {double_t};    BEGIN      Z_Val := Parse_Oxide(Symbol, Num_Cat, Num_Oxy);      IF Z_Val <= 0 THEN        BEGIN          putmessage('Not a valid oxide, please enter something like Fe2O3, or MgO etc.', '', '', '');          exit(Oxide_to_WtFrac);        END;      Val_Oxy := 2;      Val_Cat := (Val_Oxy * Num_Oxy) DIV Num_Cat;      Formula_Wt := Num_Cat * At_Wt^^.Value[Z_Val] + Num_Oxy * 16 {At_Wt_Oxy} ;      WP_Cat := Num_Cat * At_Wt^^.Value[Z_Val] * WP_Oxide / Formula_Wt;      WP_Oxy := Num_Oxy * 16 {At_Wt_Oxy} * WP_Oxide / Formula_Wt;   (*  numtostring(Num_Oxy,str1);  numtostring(Num_Cat,str2);  putmessage('Z, Num_Oxy & Num_Cat ',str,str1,str2);    numtostring(Z_Val,str);  numtostring(Val_Oxy,str1);  numtostring(Val_Cat,str2);  putmessage('Z, Val_Oxy & Val_Cat ',str,str1,str2);  *)    END; {Oxide_to_WtFrac}  PROCEDURE WtFrac_to_Oxide {(Val_Cat : longint; nn, Z_Val : integer; VAR Symbol : Str_5; WP_Cat : double_t; VAR WP_Oxide :                             double_t)} ;    VAR      sTem		                    : Str_5;      Formula_Wt                    : real {double_t};      Num_Cat, Num_Oxy              : longint;      str                           : str255;    BEGIN      { Make the oxide string }      Num_Cat := 2;      Num_Oxy := Val_Cat;      IF (odd(Num_Oxy) = FALSE) THEN        BEGIN          Num_Cat := 1;          Num_Oxy := Val_Cat DIV 2;        END;      str := a^.sym[Z_Val];      sTem := Strip_Trailing_Blanks(str);      IF (Num_Cat > 1) THEN        BEGIN          numtostring(Num_Cat, str);          sTem := CONCAT(sTem, str);        END;      sTem := CONCAT(sTem, 'O');      IF (Num_Oxy > 1) THEN        BEGIN          numtostring(Num_Oxy, str);          sTem := CONCAT(sTem, str);        END;      Symbol := sTem; {This is the oxide}      Formula_Wt := Num_Cat * At_Wt^^.Value[Z_Val] + Num_Oxy * 16 {AtWt_Oxy} ;      WP_Oxide := Formula_Wt * WP_Cat / (Num_Cat * At_Wt^^.Value[Z_Val]);  {realtostring(WP_Oxide, 8, 5, str);  putmessage('WP_Oxide value in routine is ',str,'','');}    END; {WtFrac_to_Oxide}	{$S Physics_Windows2}  PROCEDURE D_Standard_Entry;    CONST      I_Accept                      = 1;      Cancel                        = 2;      I_Z1                          = 3;      I_Value                       = 4;      I_Quantity                    = 33;	  I_Help						= 35;      T_disp_kV                     = 37;             {static text of keV}     { Edit_Text_Item                = 46;  }           {NOT the edit box for std name}      Retreive_Item                 = 47;             {Load a Database}      Name_New_Database             = 48;      Insert_in_Database            = 49;             {Insert item}      Remove_Item                   = 50;             {Remove item}      Standards_Database            = 51;             {not needed}      R_Wt_Fr                       = 53;      R_Ox_Fr                       = 54;      R_Num_Atms                    = 55;      R_mMol_Dry_Wt                 = 56;      R_Atm_Fr                      = 57;      R_Valence                     = 58;      T_Sum                         = 60;      T_Diff_From_1                 = 62;      I_Make_Standard               = 63;      I_Clear                       = 64;      T_Average_Z                   = 68;    VAR      ExitDialog                    : boolean;      tempLong                      : longint;      tempRect                      : Rect;      DType                         : integer;      Index, nn                     : integer;      DItem                         : Handle;      CItem			                : controlhandle;      XDItem                        : Handle;      XDType                        : integer;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      tempReal                      : real {double_t};      Chem_Scale                    : integer;      Sum_Wt_By_A                   : real {double_t};      Sum                           : real {double_t};      Smallest_Wt_By_A              : real {double_t};      Wt_By_A                       : ARRAY [1..15] OF real {double_t};      Formula_Wt                    : real {double_t};      theWeightF                    : ARRAY [1..15] OF real {double_t};      theOxWeightF                  : ARRAY [1..15] OF real {double_t};      theZ                          : ARRAY [1..15] OF integer;      theValence                    : ARRAY [1..15] OF longint;      theOxStr                      : ARRAY [1..15] OF Str_5;      Num_Elements                  : integer;      Average_Z                     : real {double_t};      thestr                        : str255;      cSize                         : Point;          {Pointer to a cell in a list}      dataBounds                    : Rect;      str, str1, str2, str7, strt_str : str255;      s5Temp                        : Str_5;    PROCEDURE Refresh_Dialog;      VAR        rTempRect                     : Rect;      BEGIN        ShowWindow(GetSelection);        SelectWindow(GetSelection);        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Accept, DType, DItem, rTempRect);        PenSize(3, 3);        InsetRect(rTempRect, - 4, - 4);        FrameRoundRect(rTempRect, 16, 16);        PenSize(1, 1);        LUpdate(GetSelection^.visRgn, cList);        rTempRect := Rect_I_List1;        InsetRect(rTempRect, - 1, - 1);        FrameRect(rTempRect);      END;	      PROCEDURE SE_Help;	{Standard_Entry help}      VAR        tempRect                      : Rect;        offset                        : integer;        Left                          : integer;        Top                           : integer;        n                             : integer;        S_Help                        : DialogPtr;        itemHit                       : integer;        DType                         : integer;        DItem                         : Handle;       { CItem                         : controlhandle;}      CONST        G_Accept                      = 1;      BEGIN        S_Help := GetNewDialog(433, NIL, Pointer( - 1));        ShowWindow(S_Help);        SelectWindow(S_Help);        SetPort(S_Help);        OutlineButton(S_Help, 1, 16); { outline the OK button }        SetFont('Monaco', 9, []);        offset := 12;        Left := 5;        Top := 15;        n := 0;        moveto(Left, Top);        str := 'This dialog allows you to enter the elemental composition for the spectrum.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'This is primarily used for entering the composition of a standard. Note that';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'concentrations can be entered in several ways. Entering in one scale and then pushing the';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'radio button of another will convert your entry. The program only stores and calculates';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'in weight fraction. еееBEWAREеее Remember your chemistry, if the sum is not very near (<1%) ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'then conversions between weight and atomic fraction will be incorrect. ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'You may input oxides by entering the formula (AL2O3, etc.). This will also automatically';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'supply the valences necessary for stoichiometric oxide calculations. A database of compositions';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'may be defined. Enter a composition, name it in the name box and insert it in your database file.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'To retrieve a composition: open the file, double click the name and the composition will appear.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'Items that are not wanted may also be deleted from the database. You may have as many database';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'files as you like. Once you open one, it will appear in this window whenever this window is';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'active. (Background Subtract or Generate)';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'If you have an unknown with some elements of known composition, enter values for the known';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'elements here if you want them to stay constant during a quantitative analysis.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'е If you want to save the composition to a DTSA file with the spectrum, edit the spectrum ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'header after closing this window ("OK" button).';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(S_Help, itemHit, DType, DItem, tempRect);          IF (itemHit = G_Accept) THEN            BEGIN              ExitDialog := true;            END;        UNTIL ExitDialog;        ExitDialog := FALSE;        DisposeDialog(S_Help);		  beginupdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);      END; {End of SE_Help procedure}    PROCEDURE Add_LStr(theString: str255; theList: ListHandle);      VAR        theRow                        : integer;      BEGIN        IF (theList <> NIL) THEN          BEGIN            cSize.h := 0;            theRow := LAddRow(1, 200, theList);            cSize.v := theRow;            sTemp := theString;            LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);            LDraw(cSize, theList);          END;      END;    PROCEDURE SetValues; {D_Standard_Entry...put in the strings for the units. These strings are read as input only if a value is                          changed by the user so that all values are always his exact numbers.}      VAR        nn                            : integer;      BEGIN {PROCEDURE SetValues; num_elements is known}        FOR nn := Num_Elements TO 14 DO          BEGIN            GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, '0');            GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, '0');            IF Num_Elements > 15 THEN Num_Elements := 15;            IF Num_Elements < 1 THEN Num_Elements := 1;          END;       { myform.style := fixedDecimal;        myform.digits := 6;}        IF Chem_Scale = 2 THEN {Num_Elements is #of elements}          BEGIN            IF (Num_Elements < 1) THEN exit(SetValues);            IF Num_Elements > 15 THEN Num_Elements := 15;     { Call Procedure WeightF_to_Ox to convert theWeightF[1..n] to        theOxWeightF[1..m]:m = n - 1, and to make theOxStr[1..m]. }            FOR nn := 1 TO Num_Elements - 1 DO              BEGIN                WtFrac_to_Oxide(theValence[nn], nn, theZ[nn], s5Temp, theWeightF[nn], tempReal);                theOxStr[nn] := s5Temp;                theOxWeightF[nn] := tempReal;              END;            IF Num_Elements > 15 THEN Num_Elements := 15;            IF Num_Elements < 1 THEN Num_Elements := 1;            theOxWeightF[Num_Elements] := 0.0;            FOR nn := 0 TO Num_Elements - 2 DO              BEGIN                GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, theOxStr[nn + 1]);                tempReal := theOxWeightF[nn + 1];                {Mynum2str} RealToString(tempReal, 5, 5, thestr); {tempReal is double_t,thestr is a decstr}                GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, thestr);              END; {FOR nn := 0...}            nn := Num_Elements - 1;            IF Num_Elements > 15 THEN Num_Elements := 15;            IF Num_Elements < 1 THEN Num_Elements := 1;            sTemp := '0';            GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, sTemp);            GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, sTemp);          END { IF Chem_Scale = 2...}        ELSE          BEGIN            FOR nn := 0 TO Num_Elements - 1 DO              BEGIN                GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);                IF theZ[nn + 1] = 8 THEN sTemp := '8'				ELSE IF theZ[nn + 1] = 0 THEN sTemp := '0'                ELSE sTemp := a^.sym[theZ[nn + 1]];                SetDialogItemText(DItem, sTemp);              END; {FOR nn := 0...}            IF (Chem_Scale = 3) THEN {# of atoms }              BEGIN { Pre calculate the needed quantities }                {```}                IF theZ[1] <> 0 THEN                  BEGIN                    Wt_By_A[1] := theWeightF[1] / At_Wt^^.Value[theZ[1]];                    Smallest_Wt_By_A := Wt_By_A[1];                  END;                FOR nn := 2 TO Num_Elements DO                  BEGIN {find nn of smallest # of atoms}                    {```}                    IF theZ[nn] <> 0 THEN                      BEGIN                        Wt_By_A[nn] := theWeightF[nn] / At_Wt^^.Value[theZ[nn]]; {xxx}                        IF Wt_By_A[nn] < Smallest_Wt_By_A THEN Smallest_Wt_By_A := Wt_By_A[nn];                      END;                  END;              END {IF Chem_Scale = 3...}            ELSE              IF Chem_Scale = 5 THEN { atomic fract }                BEGIN { Pre calculate the needed quantities }                  Sum_Wt_By_A := 0.0;                  IF Num_Elements > 15 THEN Num_Elements := 15;                  IF Num_Elements < 1 THEN Num_Elements := 1;                  FOR nn := 1 TO Num_Elements DO                    BEGIN                      {```}                      IF theZ[nn] <> 0 THEN                        BEGIN                          Wt_By_A[nn] := theWeightF[nn] / At_Wt^^.Value[theZ[nn]];                          Sum_Wt_By_A := Sum_Wt_By_A + Wt_By_A[nn];                        END;                    END;                END; {IF (Chem_Scale = 5)...}            IF Num_Elements > 15 THEN Num_Elements := 15;            IF Num_Elements < 1 THEN Num_Elements := 1;            FOR nn := 0 TO Num_Elements - 1 DO              BEGIN                GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);                temp := theZ[nn + 1];                tempReal := 0.0; { double_t variable }                IF temp = 8 THEN SetDialogItemText(DItem, '8')				ELSE IF theZ[nn + 1] = 0 THEN SetDialogItemText(DItem, '0')                ELSE SetDialogItemText(DItem, a^.sym[temp]);                IF Chem_Scale = 6 THEN                  BEGIN                    numtostring(theValence[nn + 1], sTemp);                    GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                    SetDialogItemText(DItem, sTemp);                  END                ELSE                  BEGIN { IF Chem_Scale <> 6...}                    IF Chem_Scale = 1 THEN tempReal := theWeightF[nn + 1]                    ELSE                      IF Chem_Scale = 3 THEN tempReal := (Wt_By_A[nn + 1] / Smallest_Wt_By_A)                      ELSE                        IF Chem_Scale = 4 THEN                          BEGIN                            temp := theZ[nn + 1];                            {```}                            IF temp <> 0 THEN tempReal := (theWeightF[nn + 1] * 1E6) / At_Wt^^.Value[temp];                          END {else IF Chem_Scale = 4 ...}                        ELSE IF Chem_Scale = 5 THEN tempReal := Wt_By_A[nn + 1] / Sum_Wt_By_A; {atom fract}                    { see SANE p25}                    {Mynum2str} RealToString(tempReal, 5, 5, thestr); {tempReal is double_t,thestr is a decstr}                    GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                    SetDialogItemText(DItem, thestr);                  END; { IF Chem_Scale <> 6...}              END; { for nn := 0 to 0 TO Num_Elements - 1 do... }          END; {IF Chem_Scale <> 2...}      END; {SetValues; ...D_Standard_Entry}    PROCEDURE GetValues; {D_Standard_Entry}  { gets decimal string; double_t result stored in binary as a real    This is called only if z or value is hit.}      VAR        nn, ZValue                    : integer;        WValue                        : real {double_t};      BEGIN        Formula_Wt := 0.0;        IF (Chem_Scale <> 6) THEN Num_Elements := 0;        IF (Chem_Scale = 2) THEN          BEGIN            FOR nn := 0 TO 14 DO              BEGIN                GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                WValue := MyStr2Num(sTemp); {convert the string to a real value}                GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);                GetDialogItemText(DItem, str); {to start, str is '0' ie zero }                str := Strip_Trailing_Blanks(str); { trim the space after a single char replace }                IF (ord(str[1]) <> 48) AND (WValue > 0) THEN                  BEGIN                    Num_Elements := Num_Elements + 1;                    IF Num_Elements > 15 THEN Num_Elements := 15;                    theOxStr[Num_Elements] := str;                    theOxWeightF[Num_Elements] := WValue;                  END                ELSE                  BEGIN                    theOxWeightF[nn + 1] := 0.0;                    theOxStr[nn + 1] := str;                  END;                theValence[nn + 1] := 0; {give this values in Oxide_to_Z routine}              END; { FOR nn := 0 TO 14...}            Num_Elements := Num_Elements + 1; {include oxygen}            IF Num_Elements > 15 THEN Num_Elements := 15;            {Call the routine Oxide_to_Z to get the z,wtfs and valences}            theWeightF[Num_Elements] := 0.0;            FOR nn := 1 TO Num_Elements - 1 DO              BEGIN                s5Temp := theOxStr[nn];                Oxide_to_WtFrac(s5Temp, nn, theZ[nn], theValence[nn], theWeightF[nn], WValue, theOxWeightF[nn]);                theWeightF[Num_Elements] := theWeightF[Num_Elements] + WValue;              END;            theZ[Num_Elements] := 8;            theValence[Num_Elements] := 2;          END { IF (Chem_Scale = 2)...}        ELSE          IF (Chem_Scale = 6) THEN {we already know the Z's}            FOR nn := 0 TO Num_Elements - 1 DO              BEGIN                GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                StringToNum(sTemp, theValence[nn + 1]);              END { IF (Chem_Scale = 6)...}          ELSE            BEGIN              FOR nn := 0 TO 14 DO                BEGIN                  GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  sTemp := Strip_Trailing_Blanks(sTemp); { trim the space after a single char replace }                  IF sTemp = '8' THEN ZValue := 8                  ELSE ZValue := AtSymbol_To_Znum(sTemp);                  GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  WValue := MyStr2Num(sTemp); {convert the string to a real value}                  {ее}                  IF (ZValue > 0) AND (WValue > 0) THEN                    BEGIN                      Num_Elements := Num_Elements + 1;                      IF Num_Elements > 15 THEN Num_Elements := 15;                      theZ[Num_Elements] := ZValue;                      theWeightF[Num_Elements] := WValue;                    END                  ELSE                    BEGIN                      theWeightF[nn + 1] := 0.0;                      theZ[nn + 1] := 0;                    END;                END; { FOR nn := 0 TO 14...}              IF (Chem_Scale = 3) THEN { # of atoms }                BEGIN                  FOR nn := 0 TO Num_Elements - 1 DO                    BEGIN                      temp := theZ[nn + 1];                      theWeightF[nn + 1] := theWeightF[nn + 1] * (At_Wt^^.Value[temp]);                      Formula_Wt := Formula_Wt + theWeightF[nn + 1];                    END; {FOR nn := 0...}                  FOR nn := 0 TO Num_Elements - 1 DO                    theWeightF[nn + 1] := theWeightF[nn + 1] / Formula_Wt;                END { IF (Chem_Scale = 3) }              ELSE                IF (Chem_Scale = 4) THEN {mMole/kgdrywt}                  FOR nn := 0 TO Num_Elements - 1 DO                    BEGIN                      temp := theZ[nn + 1];                      theWeightF[nn + 1] := theWeightF[nn + 1] * At_Wt^^.Value[temp] * 1E-6;                    END {IF (Chem_Scale = 4) ... FOR nn := 0 ...}                ELSE                  IF (Chem_Scale = 5) THEN { atomic fract }                    BEGIN                      Sum_Wt_By_A := 0.0;                      FOR nn := 0 TO Num_Elements - 1 DO                        BEGIN                          temp := theZ[nn + 1];                          Wt_By_A[nn + 1] := theWeightF[nn + 1] * At_Wt^^.Value[temp];                          Sum_Wt_By_A := Sum_Wt_By_A + Wt_By_A[nn + 1];                        END;                      FOR nn := 0 TO Num_Elements - 1 DO                        BEGIN                          theWeightF[nn + 1] := Wt_By_A[nn + 1] / Sum_Wt_By_A;                        END;                    END; {IF (Chem_Scale = 5)...}            END; {if chem_scale<>6}      END; { sub Procedure GetValues }    PROCEDURE Do_Sums;      VAR        nn                            : integer;      BEGIN        Sum := 0.0;        Average_Z := 0.0;  {We always know what theWeightF,etc and, IF (Chem_Scale = 2),   we know OxWeightF, OxStr etc }        IF (Num_Elements < 1) THEN exit(Do_Sums);        IF Num_Elements > 15 THEN Num_Elements := 15;        FOR nn := 0 TO Num_Elements - 1 DO          BEGIN {if we read strings then no math needed}            IF (Chem_Scale = 2) THEN Sum := Sum + theOxWeightF[nn + 1]            ELSE              IF (Chem_Scale = 5) THEN                BEGIN                  GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  Sum := Sum + MyStr2Num(sTemp);                END              ELSE Sum := Sum + theWeightF[nn + 1];            Average_Z := Average_Z + theWeightF[nn + 1] * theZ[nn + 1];          END;        GetDialogItem(GetSelection, T_Sum, XDType, XDItem, tempRect);        RealToString(Sum, 5, 5, str);        SetDialogItemText(XDItem, str);        GetDialogItem(GetSelection, T_Diff_From_1, XDType, XDItem, tempRect);        RealToString(1 - Sum, 5, 5, str);        SetDialogItemText(XDItem, str);        GetDialogItem(GetSelection, T_Average_Z, XDType, XDItem, tempRect);        RealToString(Average_Z, 5, 5, str);        SetDialogItemText(XDItem, str);      END;	    Procedure Clear_Comp_Data;    VAR	  nn	: integer;  	BEGIN		FOR nn := 0 TO 14 DO		  BEGIN			theZ[nn + 1] := 0;			theWeightF[nn + 1] := 0.0;			theOxStr[nn + 1] := '';			theOxWeightF[nn + 1] := 0.0;			theValence[nn + 1] := 0;			GetDialogItem(GetSelection, I_Z1 + 2 * nn, DType, DItem, tempRect);			SetDialogItemText(DItem, '0');			GetDialogItem(GetSelection, I_Value + 2 * nn, DType, DItem, tempRect);			SetDialogItemText(DItem, '0');		  END;		Do_Sums;		Num_Elements := 0;	END;	      BEGIN { main PROCEDURE D_Standard_Entry;}      GetSelection := GetNewDialog(4551, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      OutlineButton(GetSelection, 1, 16); { outline the accept button }	  	  GetDialogItem(GetSelection, Insert_in_Database, DType, DItem, tempRect);	  HiliteControl(ControlHandle(DItem), 255);	  GetDialogItem(GetSelection, Remove_Item, DType, DItem, tempRect);	  HiliteControl(ControlHandle(DItem), 255);      SetRect(Rect_I_List1, 194, 189, 615, 332); { l,t,r,b }      tempRect := Rect_I_List1;      tempRect.Right := tempRect.Right - 15;      IF (tempRect.Right <= (tempRect.Left + 15)) THEN tempRect.Right := tempRect.Left + 15;      InsetRect(tempRect, - 1, - 1);      FrameRect(tempRect);      InsetRect(tempRect, 1, 1);      SetRect(dataBounds, 0, 0, 1, 0);      cSize.h := tempRect.Right - tempRect.Left;      cSize.v := 0;      cList := LNew(tempRect, dataBounds, cSize, 0, GetSelection, true, FALSE, FALSE, true);      cList^^.selFlags := lOnlyOne + lNoNilHilite;      LSetDrawingMode(FALSE, cList);      strt_str := 'Replace this text with new item name (<32 chars)';      GetDialogItem(GetSelection, Edit_Text_Item, DType, DItem, tempRect);      SetDialogItemText(DItem, strt_str);      cSize.v := 0;      LSetSelect(true, cSize, cList);      Refresh_Dialog;      Number_of_Entries := 0;      OpenNew_Database := FALSE;      IF (DataBase_Open = true) THEN	   begin	    LSetDrawingMode(true, cList);	    Open_Database;		  GetDialogItem(GetSelection,Insert_in_Database,DType,DItem,tempRect);		  HiliteControl(ControlHandle(DItem), 0); 		  GetDialogItem(GetSelection,Remove_Item,DType,DItem,tempRect);		  HiliteControl(ControlHandle(DItem), 0); 				  LdelRow(0, 1, cList);		  LSetDrawingMode(FALSE, cList);		  if Comp_handles then			begin			  FOR Index := 1 TO Number_of_Entries DO				BEGIN				  IF NOT (Comp_Data[Index]^^.C_Name = '') THEN					BEGIN					  numtostring(Index, str1);					  str2 := Strip_Trailing_Blanks(str1);					  str1 := Strip_Trailing_Blanks(Comp_Data[Index]^^.C_Name);					  str := CONCAT(str2, '  ', str1);					  Add_LStr(str, cList);					END;				END;			end;		  LSetDrawingMode(true, cList);		  cSize.v := 0;		  LSetSelect(true, cSize, cList); { this selects the first entry }				Refresh_Dialog;	   end;      GetDialogItem(GetSelection, I_Make_Standard, DType, DItem, tempRect);      CItem := ControlHandle(DItem);      IF Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard THEN SetControlValue(CItem, 1)      ELSE SetControlValue(CItem, 0);      GetDialogItem(GetSelection, T_disp_kV, DType, DItem, tempRect);      RealToString(Plt_spec[10]^^.Expt_Info.kV, 5, 2, str);      str := Strip_Trailing_Blanks(str);      SetDialogItemText(DItem, str);	  	  Clear_Comp_Data;      {the Plt_spec[10] values will not change unless accept}      Num_Elements := 0;      WITH Plt_spec[10]^^.SpectrumStuff.Spectrum_Info DO        FOR nn := 1 TO 15 DO          BEGIN { stuff in what's in the record }            theZ[nn] := Element_Info[nn].Atomic_Number;            IF ((theZ[nn] <= 0) OR (theZ[nn] > 95)) THEN theZ[nn] := 0            ELSE Num_Elements := Num_Elements + 1;            IF Num_Elements > 15 THEN Num_Elements := 15;			if ((Element_Info[nn].Valence < 0.0) OR (Element_Info[nn].Valence > 7.0)) then Element_Info[nn].Valence := 0.0;            theValence[nn] := rinttol(Element_Info[nn].Valence);            theWeightF[nn] := Element_Info[nn].Weight_Fraction;          END;		  if Num_Elements <= 0 then		  		Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_standard := false;      IF ((Active_Chemical_Scale < 1) OR (Active_Chemical_Scale > 5)) THEN Active_Chemical_Scale := 1; { GLOBAL }      Chem_Scale := Active_Chemical_Scale; { LOCAL }      FOR Index := R_Wt_Fr TO R_Valence DO        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          SetControlValue(ControlHandle(DItem), 0);        END;      GetDialogItem(GetSelection, I_Quantity, XDType, XDItem, tempRect);      IF Active_Chemical_Scale = 1 THEN        BEGIN          SetDialogItemText(XDItem, 'Weight Fraction');          Index := R_Wt_Fr;        END      ELSE        IF Active_Chemical_Scale = 2 THEN          BEGIN            SetDialogItemText(XDItem, 'Oxide Weight Fraction');            Index := R_Ox_Fr;          END        ELSE          IF Active_Chemical_Scale = 3 THEN            BEGIN              SetDialogItemText(XDItem, 'Number of Atoms in a Compound');              Index := R_Num_Atms;            END          ELSE            IF Active_Chemical_Scale = 4 THEN              BEGIN                SetDialogItemText(XDItem, 'mMol/kg dry Wt');                Index := R_mMol_Dry_Wt;              END            ELSE              IF Active_Chemical_Scale = 5 THEN                BEGIN                  SetDialogItemText(XDItem, 'Atomic Fraction');                  Index := R_Atm_Fr;                END;      GetDialogItem(GetSelection, Index, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 1);      SetValues;      Do_Sums;      { setup for window finished; start getting input }      ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@GFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        IF (itemHit > 100) AND (itemHit < 999) THEN          BEGIN            temp := itemHit - 100;            GetDialogItem(GetSelection, Edit_Text_Item, DType, DItem, tempRect);			if Comp_handles then			  begin			    Clear_Comp_Data;				str7 := Strip_Trailing_Blanks(Comp_Data[temp]^^.C_Name);				SetDialogItemText(DItem, str7);				Num_Elements := Comp_Data[temp]^^.C_Number;				IF Num_Elements > 15 THEN Num_Elements := 15;				FOR Index := 1 TO Num_Elements DO				  BEGIN					theZ[Index] := Comp_Data[temp]^^.C_Atno[Index];					theWeightF[Index] := Comp_Data[temp]^^.C_WtFr[Index];					theValence[Index] := Comp_Data[temp]^^.C_Valence[Index];				  END;			  end;            GetDialogItem(GetSelection, I_Quantity, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, 'Weight Fraction');            GetDialogItem(GetSelection, R_Wt_Fr, DType, DItem, tempRect);            CItem := ControlHandle(DItem);            Chem_Scale := 1;            SetValues;            Do_Sums;            FOR Index := R_Wt_Fr TO R_Valence DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0); {turn off all radios}              END;            SetControlValue(CItem, 1); {turn on the selected radio}            Refresh_Dialog;          END;        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;            { GetValues;} {reads the strings and converts to wtF; gives theWeights and theZs}            IF Chem_Scale < 6 THEN Active_Chemical_Scale := Chem_Scale;            GetDialogItem(GetSelection, I_Make_Standard, DType, DItem, tempRect);            CItem := ControlHandle(DItem);            temp := GetControlValue(CItem);            IF (temp = 0) or			   (Num_Elements <= 0)			  THEN Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard := FALSE            ELSE Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard := true;            WITH Plt_spec[10]^^.SpectrumStuff.Spectrum_Info DO              FOR nn := 1 TO Num_Elements DO                BEGIN                  a^.Thin_At_Num[nn] := theZ[nn];                  Element_Info[nn].Atomic_Number := theZ[nn];                  IF ((theValence[nn] > 0) AND (theValence[nn] <= 7)) then                  	Element_Info[nn].Valence := theValence[nn]                  else                  	Element_Info[nn].Valence := 0.0;                  Element_Info[nn].Weight_Fraction := {num2real}(theWeightF[nn]);                END;			 if (Comp_handles) then              FOR Index := 1 TO Number_of_Entries DO                H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');			 Comp_handles := false;          END        ELSE          IF (itemHit = Cancel) THEN            BEGIN			  if (Comp_handles) then              FOR Index := 1 TO Number_of_Entries DO                H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');			  Comp_handles := false;   {putmessage('About to dispose of the cList','','','');   LDispose(cList);}              tempRect := GetSelection^.portRect;              DisposeDialog(GetSelection);              FillWhiteSpace(tempRect);              exit(D_Standard_Entry);            END        ELSE          IF (itemHit = I_Help) THEN            BEGIN				SE_Help;			END          ELSE            IF (itemHit = I_Clear) THEN              BEGIN			    Clear_Comp_Data;              END			              ELSE              IF (itemHit = Remove_Item) THEN                BEGIN				  StringToNum(str_info, tempLong);				  if (tempLong > 0) then				   begin				  Remove_from_Database(tempLong);				  if (Comp_handles) then				    begin					  H_UnLock_Dispose(Handle(Comp_Data[Number_of_Entries]), 'Comp_Data handle');					  cSize.v := 0;					  LSetSelect(true, cSize, cList); { this selects the first entry }					  LSetDrawingMode(true, cList);					  LdelRow(0, 1, cList);					  Number_of_Entries := Number_of_Entries - 1;					  LSetDrawingMode(false, cList);					  if (Comp_handles) AND (Number_of_Entries > 0) then					  for index := 1 to Number_of_Entries do						begin						  IF NOT (Comp_Data[Index]^^.C_Name = '') THEN							BEGIN							  str7 := Comp_Data[index]^^.C_Name;							  numtostring(index, str1);							  str1 := Strip_Trailing_Blanks(str1);							  str := CONCAT(str1, '  ', str7);							  Add_LStr(str, cList);							END;						end;					end;				  LSetDrawingMode(true, cList);				  Refresh_Dialog;				  cSize.v := 0;				  LSetSelect(true, cSize, cList); { this selects the first entry }				  end;	{ if (tempLong > 0) }				END             ELSE              IF (itemHit = Insert_in_Database) THEN                BEGIN				  IF (DataBase_Open = TRUE) THEN					BEGIN                  IF Number_of_Entries >= 50 THEN                    BEGIN                      putmessage('You have reached the maximum number', ' of compositions allowed for this file.',                                 ' Please start a new data file for additional', ' compositions.');                    END                  ELSE                    BEGIN                      GetDialogItem(GetSelection, Edit_Text_Item, DType, DItem, tempRect);                      GetDialogItemText(DItem, sTemp);                      str7 := Strip_Trailing_Blanks(sTemp);					  if NOT (strt_str = str7) then					  begin                      Number_of_Entries := Number_of_Entries + 1;                      {putmessage('str7 contains the name ',str7,' first','');}                      Test_a_Handle(Handle(Comp_Data[Number_of_Entries]), 'Comp_Data[Number_of_Entries]');                      Comp_Data[Number_of_Entries] := Comp_RecHdl(NewHandle(SizeOf(Comp_Rec)));                      MoveHHi(Handle(Comp_Data[Number_of_Entries]));                      HLock(Handle(Comp_Data[Number_of_Entries]));					  Comp_handles := true;                      {putmessage('str7 contains the name ',str7,' second','');}					  nn := Length(str7);					  if nn > 32 then					  	str7[0] := chr(32);                      Comp_Data[Number_of_Entries]^^.C_Name := str7;                      IF Num_Elements < 1 THEN Num_Elements := 1;                      Comp_Data[Number_of_Entries]^^.C_Number := Num_Elements;                      FOR Index := 1 TO Num_Elements DO                        BEGIN                          Comp_Data[Number_of_Entries]^^.C_Atno[Index] := theZ[Index];                          Comp_Data[Number_of_Entries]^^.C_WtFr[Index] := theWeightF[Index];							if ((theValence[Index] < 1) OR (theValence[Index] > 7)) then								theValence[Index] := 0;                          Comp_Data[Number_of_Entries]^^.C_Valence[Index] := theValence[Index];                        END;                      Add_to_Database;                      numtostring(Number_of_Entries, str1);                      str1 := Strip_Trailing_Blanks(str1);                      str := CONCAT(str1, '  ', str7);                      {putmessage('str7 contains the name ',str7,' third','');}                      LSetDrawingMode(true, cList);                      Add_LStr(str, cList);                      Refresh_Dialog;					  end;                    END;				  END;		{ IF (DataBase_Open) }                END              ELSE                IF (itemHit = Name_New_Database) THEN                  BEGIN                    DataBase_Open := FALSE;                    LdelRow(0, 1, cList);                    Create_Database;					  GetDialogItem(GetSelection,Insert_in_Database,DType,DItem,tempRect);					  HiliteControl(ControlHandle(DItem), 0); 					  GetDialogItem(GetSelection,Remove_Item,DType,DItem,tempRect);					  HiliteControl(ControlHandle(DItem), 0);                     Refresh_Dialog;                  END                ELSE                  IF (itemHit = Retreive_Item) THEN                    BEGIN                      OpenNew_Database := true;                      LSetDrawingMode(true, cList);                      Open_Database;					  GetDialogItem(GetSelection,Insert_in_Database,DType,DItem,tempRect);					  CItem := ControlHandle(DItem);					  HiliteControl(CItem, 0); 					  GetDialogItem(GetSelection,Remove_Item,DType,DItem,tempRect);					  CItem := ControlHandle(DItem);					  HiliteControl(CItem, 0);                       cSize.v := 0;                      LSetSelect(true, cSize, cList); { this selects the first entry }                      {Refresh_Dialog;}                      LdelRow(0, 1, cList);                      LSetDrawingMode(FALSE, cList);					  if Comp_handles then					    begin						  FOR Index := 1 TO Number_of_Entries DO							BEGIN							  IF NOT (Comp_Data[Index]^^.C_Name = '') THEN								BEGIN								  numtostring(Index, str1);								  str2 := Strip_Trailing_Blanks(str1);								  str1 := Strip_Trailing_Blanks(Comp_Data[Index]^^.C_Name);								  str := CONCAT(str2, '  ', str1);								  Add_LStr(str, cList);								END;							END;						end;                      LSetDrawingMode(true, cList);                      Refresh_Dialog;                      cSize.v := 0;                      LSetSelect(true, cSize, cList); { this selects the first entry }                      OpenNew_Database := FALSE;                    END                  ELSE                    IF (itemHit = I_Make_Standard) THEN                      BEGIN                        temp := GetControlValue(CItem);                        SetControlValue(CItem, (temp + 1) MOD 2);                        BeepBeep;                      END                    ELSE                      IF (itemHit >= R_Wt_Fr) AND (itemHit <= R_Valence) THEN                        BEGIN                          IF itemHit = R_Ox_Fr THEN                            BEGIN                              nn := 1;                              REPEAT                                IF theValence[nn] > 0 THEN nn := nn + 1;                              UNTIL (theValence[nn] <= 0) OR (nn = Num_Elements);      {remember the valence[Num_Elements] is the valence[Oxygen] which       doesn't count.}       						if num_elements < 1 then num_elements := 1;                              IF ((theValence[nn] <= 0) OR (theValence[nn] > 7)) AND (theWeightF[1] > 0.0) THEN                                putmessage('I cannot give you the Oxide fractions without the valences.',                                           'Another way to enter the data is to `zero all` then click the oxide',                                           'button and enter formulas such as Al2O3. The valences will then be',                                           'calculated from the stoichiometry relation.')                              ELSE                                IF ((theZ[Num_Elements] <> 8) AND (theWeightF[1] > 0.0)) THEN                                  putmessage('The last element must be oxygen for this conversion.', '', '', '')                                ELSE                                  BEGIN                                    GetDialogItem(GetSelection, I_Quantity, XDType, XDItem, tempRect);                                    SetDialogItemText(XDItem, 'Oxide Weight Fraction');                                    FOR Index := R_Wt_Fr TO R_Valence DO                                      BEGIN                                        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                                        SetControlValue(ControlHandle(DItem), 0);                                      END;                                    SetControlValue(CItem, 1);                                    Chem_Scale := 2;                                  END;                            END { IF itemHit = R_Ox_Fr THEN...}                          ELSE                            BEGIN { IF itemHit <> R_Ox_Fr THEN...}                              GetDialogItem(GetSelection, I_Quantity, XDType, XDItem, tempRect);                              FOR Index := R_Wt_Fr TO R_Valence DO                                BEGIN                                  GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                                  SetControlValue(ControlHandle(DItem), 0);                                END;                              SetControlValue(CItem, 1);                              IF itemHit = R_Wt_Fr THEN                                BEGIN                                  SetDialogItemText(XDItem, 'Weight Fraction');                                  Chem_Scale := 1;                                END                              ELSE                                IF itemHit = R_Num_Atms THEN                                  BEGIN                                    SetDialogItemText(XDItem, 'Number of Atoms in a Compound');                                    Chem_Scale := 3;                                  END                                ELSE                                  IF itemHit = R_mMol_Dry_Wt THEN                                    BEGIN                                      SetDialogItemText(XDItem, 'mMol/kg dry Weight');                                      Chem_Scale := 4;                                    END                                  ELSE                                    IF itemHit = R_Atm_Fr THEN                                      BEGIN                                        SetDialogItemText(XDItem, 'Atomic Fraction');                                        Chem_Scale := 5;                                      END                                    ELSE                                      IF itemHit = R_Valence THEN                                        BEGIN                                          SetDialogItemText(XDItem, 'Valences');                                          Chem_Scale := 6;                                        END;                            END; { IF itemHit <> R_Ox_Fr THEN...}   {if we've cleared all the values and changed units there's no point    in calling SetValues and Do_Sums til there are some new entries}                          IF Num_Elements > 0 THEN                            BEGIN                              SetValues; {we always have theWeightFs and theZs}                              Do_Sums;                            END;                        END { IF (itemHit >= R_Wt_Fr) AND (itemHit <= R_Valence) THEN...}                      ELSE                        IF (itemHit >= I_Z1) AND (itemHit <= I_Value + 28) THEN                          BEGIN { we don't want to read values just because we changed units but we do if we changed z or quantity}                            GetValues; {gives theWeightFs and theZs}                            Do_Sums;                          END;        {ееее}      UNTIL ExitDialog;      FOR nn := Num_Elements + 1 TO 15 DO        BEGIN          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Weight_Fraction := 0.0;          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Atomic_Number := 0;          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence := 0.0;        END;      Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements := Num_Elements;      Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Average_Z := Average_Z;	  if Comp_handles then      FOR Index := 1 TO Number_of_Entries DO        H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');	  Comp_handles := false;      {LDispose(cList);}      DisposeDialog(GetSelection);    END; {End of PROCEDURE D_Standard_Entry; }  PROCEDURE PutMoreInfo;    VAR      L                             : longint;      info                          : str255;      info2                         : str255;      DType                         : integer;      DItem                         : Handle;      str, str1, str2, str3         : str255;      str4, str7        			: str255;    BEGIN      StringToNum(str_info, L); {L is the "number" of the list item, ie, position }      IF L < 1 THEN L := 1;      IF L > 999 THEN L := 999;      info := ' ';      info2 := ' ';      IF (L >= 1) AND (L <= 999) THEN        BEGIN          info := 'No message for this item';          info2 := ' ';          str7 := 'Plotted as a function of Z in channels 1-100.';          IF L = 100 THEN            BEGIN              str1 := 'The spectrum with no counting noise present. To add the correct ammount of noise ';              str2 := 'to this spectrum go to the MATH menu and "Add Poisson Noise". This will add the  ';              str3 := 'correct noise for the faraday current, time, detector area etc. etc. that you ';              str4 := 'specified.';              info := CONCAT(str1, str2, str3, str4);              str1 := 'This spectrum can be made to agree closely with actual spectra from your instrument by ';              str2 := 'fine tuning the instrumental and detector parameters, and, as a rare and last resort, by ';              str3 := 'adjusting the coefficients on the x-ray cross-sections';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 1 THEN            BEGIN              str1 := 'Qk is the K shell Ionization Cross Section you chose in the "Choose Cross ';              str2 := 'Sections" Dialog. The numbers displayed are in cm^2 and are scaled by 1.0E20.';               str3 := 'Therefore, multiply the values by 1.0E-20. Also use AUTOSCALE. ';              info := CONCAT(str1, str2, str3, str7);            END;          IF L = 2 THEN            BEGIN              str1 := 'Ql is the L shell Ionization Cross Section you chose in the "Choose Cross ';              str2 := 'Sections" Dialog. The numbers displayed are in cm^2 and are scaled by 1.0E20.';               str3 := 'Therefore, multiply the values by 1.0E-20. Also use AUTOSCALE. ';              info := CONCAT(str1, str2, str3, str7);            END;          IF L = 3 THEN            BEGIN              str1 := 'Qm is the M shell Ionization Cross Section you chose in the "Choose Cross ';              str2 := 'Sections" Dialog. The numbers displayed are in cm^2 and are scaled by 1.0E20.';               str3 := 'Therefore, multiply the values by 1.0E-20. Also use AUTOSCALE. ';              info := CONCAT(str1, str2, str3, str7);            END;          IF L = 5 THEN            BEGIN              str1 := 'QkеFеOmega is the product of the K shell Cross Section, the relative transition ';              str2 := 'probability and the fluorescence yield. For some purposes the peak of this plot ';              str3 := ' corresponds to the most sensitive element in the K Family for a given kV.';              str4 := ' Multiply the values by 1.0E-14 cm^2eV^2.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 6 THEN            BEGIN              str1 := 'QlеFеOmega is the product of the L shell Cross Section, the relative transition ';              str2 := 'probability and the fluorescence yield. For some purposes the peak of this plot ';              str3 := ' corresponds to the most sensitive element in the L Family for a given kV.';              str4 := ' Multiply the values by 1.0E-14 cm^2eV^2.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 7 THEN            BEGIN              str1 := 'QmеFеOmega is the product of the M shell Cross Section, the relative transition ';              str2 := 'probability and the fluorescence yield. For some purposes the peak of this plot ';              str3 := ' corresponds to the most sensitive element in the M Family for a given kV.';              str4 := ' Multiply the values by 1.0E-14 cm^2eV^2.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 8 THEN            BEGIN              str1 := 'QkеFеOmega/A is the same as 5 but divided by atomic weight. For a thin target and ';              str2 := 'an element in a fixed matrix the peak of this plot corresponds to the most sensitive ';              str3 := 'element in the K Family for a given kV.';              str4 := ' Multiply the values by 1.0E-14 cm^2eV^2.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 9 THEN            BEGIN              str1 := 'QlеFеOmega/A is the same as 6 but divided by atomic weight. For a thin target and ';              str2 := 'an element in a fixed matrix the peak of this plot corresponds to the most sensitive ';              str3 := 'element in the L Family for a given kV.';              str4 := ' Multiply the values by 1.0E-14 cm^2eV^2.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 10 THEN            BEGIN              str1 := 'QmеFеOmega/A is the same as 7 but divided by atomic weight. For a thin target and ';              str2 := 'an element in a fixed matrix the peak of this plot corresponds to the most sensitive ';              str3 := 'element in the M Family for a given kV.';              str4 := ' Multiply the values by 1.0E-14 cm^2eV^2.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 11 THEN            BEGIN              str1 := 'Fk is the relative transition probability for the K alpha1 line. It is the number of ';              str2 := 'photons of K alpha1 generated within the specimen, divided by the number of ';              str3 := 'photons generated in all lines produced by ionization of the K shell.';              info := CONCAT(str1, str2, str3);            END;          IF L = 12 THEN            BEGIN              str1 := 'Fl is the relative transition probability for the L alpha1 line. It is the number of ';              str2 := 'photons of L alpha1 generated within the specimen, divided by the number of ';              str3 := 'photons generated in all lines produced by ionization of the LIII shell.';              info := CONCAT(str1, str2, str3);            END;          IF L = 13 THEN            BEGIN              str1 := 'Fm is the relative transition probability for the M alpha line. It is the number of ';              str2 := 'photons of M alpha generated within the specimen, divided by the number of ';              str3 := 'photons generated in all lines produced by ionization of the MV shell. (Poorly known)';              info := CONCAT(str1, str2, str3);            END;          str := 'It is the probability of X-Ray emission (rather than Auger emission) after an atom ';          str := CONCAT(str, 'has been ionized (in our case) by an electron or a photon.');          IF L = 14 THEN            BEGIN              str1 := 'Omega K is the fluorescence yield for the K shell.  ';              info := CONCAT(str1, str);            END;          IF L = 15 THEN            BEGIN              str1 := 'Omega L is the fluorescence yield for the LIII shell and is less well known than for K.  ';              info := CONCAT(str1, str);            END;          IF L = 16 THEN            BEGIN              str1 := 'Omega M is the fluorescence yield for the MV shell and is poorly known.  ';              info := CONCAT(str1, str);            END;          IF L = 17 THEN            BEGIN              str1 := 'The Atomic Weights. ';              info := CONCAT(str1, str7);            END;          IF L = 18 THEN            BEGIN              str1 := 'J is the mean excitation energy used in the stopping power equation, S. ';              info := CONCAT(str1, str7);            END;          IF L = 19 THEN            BEGIN              str1 := 'Same as 18 but normalized by dividing thru by Z. ';              info := CONCAT(str1, str7);            END;          str := 'It is used in the calculation of X-Ray generation in BULK targets only. ';          IF L = 20 THEN            BEGIN              str1 := 'The Integral of Qk/S is the integration, from the beam energy down to the K binding ';              str2 := 'energy, of the ratio of the characteristic cross-section by the stopping power. ';              info := CONCAT(str1, str2, str);            END;          IF L = 21 THEN            BEGIN              str1 := 'The Integral of Ql/S is the integration, from the beam energy down to the LIII binding ';              str2 := 'energy, of the ratio of the characteristic cross-section by the stopping power. ';              info := CONCAT(str1, str2, str);            END;          IF L = 22 THEN            BEGIN              str1 := 'The Integral of Qm/S is the integration, from the beam energy down to the MV binding ';              str2 := 'energy, of the ratio of the characteristic cross-section by the stopping power. ';              info := CONCAT(str1, str2, str);            END;          IF L = 23 THEN            BEGIN              str1 := 'The stopping power of an atom of atomic number Z for an electron of a given energy ';              str2 := 'in keV. Stopping power is usually expressed as the Bethe Law divided by mass-thickness. ';              info := CONCAT(str1, str2, str7);            END;          IF L = 26 THEN            BEGIN            END;          IF L = 58 THEN            BEGIN              str1 := 'Theoretical peak to local(10 eV) background for K alpha. The ratio ';              str2 := 'is for the integral of the KA1 and the KA2 lines divided by the continuum in 10eV under ';              str3 := 'the peaks. The ratio is stongly a function of beam energy and take-off angle. ';              info := CONCAT(str1, str2, str3);              str1 := 'This ratio is useful to test out the performance of your AEM. Use the SIMPLEX to obtain  ';              str2 := 'a P/B for, say, Cr, and see if it is close to the numbers predicted in this ';              str3 := 'curve of P/B vs Z. If it is not at least close it may not be the fault of the program ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 59 THEN info := 'Same as 58 but for L alpha 1 line. ';          IF L = 60 THEN info := 'Same as 58 but for M alpha line. ';          IF L = 61 THEN            BEGIN              str1 := 'Atomic density vs Z, it might be useful in the "Calculator". ';              info := str1;            END;          IF L = 62 THEN            BEGIN              str1 := 'Atomic number divided by atomic weight, vs Z, it might be useful in the "Calculator". ';              info := str1;            END;          IF L = 63 THEN            BEGIN              str1 := 'Atomic number squared divided by atomic weight, vs Z, it might be useful in the  ';              str2 := '"Calculator". Important quantity for biologists using the AEM. ';              info := CONCAT(str1, str2);            END;          IF L = 65 THEN            BEGIN              str1 := 'QkEk^2 is the K shell Ionization Cross Section you chose in the "Choose Cross ';              str2 := 'Sections" Dialog times Ek^2 vs U (U = 10 eV/chan). The numbers displayed are in cm^2eV^2 ';               str3 := 'and are scaled by 1.0E14. Therefore, multiply the values by 1.0E-14. Also use AUTOSCALE. ';              str4 := 'YOU MAY SELECT ONLY ONE ELEMENT FOR THIS OUTPUT.';              info := CONCAT(str1, str2, str3, str4);            END;          IF L = 66 THEN            BEGIN              str1 := '45 degree ramp over all channels. May be useful in CALCULATOR. Useful to test the ';              str2 := 'digital filter, which should return zero for a straight line.';              info := CONCAT(str1, str2);            END;          IF L = 80 THEN            BEGIN              str1 := 'Detector Response vs photon energy. This is the detector efficiency, from 0-1, ';              str2 := 'of the detector whose parameters you entered. This curve is kept in memory and the ';              str3 := 'PREFERENCES.MCA file which loads at program startup. It is used thru out the program. ';              info := CONCAT(str1, str2, str3);            END;          IF L = 81 THEN            BEGIN              str1 := 'The Detector Response vs photon energy convolved with the detector resolution.  ';              str2 := 'This is the detector efficiency, from 0-1, of the detector whose parameters you entered.  ';              str3 := 'Note that the absorption edges are smoothed over and look surprisingly like peaks.';              info := CONCAT(str1, str2, str3);              str1 := 'In particular, note the effect on the Si absorption edge due to the detector dead layer. ';              str2 := 'This "Silicon Peak" translates into 0.1-0.2 weight percent Si in any specimen you ';              str3 := 'analyze. Use item #82, generating a Li or Be spectrum, to actually see the artifacts.';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 82 THEN            BEGIN              str1 := 'The observed spectrum but without noise or peaks. If the target was bulk, then the  ';              str2 := 'specimen self absorption edges will be present.  ';              str3 := ' ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 84 THEN            BEGIN              str1 := 'The spectrum as it would appear if a perfect detector was inside the specimen.  ';              str2 := 'The characteristic photons are all placed in one channel. This is a reasonable thing ';              str3 := 'to do since natural x-ray peaks are a few eV wide. (Scaled to detector solid angle).';              info := CONCAT(str1, str2, str3);              str1 := '';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 85 THEN            BEGIN              str1 := 'Detected peaks only. The observed spectrum but without noise or continuum.   ';              str2 := '   ';              str3 := ' ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 86 THEN            BEGIN              str1 := 'The spectrum as it would appear just in front of the detector.  ';              str2 := ' The specimen self absorption edges will be present. The characteristic photons ';              str3 := 'are all placed in one channel. This is a reasonable thing to do since natural x-ray ';              info := CONCAT(str1, str2, str3);              str1 := 'peaks are a few eV wide. Absorption for thin targets applied. ';              str2 := 'Bulk targets have had an absorption correction applied and a fluorescence correction ';              str3 := 'applied in this version. ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 87 THEN            BEGIN              str1 := 'The spectrum as it would appear just inside the detector. If the target was еbulkе, ';              str2 := ' then the specimen self absorption edges will be present. The characteristic photons ';              str3 := 'are all placed in one channel. еTHINе specimen absorption is also applied. ';              info := CONCAT(str1, str2, str3);              str1 := ' Note the effects of the detector window materials. еTry ';              str2 := 'convolving this spectrum with the detector resolution which can be done in ';              str3 := 'the "SMOOTH" feature. Compare the resulting spectrum with that of item 100. ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 88 THEN            BEGIN              str1 := 'Mu/Rho, the mass absorption coefficients, vs photon energy, for the target composition ';              str2 := 'you entered in the previous dialog.  ';              info := CONCAT(str1, str2);            END;          IF L = 89 THEN            BEGIN              str1 := 'f(chi) is for еBULKе targets only. It is the most important quantity in ZAF theory. ';              str2 := 'f(chi) is the probability, from 0-1, that a generated characteristic photon (generated, ';              str3 := 'at еANYе depth) of a given energy, will escape the specimen. ';              info := CONCAT(str1, str2, str3);              str1 := 'It is strongly dependent on the composition you entered in the previous dialog, ';              str2 := 'and on the beam energy. To trust the results of ';              str3 := 'a ZAF analysis, f(chi) should be above 0.75 for all measured elements. ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 90 THEN            BEGIN              str1 := 'The continuum cross-section vs photon energy. Has the dimensions of the continuum. ';              str2 := 'cross section, ie about E-25 for thin targets, and about E-7 for bulk targets, ';              str3 := 'and will require a lot of vertical scaling in order be visible.  ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 91 THEN            BEGIN              str1 := 'еBULK target onlyе Electron Backscatter factor vs energy. ';              str2 := ' ';              str3 := ' ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 92 THEN            BEGIN              str1 := 'еBULK target onlyе Electron Backscatter factor for continuum radiation vs energy. ';              str2 := ' ';              str3 := ' ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 93 THEN            BEGIN              str1 := 'еBULK target onlyе Stopping Power vs energy. ';              str2 := ' ';              str3 := ' ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 94 THEN            BEGIN              str1 := 'еTHIN target onlyе The peaks as they would be just before the detector window. An ';              str2 := 'absorption correction is applied by dividing the film into 50 layers and doing ';              str3 := 'a beers law correction to each layer seperatly. ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 95 THEN            BEGIN              str1 := 'еTHIN target onlyе The continuum spectrum as it would be viewed ';              str2 := 'by the detector after the electronics. Compare this to item 100 which will always appear';              str3 := 'in WORK. ';              info := CONCAT(str1, str2, str3);              str1 := 'The two spectra are identical except for the x-ray peaks. ';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 96 THEN            BEGIN              str1 := 'The continuum cross-section vs photon energy, but normalized as a Fano plot by ';              str2 := 'multiplying by the photon energy and dividing by the square of the atomic number. ';              str3 := 'This normalization is for еTHINе targets only. Since thin target continuum is strongly ';              info := CONCAT(str1, str2, str3);              str1 := 'a function of the square of Z divided by the photon energy, the normalization brings ';              str2 := 'out the other dependancies, such as take-off angle etc. ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 97 THEN            BEGIN              str1 := 'еBulk Targets Onlyе ';              str2 := 'Spectrum before detector without characteristic fluorescence. ';              str3 := '   ';              info := CONCAT(str1, str2, str3);              str1 := ' ';              str2 := '  ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          IF L = 98 THEN            BEGIN              str1 := 'The total spectrum as it would appear if a perfect detector was inside the specimen.  ';              str2 := 'The characteristic photons are all placed in one channel. This is a reasonable thing ';              str3 := 'to do since natural x-ray peaks are a few eV wide. ';              info := CONCAT(str1, str2, str3);              str1 := '';              str2 := ' ';              str3 := ' ';              info2 := CONCAT(str1, str2, str3);            END;          BackColor(WhiteColor);          ForeColor(BlackColor);          GetDialogItem(Option_Picker, I_TextBox, DType, DItem, tempRect);          SetDialogItemText(DItem, info);          GetDialogItem(Option_Picker, I_TextBox2, DType, DItem, tempRect);          SetDialogItemText(DItem, info2);        END;    END; { Procedure PutMoreInfo }  {===========================================================}  FUNCTION myFilter(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: integer): boolean;	CONST		I_Done                        = 1;		I_Cancel					  = 2;		kVisualDelay				  = 8;		kReturnKey					  = $0D;		kEnterKey					  = $03;		kEscapeKey					  = $1B; 		kPeriodKey					  = $2E;    VAR      tempRect                      : Rect;	  DType                         : integer;	  DItem                         : Handle;      temp                          : longint;      DataLen                       : integer;      str_3                         : STRING[3];      gotClicked                    : Cell;      ignore                        : boolean;	  finalTicks					: Longint;	  key							: Char;    BEGIN      myFilter := FALSE;      Do_Calc := FALSE;      IF (theEvent.what = MouseDown) THEN {Only do on a mouse click}        BEGIN          DataLen := 3;          Rect_Point := theEvent.where; {Get the point where the mouse was clicked}          GlobalToLocal(Rect_Point);          IF PtInRect(Rect_Point, Spec_chooser_rect) THEN { we are in the box of cells }            BEGIN              { the ordering of double, single click handling is important }              DoubleClick := LClick(Rect_Point, theEvent.modifiers, Spec_chooser_List);              IF DoubleClick THEN { Double click handling }                BEGIN                  str_3 := '   '; { initialization is essential }                  LGetCell(Pointer(ord(@str_3) + 1), DataLen, Spec_chooser_List^^.lastClick, Spec_chooser_List);                  str_3 := Strip_Trailing_Blanks(str_3);                  StringToNum(str_3, temp);                  itemHit := integer(temp + 100);                  myFilter := true;                  Do_Calc := true;                END;              ignore := LClick(Rect_Point, 0, Spec_chooser_List); { single click handling }              gotClicked := LLastClick(Spec_chooser_List);              str_info := '   ';              LGetCell(Pointer(ord(@str_info) + 1), DataLen, gotClicked, Spec_chooser_List);              str_info := Strip_Trailing_Blanks(str_info);              PutMoreInfo;            END; {End of PtInRect}        END	{ IF (theEvent.what = MouseDown) }	  ELSE	    CASE theEvent.what OF			keyDown, Autokey:	{user pressed a key}			BEGIN				key := Char(BAnd(theEvent.message, charCodeMask));				IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN				  BEGIN				    GetDialogItem(theDialog, I_Done, DType, DItem, tempRect);							{invert the OK button for user feedback}					HiliteControl(ControlHandle(DItem), kControlButtonPart);					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(ControlHandle(DItem), 0);					myFilter := TRUE;								{event's being handled}					itemHit := I_Done;								{return the default button}				  END;				END; { keyDown, Autokey }			END;{CASE theEvent.what}		    END;  {===========================================================}  {$S Physics_Windows3 }  PROCEDURE D_Output_Opts;    VAR      tempRect                      : Rect;      DType                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      dataBounds                    : Rect;      cSize                         : Point;      Func                          : ARRAY [0..100] OF STRING[60];      str, str1, str2, str3         : str255;      str5, str7        			: str255;    PROCEDURE Refresh_Dialog;      VAR        rTempRect                     : Rect;      BEGIN        SetPort(Option_Picker);        GetDialogItem(Option_Picker, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);        LUpdate(Option_Picker^.visRgn, Spec_chooser_List);        rTempRect := Spec_chooser_rect;        InsetRect(rTempRect, - 1, - 1);        FrameRect(rTempRect);      END;    PROCEDURE Add_LStr(theString: str255; theList: ListHandle);      VAR        theRow                        : integer;      BEGIN        IF (theList <> NIL) THEN          BEGIN            cSize.h := 0;            theRow := LAddRow(1, 300, theList);            cSize.v := theRow;            sTemp := theString;            LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);            LDraw(cSize, theList);          END;      END;    BEGIN      Option_Picker := GetNewDialog(9175, NIL, Pointer( - 1));      ShowWindow(Option_Picker);      SelectWindow(Option_Picker);      SetPort(Option_Picker);      SetRect(Spec_chooser_rect, 161, 160, 550, 365); { l,t,r,b }      tempRect := Spec_chooser_rect;      tempRect.Right := tempRect.Right - 15;      IF (tempRect.Right <= (tempRect.Left + 15)) THEN tempRect.Right := tempRect.Left + 15;      InsetRect(tempRect, - 1, - 1);      FrameRect(tempRect);      InsetRect(tempRect, 1, 1);      SetRect(dataBounds, 0, 0, 1, 0);      cSize.h := tempRect.Right - tempRect.Left;      cSize.v := 0;      Spec_chooser_List := LNew(tempRect, dataBounds, cSize, 0, Option_Picker, true, FALSE, FALSE, true);      Spec_chooser_List^^.selFlags := lOnlyOne + lNoNilHilite;      LSetDrawingMode(FALSE, Spec_chooser_List);      str1 := 'ее Single click on a list item to get more information about that item ее ';      str2 := 'If you want to display the item then enter the number at the left of the item ';      str3 := 'in one of the "Spectrum" boxes on the left side of the dialog window. ';      str7 := CONCAT(str1, str2, str3);      GetDialogItem(Option_Picker, I_TextBox, DType, DItem, tempRect);      SetDialogItemText(DItem, str7);      Func[100] := ' 100 Final Composite Spectrum ';      Add_LStr(Func[100], Spec_chooser_List);      Func[1] := '1    Qk- K Shell Ionization Cross section vs Z';      Add_LStr(Func[1], Spec_chooser_List);      Func[2] := '2    Ql- L Shell Ionization Cross section vs Z';      Add_LStr(Func[2], Spec_chooser_List);      Func[3] := '3    Qm- M Shell Ionization Cross section vs Z';      Add_LStr(Func[3], Spec_chooser_List);      Func[5] := '5    QkеFеOmega vs Z';      Add_LStr(Func[5], Spec_chooser_List);      Func[6] := '6    QlеFеOmega vs Z';      Add_LStr(Func[6], Spec_chooser_List);      Func[7] := '7    QmеFеOmega vs Z';      Add_LStr(Func[7], Spec_chooser_List);      Func[8] := '8    QkеFеOmega/At.Wt. vs Z';      Add_LStr(Func[8], Spec_chooser_List);      Func[9] := '9    QlеFеOmega/At.Wt. vs Z';      Add_LStr(Func[9], Spec_chooser_List);      Func[10] := '10    QmеFеOmega/At.Wt. vs Z';      Add_LStr(Func[10], Spec_chooser_List);      Func[11] := '11    Fk vs Z';      Add_LStr(Func[11], Spec_chooser_List);      Func[12] := '12    Fl vs Z';      Add_LStr(Func[12], Spec_chooser_List);      Func[13] := '13    Fm vs Z';      Add_LStr(Func[13], Spec_chooser_List);      Func[14] := '14    Omega K  vs Z';      Add_LStr(Func[14], Spec_chooser_List);      Func[15] := '15    Omega L  vs Z';      Add_LStr(Func[15], Spec_chooser_List);      Func[16] := '16    Omega M vs Z';      Add_LStr(Func[16], Spec_chooser_List);      Func[17] := '17    Atomic Weights vs Z';      Add_LStr(Func[17], Spec_chooser_List);      Func[18] := '18    J (keV) vs Z';      Add_LStr(Func[18], Spec_chooser_List);      Func[19] := '19    J/Z vs Z';      Add_LStr(Func[19], Spec_chooser_List);      IF Running_Bulk_Mode THEN        BEGIN          Func[20] := '20    Integral Qk/S';          Add_LStr(Func[20], Spec_chooser_List);          Func[21] := '21    Integral Ql/S';          Add_LStr(Func[21], Spec_chooser_List);          Func[22] := '22    Integral Qm/S';          Add_LStr(Func[22], Spec_chooser_List);          Func[23] := '23    S (keV) the stopping power';          Add_LStr(Func[23], Spec_chooser_List);        END;      Func[61] := '61    N edge vs Z from 1-95';      Add_LStr(Func[61], Spec_chooser_List);      Func[62] := '62    Rho (density) vs Z from 1-95';      Add_LStr(Func[62], Spec_chooser_List);      Func[63] := '63    Z/A vs Z from 1-95';      Add_LStr(Func[63], Spec_chooser_List);      Func[64] := '64    Z*Z/A vs Z from 1-95';      Add_LStr(Func[64], Spec_chooser_List);      IF Running_Thin_Mode THEN        BEGIN          Add_LStr(' ', Spec_chooser_List);          Func[58] := '58    K pk/Lcl Bkg vs Z, from 1-95';          Add_LStr(Func[58], Spec_chooser_List);          Func[59] := '59    L pk/Lcl Bkg vs Z from 1-95';          Add_LStr(Func[59], Spec_chooser_List);          Func[60] := '60    M pk/Lcl Bkg vs Z from 1-95';          Add_LStr(Func[60], Spec_chooser_List);        END;      Func[65] := '65    QkEk^2 vs U';      Add_LStr(Func[65], Spec_chooser_List);      Func[66] := '66    QlEl^2 vs U';      Add_LStr(Func[66], Spec_chooser_List);      Func[67] := '67    QmEm^2 vs U';      Add_LStr(Func[67], Spec_chooser_List);      Add_LStr(' ', Spec_chooser_List);      Func[70] := '70    Ramp vs Channel number';      Add_LStr(Func[70], Spec_chooser_List);      Func[80] := '80    Detector Response';      Add_LStr(Func[80], Spec_chooser_List);      Func[81] := '81    Detector Response after Electronics';      Add_LStr(Func[81], Spec_chooser_List);      IF Running_Bulk_Mode THEN        BEGIN	      Add_LStr(' ', Spec_chooser_List);	      Func[82] := '82    Continuum after Electronics';	      Add_LStr(Func[82], Spec_chooser_List);        END;            Func[85] := '85    Gaussian Peaks after Electronics';      Add_LStr(Func[85], Spec_chooser_List);      Func[90] := '90    Continuum cross-section Q vs E';      Add_LStr(Func[90], Spec_chooser_List);      IF Running_Thin_Mode THEN        BEGIN          Func[96] := '96    Q(continuum) * E / (Z*Z)   vs E';          Add_LStr(Func[96], Spec_chooser_List);        END;      Add_LStr(' ', Spec_chooser_List);      Func[98] := '98    Total Spectrum inside the specimen (4╣ sr)';      Add_LStr(Func[98], Spec_chooser_List);      Func[84] := '84    Spectrum inside the specimen (generated)';      Add_LStr(Func[84], Spec_chooser_List);      IF Running_Thin_Mode THEN        BEGIN		  Func[86] := '86    Spectrum after specimen absorp. (emitted)';		  Add_LStr(Func[86], Spec_chooser_List);	    END;      IF Running_Bulk_Mode THEN        BEGIN		  Func[86] := '86    Spectrum after specimen absorp. with fluor.';		  Add_LStr(Func[86], Spec_chooser_List);          Func[97] := '97    Spectrum after specimen absorp. w/o fluor.';          Add_LStr(Func[97], Spec_chooser_List);        END;		      Func[87] := '87    Spectrum inside the detector';      Add_LStr(Func[87], Spec_chooser_List);      IF Running_Thin_Mode THEN        BEGIN         { Func[94] := '94    Spectrum in front of detector with absorp corr';}	{broad peaks before absorption}          {Add_LStr(Func[94], Spec_chooser_List);}          Func[95] := '95    Continuum after electronics';	{same as 86 (emitted)}          Add_LStr(Func[95], Spec_chooser_List);        END;      Add_LStr(' ', Spec_chooser_List);      Func[88] := '88    Mu/Rho vs photon energy';      Add_LStr(Func[88], Spec_chooser_List);      IF Running_Bulk_Mode THEN        BEGIN          Func[89] := '89    f( Chi ) vs photon energy';          Add_LStr(Func[89], Spec_chooser_List);        END;      Add_LStr(' ', Spec_chooser_List);      IF Running_Bulk_Mode THEN        BEGIN          Func[91] := '91    Electron backscatter vs E';          Add_LStr(Func[91], Spec_chooser_List);          Func[92] := '92    Electron Backscatter (Continuum) vs E';          Add_LStr(Func[92], Spec_chooser_List);          Func[93] := '93    Electron Stopping Power vs E';          Add_LStr(Func[93], Spec_chooser_List);        END;      LSetDrawingMode(true, Spec_chooser_List);      cSize.v := 0;      LSetSelect(true, cSize, Spec_chooser_List);      GetDialogItem(Option_Picker, EBox_1, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S1_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S1_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_2, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S2_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S2_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_3, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S3_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S3_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_4, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S4_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S4_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_5, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S5_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S5_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_6, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S6_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S6_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_7, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S7_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S7_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_8, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numtostring(Thin_S8_Choice, str);      IF Running_Bulk_Mode THEN numtostring(Bulk_S8_Choice, str);      SetDialogItemText(DItem, str);      GetDialogItem(Option_Picker, EBox_Rslt, DType, DItem, tempRect);      IF Response_InTo_Results THEN str := '80'      ELSE        IF Running_Thin_Mode THEN numtostring(Thin_Rslt_Choice, str)        ELSE IF Running_Bulk_Mode THEN numtostring(Bulk_Rslt_Choice, str);      SetDialogItemText(DItem, str);    (*   GetDialogItem(Option_Picker, EBox_Wk, DType, DItem, tempRect);      IF Running_Thin_Mode THEN numToString(Thin_Wk_Choice, Str);      IF Running_Bulk_Mode THEN numToString(Bulk_Wk_Choice, Str);      SetDialogItemText(DItem, Str);*)      Refresh_Dialog;      ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@myFilter), itemHit);        GetDialogItem(Option_Picker, itemHit, DType, DItem, tempRect);        CItem := controlHandle(DItem);        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;            Refresh_Dialog;          END;      UNTIL ExitDialog;      Func[0] := ' ';	WITH X_SectRec^^ DO	 BEGIN      GetDialogItem(Option_Picker, EBox_1, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      str5 := '';      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S1_Choice);          if ((Thin_S1_Choice < 11) OR ((Thin_S1_Choice >= 65) AND (Thin_S1_Choice <= 67))) then begin            CASE Thin_S1_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S1_Choice >= 65) AND (Thin_S1_Choice <= 67)) then            	str := CONCAT(Func[Thin_S1_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S1_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S1_Choice];          Plt_spec[1]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, thin, ', str);        END      Else IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S1_Choice);          if ((Bulk_S1_Choice < 11) OR ((Bulk_S1_Choice >= 65) AND (Bulk_S1_Choice <= 67))) then begin            CASE Bulk_S1_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S1_Choice >= 65) AND (Bulk_S1_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S1_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S1_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S1_Choice];          Plt_spec[1]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[1]^^.Expt_Info.RefFile := false;	        GetDialogItem(Option_Picker, EBox_2, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S2_Choice);          if ((Thin_S2_Choice < 11) OR ((Thin_S2_Choice >= 65) AND (Thin_S2_Choice <= 67))) then begin            CASE Thin_S2_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S2_Choice >= 65) AND (Thin_S2_Choice <= 67)) then            	str := CONCAT(Func[Thin_S2_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S2_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S2_Choice];          Plt_spec[2]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S2_Choice);          if ((Bulk_S2_Choice < 11) OR ((Bulk_S2_Choice >= 65) AND (Bulk_S2_Choice <= 67))) then begin            CASE Bulk_S2_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S2_Choice >= 65) AND (Bulk_S2_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S2_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S2_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S2_Choice];          Plt_spec[2]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[2]^^.Expt_Info.RefFile := false;	        GetDialogItem(Option_Picker, EBox_3, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S3_Choice);          if ((Thin_S3_Choice < 11) OR ((Thin_S3_Choice >= 65) AND (Thin_S3_Choice <= 67))) then begin            CASE Thin_S3_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S3_Choice >= 65) AND (Thin_S3_Choice <= 67)) then            	str := CONCAT(Func[Thin_S3_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S3_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S3_Choice];          Plt_spec[3]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S3_Choice);          if ((Bulk_S3_Choice < 11) OR ((Bulk_S3_Choice >= 65) AND (Bulk_S3_Choice <= 67))) then begin            CASE Bulk_S3_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S3_Choice >= 65) AND (Bulk_S3_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S3_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S3_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S3_Choice];          Plt_spec[3]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[3]^^.Expt_Info.RefFile := false;      GetDialogItem(Option_Picker, EBox_4, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S4_Choice);          if ((Thin_S4_Choice < 11) OR ((Thin_S4_Choice >= 65) AND (Thin_S4_Choice <= 67))) then begin            CASE Thin_S4_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S4_Choice >= 65) AND (Thin_S4_Choice <= 67)) then            	str := CONCAT(Func[Thin_S4_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S4_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S4_Choice];          Plt_spec[4]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S4_Choice);          if ((Bulk_S4_Choice < 11) OR ((Bulk_S4_Choice >= 65) AND (Bulk_S4_Choice <= 67))) then begin            CASE Bulk_S4_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S4_Choice >= 65) AND (Bulk_S4_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S4_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S4_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S4_Choice];          Plt_spec[4]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[4]^^.Expt_Info.RefFile := false;      GetDialogItem(Option_Picker, EBox_5, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S5_Choice);          if ((Thin_S5_Choice < 11) OR ((Thin_S5_Choice >= 65) AND (Thin_S5_Choice <= 67))) then begin            CASE Thin_S5_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S5_Choice >= 65) AND (Thin_S5_Choice <= 67)) then            	str := CONCAT(Func[Thin_S5_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S5_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S5_Choice];          Plt_spec[5]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S5_Choice);          if ((Bulk_S5_Choice < 11) OR ((Bulk_S5_Choice >= 65) AND (Bulk_S5_Choice <= 67))) then begin            CASE Bulk_S5_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S5_Choice >= 65) AND (Bulk_S5_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S5_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S5_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S5_Choice];          Plt_spec[5]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[5]^^.Expt_Info.RefFile := false;      GetDialogItem(Option_Picker, EBox_6, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S6_Choice);          if ((Thin_S6_Choice < 11) OR ((Thin_S6_Choice >= 65) AND (Thin_S6_Choice <= 67))) then begin            CASE Thin_S6_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S6_Choice >= 65) AND (Thin_S6_Choice <= 67)) then            	str := CONCAT(Func[Thin_S6_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S6_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S6_Choice];          Plt_spec[6]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S6_Choice);          if ((Bulk_S6_Choice < 11) OR ((Bulk_S6_Choice >= 65) AND (Bulk_S6_Choice <= 67))) then begin            CASE Bulk_S6_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S6_Choice >= 65) AND (Bulk_S6_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S6_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S6_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S6_Choice];          Plt_spec[6]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[6]^^.Expt_Info.RefFile := false;      GetDialogItem(Option_Picker, EBox_7, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S7_Choice);          if ((Thin_S7_Choice < 11) OR ((Thin_S7_Choice >= 65) AND (Thin_S7_Choice <= 67))) then begin            CASE Thin_S7_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S7_Choice >= 65) AND (Thin_S7_Choice <= 67)) then            	str := CONCAT(Func[Thin_S7_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S7_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S7_Choice];          Plt_spec[7]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S7_Choice);          if ((Bulk_S7_Choice < 11) OR ((Bulk_S7_Choice >= 65) AND (Bulk_S7_Choice <= 67))) then begin            CASE Bulk_S7_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S7_Choice >= 65) AND (Bulk_S7_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S7_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S7_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S7_Choice];          Plt_spec[7]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[7]^^.Expt_Info.RefFile := false;      GetDialogItem(Option_Picker, EBox_8, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_S8_Choice);          if ((Thin_S8_Choice < 11) OR ((Thin_S8_Choice >= 65) AND (Thin_S8_Choice <= 67))) then begin            CASE Thin_S8_Choice of                              1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_S8_Choice >= 65) AND (Thin_S8_Choice <= 67)) then            	str := CONCAT(Func[Thin_S8_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_S8_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_S8_Choice];          Plt_spec[8]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_S8_Choice);          if ((Bulk_S8_Choice < 11) OR ((Bulk_S8_Choice >= 65) AND (Bulk_S8_Choice <= 67))) then begin            CASE Bulk_S8_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_S8_Choice >= 65) AND (Bulk_S8_Choice <= 67)) then            	str := CONCAT(Func[Bulk_S8_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_S8_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_S8_Choice];          Plt_spec[8]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ', str);        END;	  Plt_spec[8]^^.Expt_Info.RefFile := false;      GetDialogItem(Option_Picker, EBox_Rslt, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      IF Running_Thin_Mode THEN        BEGIN          StringToNum(sTemp, Thin_Rslt_Choice);          if ((Thin_Rslt_Choice < 11) OR ((Thin_Rslt_Choice >= 65) AND (Thin_Rslt_Choice <= 67))) then begin            CASE Thin_Rslt_Choice of                               1, 5, 8, 65:            	  str5 := Thin_X_Xec_List[Thin_K_Xsect];            	2, 6, 9, 66:            	  str5 := Thin_X_Xec_List[Thin_L_Xsect + 14];            	3, 7, 10, 67:            	  str5 := Thin_X_Xec_List[Thin_M_Xsect + 26];              end;	{case}            if ((Thin_Rslt_Choice >= 65) AND (Thin_Rslt_Choice <= 67)) then            	str := CONCAT(Func[Thin_Rslt_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Thin_Rslt_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Thin_Rslt_Choice];          Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, thin, ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          StringToNum(sTemp, Bulk_Rslt_Choice);          if ((Bulk_Rslt_Choice < 11) OR ((Bulk_Rslt_Choice >= 65) AND (Bulk_Rslt_Choice <= 67))) then begin            CASE Bulk_Rslt_Choice of                              1, 5, 8, 65:            	  str5 := Bulk_X_Xec_List[Bulk_K_Xsect];            	2, 6, 9, 66:            	  str5 := Bulk_X_Xec_List[Bulk_L_Xsect + 15];            	3, 7, 10, 67:            	  str5 := Bulk_X_Xec_List[Bulk_M_Xsect + 31];              end;	{case}            if ((Bulk_Rslt_Choice >= 65) AND (Bulk_Rslt_Choice <= 67)) then            	str := CONCAT(Func[Bulk_Rslt_Choice],' in units 1.0E-14 cm^2eV^2 ',str5)            else          		str := CONCAT(Func[Bulk_Rslt_Choice],' in units 1.0E-20 cm^2 ',str5);          end          else str := Func[Bulk_Rslt_Choice];          Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated, bulk, ',  str);        END;	  Plt_spec[9]^^.Expt_Info.RefFile := false;	  	  str5 := '';	  str := '';      (*GetDialogItem(Option_Picker, EBox_Wk, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);*)	END;	{WITH X_SectRec^^ DO}      DisposeDialog(Option_Picker);    END;  PROCEDURE D_Thin_X_Sects;    CONST      I_Accept                      = 1;      I_Casnati                     = 2;      I_Schreiber_Wimms3            = 3;      I_Mott_Massey                 = 4;      I_Kolbenstvedt                = 5;      I_Bethe_Fermi_Zalusek6        = 6;      I_Fabre                       = 7;      I_Sigma_K                     = 8;      I_Lotz_1_25                   = 9;      I_Green_Cosslett              = 10;      I_Worthington_Tomlin          = 11;      I_Gryzinski                   = 12;      I_Brown                       = 13;      I_Drawin                      = 14;      I_Jakoby	{I_Spare8}          = 15;            I_Spare7                      = 16;             { disabled, "е" }      I_Spare6                      = 17;             { disabled, "е" }      I_Spare5				        = 18;                   I_Casnati_L	{I_Spare5}      = 19;      I_Bethe_Fiori            		= 20;{ enabled, "Bethe (Fiori) " }      I_Schreiber_Wimm              = 21;      I_Bethe_Fermi_Zalusek21       = 22;      I_Brown24                     = 23;      I_Bethe_Powell                = 24;      I_Sigma_L                     = 25;      I_Fabre28      {I_Fabre28}    = 26;                         I_Spare12                     = 27;             { disabled, "е" }      I_Spare11                     = 28;             { disabled, "е" }      I_Spare13                     = 29;             { disabled, "е" }            I_Casnati_M	{I_Spare10}     = 30;                   I_Schreiber_Wimms29           = 31;      I_Brown35                     = 32;             { enabled, "Bethe " }      I_Bethe_Fiori_M               = 33;            I_Spare14                     = 34;             { disabled, "е" }      I_Spare15                     = 35;             { disabled, "е" }      I_Marshall_Hall               = 36;      I_Kirkpatrick_Wiedmann        = 37;      I_Kirkpatrick_Wiedman         = 38;      I_Modified_Bethe_Heitle       = 39;            I_Fluorescent_Yields_as       = 40;             { disabled, "е" }      I_Fitted_Fluorescent_Yi       = 41;             { disabled, "е" }      I_Load_Defaults               = 55;    VAR      ExitDialog                    : boolean;      tempRect                      : Rect;      DType                         : integer;      Index                         : integer;      DItem                         : Handle;      CItem, CTempItem              : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      GetSelection                  : DialogPtr;      str                           : str255;    	LABEL 100;    PROCEDURE Refresh_Dialog;      BEGIN        SetPort(GetSelection);		GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN      GetSelection := GetNewDialog(9172, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      { Grey out the unused radio buttons }      GetDialogItem(GetSelection, I_Kirkpatrick_Wiedman, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);    100:      FOR Index := I_Casnati TO I_Jakoby DO { Turn on the Preset K button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          GetDialogItem(GetSelection, Thin_K_Xsect, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      { #25, I_Fabre28, is е and disabled }      FOR Index := I_Spare7 TO I_Fabre28 DO { 16-25 Turn on the Preset L button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          Index := Thin_L_Xsect + I_Spare7 - 2;          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      { #26-28, I_Spare12 - I_Spare9, are е and disabled }      FOR Index := I_Spare12 TO I_Bethe_Fiori_M DO {28-31 Turn on the Preset M button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          Index := Thin_M_Xsect + I_Spare12 - 1;          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      { #32-33, I_Spare14 - I_Spare13, are е and disabled }      FOR Index := I_Spare14 TO I_Modified_Bethe_Heitle DO {34-37 Turn on the Preset Cont button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          Index := Thin_CONT_Xsect + I_Spare14 - 2;          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      { #38-39, I_Fluorescent_Yields_as - I_Fitted_Fluorescent_Yi, are е and disabled }     (*  FOR Index := I_Fluorescent_Yields_as TO I_Fitted_Fluorescent_Yi DO    {38-39 Turn on the Preset Fluor button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := POINTER(DItem);          IF Thin_Fluor_Yield = Index - I_Fluorescent_Yields_as + 2 THEN SetControlValue(CItem, 1)          ELSE SetControlValue(CItem, 0);        END;*)      GetDialogItem(GetSelection, 51, DType, DItem, tempRect);      RealToString(Thin_CONT_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str); {Continuum scale factor}      GetDialogItem(GetSelection, 52, DType, DItem, tempRect);      RealToString(Thin_M_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str); {M scale factor}      GetDialogItem(GetSelection, 53, DType, DItem, tempRect);      RealToString(Thin_L_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str); {L scale factor}      GetDialogItem(GetSelection, 54, DType, DItem, tempRect);      RealToString(Thin_K_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str); {K scale factor}      Refresh_Dialog;      ExitDialog := FALSE;      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;          END;        IF (itemHit = I_Load_Defaults) THEN          BEGIN            BeepBeep;            Thin_K_Xsect := 7;            Thin_L_Xsect := 6;            Thin_M_Xsect := 7;            Thin_CONT_Xsect := 7;            Thin_CONT_Xsect_BG := 17;            Thin_Fluor_Yield := 3;            GOTO 100;          END;        IF (itemHit >= I_Casnati) AND (itemHit <= I_Jakoby) THEN          BEGIN            FOR Index := I_Casnati TO I_Jakoby DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                CTempItem := ControlHandle(DItem);                SetControlValue(CTempItem, 0);              END;            SetControlValue(CItem, 1);          END;        IF (itemHit >= I_Spare7) AND (itemHit <= I_Fabre28) THEN          BEGIN            FOR Index := I_Spare7 TO I_Fabre28 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                CTempItem := ControlHandle(DItem);                SetControlValue(CTempItem, 0);              END;            SetControlValue(CItem, 1);          END;        IF (itemHit >= I_Spare12) AND (itemHit <= I_Bethe_Fiori_M) THEN          BEGIN            FOR Index := I_Spare12 TO I_Bethe_Fiori_M DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                CTempItem := ControlHandle(DItem);                SetControlValue(CTempItem, 0);              END;            SetControlValue(CItem, 1);          END;        IF (itemHit >= I_Spare14) AND (itemHit <= I_Modified_Bethe_Heitle) THEN          BEGIN            FOR Index := I_Spare14 TO I_Modified_Bethe_Heitle DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                CTempItem := ControlHandle(DItem);                SetControlValue(CTempItem, 0);              END;            SetControlValue(CItem, 1);          END;      (*  IF (itemHit >= I_Fluorescent_Yields_as) AND (itemHit <= I_Fitted_Fluorescent_Yi) THEN          BEGIN            FOR Index := I_Fluorescent_Yields_as TO I_Fitted_Fluorescent_Yi DO {Clear all other radios}              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                CTempItem := ControlHandle(DItem);                SetControlValue(CTempItem, 0);              END;            SetControlValue(CItem, 1);          END;*)      UNTIL ExitDialog;      Index := I_Casnati;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_Jakoby);      temp := Index - I_Casnati + 1;      { The buttons top to bottom go 7,8,9,10,11,12,13,14,6,5,4,3,2 }      Thin_K_Xsect := temp;      Index := I_Spare7;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_Fabre28);      temp := Index - I_Spare7 + 1;      { The buttons top to bottom go 12...2 ditl's go 25 to 15 top to bottom}      Thin_L_Xsect := temp;	  if (Thin_L_Xsect = 10 ) then Putmessage('Bethe-Powell is only valid for overvoltages > 1.67', '', '', '');      Index := I_Spare12;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_Bethe_Fiori_M);      temp := Index - I_Spare12 {+ 1};      { The buttons top to bottom go 7...2 }      Thin_M_Xsect := temp;      Index := I_Spare14; { 34 }      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_Modified_Bethe_Heitle);      temp := Index - I_Spare14 + 1;      { The buttons top to bottom go 7...2 }      Thin_CONT_Xsect := temp;     (* Index := I_Fluorescent_Yields_as;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_Fitted_Fluorescent_Yi);      temp := Index - I_Fluorescent_Yields_as + 1;      { The buttons top to bottom go 3, 2 }      Thin_Fluor_Yield := temp;*)      GetDialogItem(GetSelection, 51, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get Continuum Scale Factor}      Thin_CONT_ScaleFactor := MyStr2Num(sTemp);      GetDialogItem(GetSelection, 52, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get M Scale Factor}      Thin_M_ScaleFactor := MyStr2Num(sTemp);      GetDialogItem(GetSelection, 53, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get L Scale Factor}      Thin_L_ScaleFactor := MyStr2Num(sTemp);      GetDialogItem(GetSelection, 54, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get K Scale Factor}      Thin_K_ScaleFactor := MyStr2Num(sTemp);      DisposeDialog(GetSelection);    END; {End of procedure}  PROCEDURE D_Bulk_X_Sects;    CONST                                             {These are the item numbers for controls in the Dialog}      I_Accept                      = 1;      I_Drawin                      = 2;      I_Brown                       = 3;      I_Gryzinski                   = 4;      I_Worthington_Tomlin          = 5;      I_Green_Cosslett              = 6;      I_Lotz_1_25                   = 7;      I_Sigma_K                     = 8;      I_Fabre                       = 9;      I_Casnati                     = 10;      I_Kolbenstvedt                = 11;      I_Mott_Massey                 = 12;      I_Jakoby	{I_Spare1}          = 13;      I_Pouchou_Pichoir	{I_Spare2}  = 14;      I_Pouchou	{I_Spare15}         = 15;            I_Sigma_L                     = 18;      I_Bethe_Powell                = 19;      I_Brown18                     = 20;      I_Fiori_Myklebust 			= 21;      I_Casnati_L 			        = 22;      I_Pouchou_Pichoir_L           = 23;      I_Pouchou_L                   = 24;      I_Jakoby_L                    = 25;      I_Green_Cosslett_L            = 26;            I_Bethe_Fiori_M               = 33;      I_Bethe	                    = 34;      I_Casnati_M	{I_Spare10}     = 35;            I_Pouchou_Pichoir_M           = 36;      I_Pouchou_M                   = 37;      I_Rez							= 38;      I_Gryzinski_M					= 39;      I_Fabre_M						= 40;            I_Spare14                     = 32;      I_Small_Kramers_Normal        = 47;      I_Kramers                     = 48;      I_Lifshin                     = 49;      I_Rao_Sahib_Wittry            = 51;      I_Hehenkamp_Bocker            = 41;            I_Fluorescent_Yeilds_as       = 42;      I_Fitted_Fluorescent_Ye       = 43;      I_Load_Defaults               = 57;	  {constants 53, 54, 55 are bulk scaling factors}    VAR      ExitDialog                    : boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : integer;      Index                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      str                           : str255;        LABEL      100;    PROCEDURE Refresh_Dialog;      BEGIN        SetPort(GetSelection);		GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN      GetSelection := GetNewDialog(9173, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      { Grey out the unused radio buttons }     (* GetDialogItem(GetSelection, I_Spare6, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare5, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare4, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);*)      (*GetDialogItem(GetSelection, I_Spare3, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);*)     (* GetDialogItem(GetSelection, I_Spare2, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);*)      (*GetDialogItem(GetSelection, I_Spare1, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);*)     (* GetDialogItem(GetSelection, I_Fitted_Fluorescent_Ye, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Fluorescent_Yeilds_as, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Hehenkamp_Bocker, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Smith_Gold, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Green_dyson, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare15, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare14, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare12, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare11, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare16, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare9, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare8, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);      GetDialogItem(GetSelection, I_Spare7, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);*)    100:      FOR Index := 2 TO 15 DO { Turn on the Preset K button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          GetDialogItem(GetSelection, Bulk_K_Xsect, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      FOR Index := 18 TO 26 DO { Turn on the Preset L button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          Index := Bulk_L_Xsect + 18 - 3;          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      FOR Index := 33 TO 40 DO { Turn on the Preset M button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          Index := Bulk_M_Xsect + 33 - 2;          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);      FOR Index := 47 TO 51 DO { Turn on the Preset CONT button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 0);        END;          Index := Bulk_CONT_Xsect + 47 - 4;          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          SetControlValue(CItem, 1);     (* FOR Index := I_Fluorescent_Yeilds_as TO I_Fitted_Fluorescent_Ye DO { Turn on the Preset FY button }        BEGIN          GetDialogItem(GetSelection, Index, DType, DItem, tempRect);          CItem := ControlHandle(DItem);          IF Bulk_Fluor_Yield = Index - I_Fluorescent_Yeilds_as + 2 THEN SetControlValue(CItem, 1)          ELSE SetControlValue(CItem, 0);        END;*)      GetDialogItem(GetSelection, 53, DType, DItem, tempRect);      RealToString(Bulk_K_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, 54, DType, DItem, tempRect);      RealToString(Bulk_L_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, 55, DType, DItem, tempRect);      RealToString(Bulk_M_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, 56, DType, DItem, tempRect);      RealToString(Bulk_CONT_ScaleFactor, 4, 2, str);      SetDialogItemText(DItem, str);      Refresh_Dialog;      ExitDialog := FALSE;      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        {Handle it real time}        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;          END;        IF (itemHit = I_Load_Defaults) THEN          BEGIN            BeepBeep;            Bulk_K_Xsect := 9;            Bulk_L_Xsect := 6;            Bulk_M_Xsect := 2;            Bulk_CONT_Xsect := 4;            Bulk_CONT_Xsect_BG := 16;            Bulk_Fluor_Yield := 3;            GOTO 100;          END;        IF (itemHit >= 2) AND (itemHit <= 15) THEN	{2...14}          BEGIN            FOR Index := 2 TO 15 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;        IF (itemHit >= 18) AND (itemHit <= 26) THEN	{15...25}          BEGIN            FOR Index := 18 TO 26 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;        IF (itemHit >= 33) AND (itemHit <= 40) THEN	{26...31}          BEGIN            FOR Index := 33 TO 40 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;        IF (itemHit >= 47) AND (itemHit <= 51) THEN	{32...41}          BEGIN            FOR Index := 47 TO 51 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;       (* IF (itemHit >= I_Fluorescent_Yeilds_as) AND (itemHit <= I_Fitted_Fluorescent_Ye) THEN          BEGIN            FOR Index := I_Fluorescent_Yeilds_as TO I_Fitted_Fluorescent_Ye DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;*)      UNTIL ExitDialog;      Index := 1;      REPEAT        Index := Index + 1;        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);      UNTIL (temp <> 0) OR (Index > 15);      { The buttons top to bottom go 9,8,7,6,5,4,3,2,10,11,12,13,14 }      Bulk_K_Xsect := Index;      Index := 17;      REPEAT        Index := Index + 1;        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);      UNTIL (temp <> 0) OR (Index > 26);      temp := Index - 17 + 2;      { The buttons top to bottom go 3...12 }      Bulk_L_Xsect := temp;	  if (Bulk_L_Xsect = 4 ) then Putmessage('Bethe-Powell is only valid for overvoltages > 1.67', '', '', '');	        Index := 32;	{26...31}      REPEAT        Index := Index + 1;        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);      UNTIL (temp <> 0) OR (Index > 40);      temp := Index - 32 + 1;      { The buttons top to bottom go 2...7 }      Bulk_M_Xsect := temp;      Index := 46;	{32...41}      REPEAT        Index := Index + 1;        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);      UNTIL (temp <> 0) OR (Index > 51);      temp := Index - 46 + 3;      { The buttons top to bottom go 4,5,6,7,8,9,3,2 }      Bulk_CONT_Xsect := temp;    (*  Index := I_Fluorescent_Yeilds_as;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        temp := GetControlValue(CItem);        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_Fitted_Fluorescent_Ye);      temp := Index - I_Fluorescent_Yeilds_as + 1;      { The buttons top to bottom go 3, 2 }      Bulk_Fluor_Yield := temp;*)      GetDialogItem(GetSelection, 53, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get K Scale Factor}      Bulk_K_ScaleFactor := MyStr2Num(sTemp);      GetDialogItem(GetSelection, 54, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get L Scale Factor}      Bulk_L_ScaleFactor := MyStr2Num(sTemp);      GetDialogItem(GetSelection, 55, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get M Scale Factor}      Bulk_M_ScaleFactor := MyStr2Num(sTemp);      GetDialogItem(GetSelection, 56, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp); {Get CONT Scale Factor}      Bulk_CONT_ScaleFactor := MyStr2Num(sTemp);      DisposeDialog(GetSelection);    END; {End of procedure}  PROCEDURE Generate_Help;	{Generate Help}    VAR      tempRect                      : Rect;      offset                        : integer;      Left                          : integer;      Top                           : integer;      n                             : integer;      G_Help                        : DialogPtr;      itemHit                       : integer;      DType                         : integer;      DItem                         : Handle;     { CItem                         : controlhandle;}      str                           : str255;        CONST      G_Accept                      = 1;    BEGIN      {[f-]}G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString('This Dialog will "generate" a spectrum from first principals. To do this it is required');	  n := n+1; moveto(Left,Top + n*offset);str := 'that you enter all the pertinant information about your hypothetical specimen and your ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'hypothetical instrument. There are many variations on the theme. To begin, note that';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'concentrations can be entered in several ways. Entering in one scale and then pushing the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'radio button of another will convert your entry. The program only stores and calculates';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'in weight fraction. еееBEWAREеее Remember your chemistry, if the sum is not very near (<1%) ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'then conversions between weight and atomic fraction will be incorrect. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You may input oxides by entering the formula (AL2O3, etc.). This will also automatically';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'supply the valences necessary for stoichiometric oxide calculations. A database of compositions';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'may be defined. Enter a composition, name it in the name box and insert it in your database file.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To retrieve a composition: open the file, double click the name and the composition will appear.';DrawString(str); n := n+2; moveto(Left,Top + n*offset); str := 'The "spectrum" can be "viewed" at various locations such as inside the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'specimen, inside the detector etc. In addition, all of the physics and mathematics used to';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'generate the spectrum can be "viewed". All of these choices can be found in the  button';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'ее Output Choices ее. What ever you write into one of the 10 spectrum choices';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'will attach header information. еееWARNINGеееWARNINGеее if you leave the header information';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'with whatever was there you will get whatever was there, permantly attached to your new';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'creation.';DrawString(str); n := n+2; moveto(Left,Top + n*offset);str := 'The "Pick Your Physics" button allows choices of cross sections. These are cross sections ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'currently in the literature. еSome of them are wrong!!!. They are here because they are there.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'By choosing these cross sections and critically comparing their "spectra" to real spectra';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'we can weed out the bad ones. ееUSE ONLY THE DEFAULTS UNLESS YOU KNOW WHAT YOU ARE DOINGее';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);{[f+]}      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);        IF (itemHit = G_Accept) THEN          BEGIN            ExitDialog := true;          END;      UNTIL ExitDialog;      ExitDialog := FALSE;      DisposeDialog(G_Help);      beginupdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);    END; {End of G_Help procedure}  PROCEDURE PutGInfo;    VAR      L                             : longint;      info                          : str255;      info2                         : str255;      DType                         : integer;      DItem                         : Handle;    BEGIN      StringToNum(str_info, L); {L is the "number" of the list item, ie, position }      IF L < 1 THEN L := 1;      IF L > 999 THEN L := 999;      info := ' ';      info2 := ' ';      IF (L >= 1) AND (L <= 999) THEN        BEGIN          numtostring(L, info);          info2 := ' ';          {putmessage('The item number in the list is ',info,'','');}          GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);          SetDialogItemText(DItem, info);        END;    END; { Procedure PutGInfo }  PROCEDURE Values_to_Work;    BEGIN      WITH theValues DO        BEGIN          Plt_spec[10]^^.Expt_Info.number_of_channels := number_of_channels;          Plt_spec[10]^^.Expt_Info.dE := dE;          Plt_spec[10]^^.Expt_Info.BN_Thickness := BN_Thickness;          Plt_spec[10]^^.Expt_Info.SiN_Thickness := SiN_Thickness;          Plt_spec[10]^^.Expt_Info.Mylar := Mylar;          Plt_spec[10]^^.Expt_Info.Moxtek := Moxtek;          Plt_spec[10]^^.Expt_Info.Paralene := Paralene;          Plt_spec[10]^^.Expt_Info.Diamond := Diamond;          Plt_spec[10]^^.Expt_Info.Quantum := Quantum;          Plt_spec[10]^^.Expt_Info.Detector_Area := Detector_Area;		  Plt_spec[10]^^.Expt_Info.Detector.ID := Detector.ID;		  Plt_spec[10]^^.Expt_Info.Detector.Spec := Detector.Spec;          Plt_spec[10]^^.Expt_Info.Si_Resolution := Si_Resolution;          Plt_spec[10]^^.Expt_Info.WDS_Resolution := WDS_Resolution;          Plt_spec[10]^^.Expt_Info.Detector_Thickness := Detector_Thickness;          Plt_spec[10]^^.Expt_Info.Si_Thickness := Si_Thickness;          Plt_spec[10]^^.Expt_Info.Au_Thickness := Au_Thickness;          Plt_spec[10]^^.Expt_Info.Be_Thickness := Be_Thickness;          Plt_spec[10]^^.Expt_Info.Ice_Thickness := Ice_Thickness;          Plt_spec[10]^^.Expt_Info.C_Thickness := C_Thickness;          Plt_spec[10]^^.Expt_Info.Al_Thickness := Al_Thickness;          Plt_spec[10]^^.Expt_Info.Azimuth := Azimuth;          Plt_spec[10]^^.Expt_Info.Elevation := Elevation;          Plt_spec[10]^^.Expt_Info.Detector_tilt := Detector_tilt;          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle := Take_Off_Angle;          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance := Spec_Detector_Distance;          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt := Y_Tilt;          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt := X_Tilt;          Plt_spec[10]^^.Expt_Info.kV := theValues.kV;        END; { WITH...}    END; { PROCEDURE Values_to_Work }  {$S Physics_Windows4}  {еееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееееее}    PROCEDURE D_Generate_Input;    CONST      G_Accept                      = 1;      G_Cancel                      = 2;      G_zero                        = 3;      Name_New_Database             = 4;              {Make a Database}      SiLi_Params                   = 6;      G_Choose_X_Sects              = 7;      G_KV                          = 8;      G_Faraday                     = 9;      G_Time                        = 10;      G_Density                     = 11;      G_Thickness                   = 12;      I_Z1                          = 13;      I_Value                       = 14;      I_Help                        = 43;      I_Quantity                    = 45;      G_Choose_Extended             = 51;      R_Wt_Fr                       = 52;      R_Atm_Fr                      = 53;      R_Num_Atms                    = 54;      R_mMol_Dry_Wt                 = 55;      R_Ox_Fr                       = 56;      R_Valence                     = 57;      Insert_in_Database            = 59;             {Insert Item}      Remove_Item                   = 60;             {Remove Item}      { DataBase_title    = 61; this item is in the global constant list at top}      Retreive_Item                 = 62;             {Load a Database}      T_Sum                         = 66;      T_Diff_From_1                 = 67;      T_Average_Z                   = 68;      I_EDS                         = 69;      I_WDS                         = 70;      I_Display_Parameters          = 71;      I_Load_Header_Info            = 72;      I_Clear_Output_Pts			= 73;    VAR      ExitDialog                    : boolean;      tempLong                      : longint;      tempRect                      : Rect;      DType                         : integer;      Index, nn                     : integer;      DItem                         : Handle;      CItem			                : controlhandle;      XDItem                        : Handle;      XDType                        : integer;      sTemp                         : str255;      itemHit                       : integer;      OldItem                       : integer;      temp                          : integer;      tempReal                      : real {double_t};      Chem_Scale                    : integer;      Sum                           : real {double_t};      Smallest_Wt_By_A              : real {double_t};      Wt_By_A                       : ARRAY [1..15] OF real {double_t};      Sum_Wt_By_A                   : real {double_t};      Formula_Wt                    : real {double_t};      Num_Elements                  : integer;      Average_Z                     : real {double_t};      thestr                        : str255;      theOxWeightF                  : ARRAY [1..15] OF real {double_t};      theValence                    : ARRAY [1..15] OF longint;      theOxStr                      : ARRAY [1..15] OF Str_5;      G_Concentration               : ARRAY [1..15] OF real {double_t};      G_At_Num                      : ARRAY [1..15] OF integer;      cSize                         : Point;          {Pointer to a cell in a list}      dataBounds                    : Rect;      str, str1, str2, str7         : str255;      s5Temp                        : Str_5;      strt_str              		: str255;      Logic_Over_ride               : boolean;	{a spare}    PROCEDURE Refresh_Dialog;      VAR        rTempRect                     : Rect;      BEGIN        ShowWindow(G_Input);        SelectWindow(G_Input);        SetPort(G_Input);        GetDialogItem(G_Input, G_Accept, DType, DItem, rTempRect);        PenSize(3, 3);        InsetRect(rTempRect, - 4, - 4);        FrameRoundRect(rTempRect, 16, 16);        PenSize(1, 1);        LUpdate(G_Input^.visRgn, cList);        rTempRect := Rect_I_List1;        InsetRect(rTempRect, - 1, - 1);        FrameRect(rTempRect);      END;    PROCEDURE Add_LStr(theString: str255; theList: ListHandle);      VAR        theRow                        : integer;      BEGIN        IF (theList <> NIL) THEN          BEGIN            cSize.h := 0;            theRow := LAddRow(1, 200, theList);            cSize.v := theRow;            sTemp := theString;            LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);            LDraw(cSize, theList);          END;      END;    PROCEDURE SetGValues; { G_Concentration is always wtF...convert to desired units}      VAR        nn                     : integer;      BEGIN {PROCEDURE SetValues; num_elements is known}        FOR nn := Num_Elements TO 14 DO          BEGIN            GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, '0');            GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, '0');          END;        {myform.style := fixedDecimal;        myform.digits := 6;}        IF Chem_Scale = 2 THEN {Num_Elements is #of elements}          BEGIN            IF (Num_Elements <= 0) THEN exit(SetGValues);     { Call Procedure WeightF_to_Ox to convert theWeightF[1..n] to        theOxWeightF[1..m]:m = n - 1, and to make theOxStr[1..m]. }            FOR nn := 1 TO Num_Elements - 1 DO              BEGIN                WtFrac_to_Oxide(theValence[nn], nn, G_At_Num[nn], s5Temp, G_Concentration[nn], tempReal);                theOxStr[nn] := s5Temp;                theOxWeightF[nn] := tempReal;              END;            theOxWeightF[Num_Elements] := 0.0;            FOR nn := 0 TO Num_Elements - 2 DO              BEGIN                GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, theOxStr[nn + 1]);                tempReal := theOxWeightF[nn + 1];                {Mynum2str} RealToString(tempReal, 5, 5, thestr); {tempReal is double_t,thestr is a decstr}                GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, thestr);              END; {FOR nn := 0...}            nn := Num_Elements - 1;            sTemp := '0';            GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, sTemp);            GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, sTemp);          END { IF Chem_Scale = 2...}        ELSE          BEGIN            FOR nn := 0 TO Num_Elements - 1 DO              BEGIN                GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                IF G_At_Num[nn + 1] = 8 THEN sTemp := '8'                ELSE                  BEGIN                    IF (G_At_Num[nn + 1] < 1) OR (G_At_Num[nn + 1] > 95) THEN                      BEGIN                        numtostring(G_At_Num[nn + 1], str);                        putmessage('Atomic number out of range, must be 1 - 95', str, '', '');                        exit(SetGValues);                      END;                    sTemp := a^.sym[G_At_Num[nn + 1]];                  END;                SetDialogItemText(DItem, sTemp);              END; {FOR nn := 0...}            IF (Chem_Scale = 3) THEN {# of atoms }              BEGIN { Pre calculate the needed quantities }                Wt_By_A[1] := G_Concentration[1] / At_Wt^^.Value[G_At_Num[1]];                Smallest_Wt_By_A := Wt_By_A[1];                FOR nn := 2 TO Num_Elements DO                  BEGIN {find nn of smallest # of atoms}                    Wt_By_A[nn] := G_Concentration[nn] / At_Wt^^.Value[G_At_Num[nn]];                    IF Wt_By_A[nn] < Smallest_Wt_By_A THEN Smallest_Wt_By_A := Wt_By_A[nn];                  END;              END {IF Chem_Scale = 3...}            ELSE              IF Chem_Scale = 5 THEN { atomic fract }                BEGIN { Pre calculate the needed quantities }                  Sum_Wt_By_A := 0.0;                  FOR nn := 1 TO Num_Elements DO                    BEGIN                      Wt_By_A[nn] := G_Concentration[nn] / At_Wt^^.Value[G_At_Num[nn]];                      Sum_Wt_By_A := Sum_Wt_By_A + Wt_By_A[nn];                    END;                END; {IF (Chem_Scale = 5)...}            FOR nn := 0 TO Num_Elements - 1 DO              BEGIN                GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                temp := G_At_Num[nn + 1];                IF temp < 1 THEN temp := 1;                IF temp > 95 THEN temp := 95;                tempReal := 0.0; { double_t variable }                IF temp = 8 THEN SetDialogItemText(DItem, '8')                ELSE                  BEGIN                    SetDialogItemText(DItem, a^.sym[temp]);                  END;                IF Chem_Scale = 6 THEN                  BEGIN                    numtostring(theValence[nn + 1], sTemp);                    GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                    SetDialogItemText(DItem, sTemp);                  END                ELSE                  BEGIN { IF Chem_Scale <> 6...}                    IF Chem_Scale = 1 THEN tempReal := G_Concentration[nn + 1]                    ELSE                      IF Chem_Scale = 3 THEN tempReal := (Wt_By_A[nn + 1] / Smallest_Wt_By_A)                      ELSE                        IF Chem_Scale = 4 THEN                          BEGIN                            temp := G_At_Num[nn + 1];                            tempReal := (G_Concentration[nn + 1] * 1E6) / At_Wt^^.Value[temp];                          END {else IF Chem_Scale = 4 ...}                        ELSE IF Chem_Scale = 5 THEN tempReal := Wt_By_A[nn + 1] / Sum_Wt_By_A; {atom fract}                    { see SANE p25}                    {Mynum2str} RealToString(tempReal, 5, 5, thestr); {tempReal is double_t,thestr is a decstr}                    GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                    SetDialogItemText(DItem, thestr);                  END; { IF Chem_Scale <> 6...}              END; { for nn := 0 to 0 TO Num_Elements - 1 do... }          END; {IF Chem_Scale <> 2...}      END; {SetGValues; ...Generate}    PROCEDURE GetGValues; {G_Concentration should always hold wtfraction}      VAR        nn, ZValue                    : integer;        WValue                        : real {double_t};        str                           : str255;      BEGIN        Formula_Wt := 0.0;        IF (Chem_Scale <> 6) THEN Num_Elements := 0;        IF (Chem_Scale = 2) THEN          BEGIN            FOR nn := 0 TO 14 DO              BEGIN                GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                WValue := MyStr2Num(sTemp); {convert the string to a real value}                GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                GetDialogItemText(DItem, str); {to start, str is '0' ie zero }                str := Strip_Trailing_Blanks(str); { trim the space after a single char replace }                IF (ord(str[1]) <> 48) AND (WValue > 0) THEN                  BEGIN                    Num_Elements := Num_Elements + 1;                    IF Num_Elements > 15 THEN Num_Elements := 15;                    theOxStr[Num_Elements] := str;                    theOxWeightF[Num_Elements] := WValue;                  END                ELSE                  BEGIN                    theOxWeightF[nn + 1] := 0.0;                    theOxStr[nn + 1] := str;                  END;                theValence[nn + 1] := 0; {give this values in Oxide_to_Z routine}              END; { FOR nn := 0 TO 14...}            Num_Elements := Num_Elements + 1;            IF Num_Elements > 15 THEN Num_Elements := 15; {include oxygen}            {Call the routine Oxide_to_Z to get the z,wtfs and valences}            G_Concentration[Num_Elements] := 0.0;            FOR nn := 1 TO Num_Elements - 1 DO              BEGIN                s5Temp := theOxStr[nn];                Oxide_to_WtFrac(s5Temp, nn, G_At_Num[nn], theValence[nn], G_Concentration[nn], WValue, theOxWeightF[nn]);                G_Concentration[Num_Elements] := G_Concentration[Num_Elements] + WValue;              END;            G_At_Num[Num_Elements] := 8;            theValence[Num_Elements] := 2;          END { IF (Chem_Scale = 2)...}        ELSE          IF (Chem_Scale = 6) THEN {we already know the Z's}            FOR nn := 0 TO Num_Elements - 1 DO              BEGIN                GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                StringToNum(sTemp, theValence[nn + 1]);              END { IF (Chem_Scale = 6)...}          ELSE            BEGIN              FOR nn := 0 TO 14 DO                BEGIN                  GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  sTemp := Strip_Trailing_Blanks(sTemp); { trim the space after a single char replace }                  IF sTemp = '8' THEN ZValue := 8                  ELSE ZValue := AtSymbol_To_Znum(sTemp);                  GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  WValue := MyStr2Num(sTemp); {convert the string to a real value}                  {ее}                  IF (ZValue > 0) AND (WValue > 0) THEN                    BEGIN                      Num_Elements := Num_Elements + 1;                      IF Num_Elements > 15 THEN Num_Elements := 15;                      G_At_Num[Num_Elements] := ZValue;                      G_Concentration[Num_Elements] := WValue;                    END                  ELSE                    BEGIN                      G_Concentration[nn + 1] := 0.0;                      G_At_Num[nn + 1] := 0;                    END;                END; { FOR nn := 0 TO 14...}              IF (Chem_Scale = 3) THEN { # of atoms }                BEGIN                  FOR nn := 0 TO Num_Elements - 1 DO                    BEGIN                      temp := G_At_Num[nn + 1];                      G_Concentration[nn + 1] := G_Concentration[nn + 1] * (At_Wt^^.Value[temp]);                      Formula_Wt := Formula_Wt + G_Concentration[nn + 1];                    END; {FOR nn := 0...}                  FOR nn := 0 TO Num_Elements - 1 DO                    G_Concentration[nn + 1] := G_Concentration[nn + 1] / Formula_Wt;                END { IF (Chem_Scale = 3) }              ELSE                IF (Chem_Scale = 4) THEN {mMole/kgdrywt}                  FOR nn := 0 TO Num_Elements - 1 DO                    BEGIN                      temp := G_At_Num[nn + 1];                      G_Concentration[nn + 1] := G_Concentration[nn + 1] * At_Wt^^.Value[temp] * 1E-6;                    END {IF (Chem_Scale = 4) ... FOR nn := 0 ...}                ELSE                  IF (Chem_Scale = 5) THEN { atomic fract }                    BEGIN                      Sum_Wt_By_A := 0.0;                      FOR nn := 0 TO Num_Elements - 1 DO                        BEGIN                          temp := G_At_Num[nn + 1];                          Wt_By_A[nn + 1] := G_Concentration[nn + 1] * At_Wt^^.Value[temp];                          Sum_Wt_By_A := Sum_Wt_By_A + Wt_By_A[nn + 1];                        END;                      FOR nn := 0 TO Num_Elements - 1 DO                        BEGIN                          G_Concentration[nn + 1] := Wt_By_A[nn + 1] / Sum_Wt_By_A;                        END;                    END; {IF (Chem_Scale = 5)...}            END; {if chem_scale<>6}      END; { Procedure GetGValues }    PROCEDURE Do_GSums;            VAR        nn                            : integer;      BEGIN        Sum := 0.0;        Average_Z := 0.0;  {We always know what G_Concentration,etc and, IF (Chem_Scale = 2),   we know OxWeightF, OxStr etc }        IF (Num_Elements <= 0) THEN exit(Do_GSums);        FOR nn := 0 TO Num_Elements - 1 DO          BEGIN {if we read strings then no math needed}            IF (Chem_Scale = 2) THEN Sum := Sum + theOxWeightF[nn + 1]            ELSE              IF (Chem_Scale = 5) THEN                BEGIN                  GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  Sum := Sum + MyStr2Num(sTemp);                END              ELSE Sum := Sum + G_Concentration[nn + 1];            Average_Z := Average_Z + G_Concentration[nn + 1] * G_At_Num[nn + 1];          END;        GetDialogItem(G_Input, T_Sum, XDType, XDItem, tempRect);        RealToString(Sum, 5, 5, str);        SetDialogItemText(XDItem, str);        GetDialogItem(G_Input, T_Diff_From_1, XDType, XDItem, tempRect);        RealToString(1 - Sum, 5, 5, str);        SetDialogItemText(XDItem, str);        GetDialogItem(G_Input, T_Average_Z, XDType, XDItem, tempRect);        RealToString(Average_Z, 5, 5, str);        SetDialogItemText(XDItem, str);      END; { PROCEDURE Do_GSums; }		PROCEDURE Zero_the_Comps;	  VAR	    nn	: integer;	  BEGIN            BeepBeep;            FOR nn := 0 TO 14 DO {strings and values to 0}              BEGIN                GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, '0');                GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, '0');                G_At_Num[nn + 1] := 0;                G_Concentration[nn + 1] := 0.0;                theOxWeightF[nn + 1] := 0.0;                theOxStr[nn + 1] := '';                theValence[nn + 1] := 0;              END;            str := '0';            GetDialogItem(G_Input, T_Sum, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, str);            GetDialogItem(G_Input, T_Diff_From_1, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, str);            GetDialogItem(G_Input, T_Average_Z, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, str);            Num_Elements := 0;	  END;	      PROCEDURE SETUP;      VAR        nn                     : integer;      BEGIN		  		Zero_the_Comps;        IF Running_Thin_Mode THEN          FOR nn := 1 TO 15 DO {G_XXX are local variables}            BEGIN              G_At_Num[nn] := a^.Thin_At_Num[nn];              G_Concentration[nn] := a^.Thin_Concentration[nn];			  theValence[nn] := a^.Thin_Valence[nn];              IF (G_At_Num[nn] > 0) AND (G_Concentration[nn] > 0) THEN Num_Elements := Num_Elements + 1;              IF Num_Elements > 15 THEN Num_Elements := 15;            END        ELSE          IF Running_Bulk_Mode THEN            FOR nn := 1 TO 15 DO {G_XXX are local variables}              BEGIN                G_At_Num[nn] := a^.Bulk_At_Num[nn];                G_Concentration[nn] := a^.Bulk_Concentration[nn];				theValence[nn] := a^.Bulk_Valence[nn];                IF (G_At_Num[nn] > 0) AND (G_Concentration[nn] > 0) THEN Num_Elements := Num_Elements + 1;                IF Num_Elements > 15 THEN Num_Elements := 15;              END;        GetDialogItem(G_Input, G_Density, DType, DItem, tempRect);        RealToString(Thin_density, 5, 3, str);        IF Running_Thin_Mode THEN SetDialogItemText(DItem, str)        ELSE SetDialogItemText(DItem, 'N/A');        GetDialogItem(G_Input, G_Faraday, DType, DItem, tempRect);        RealToString(Faraday_Current, 5, 3, str);        SetDialogItemText(DItem, str);        GetDialogItem(G_Input, G_Time, DType, DItem, tempRect);        RealToString(Live_Time, 5, 3, str);        SetDialogItemText(DItem, str);        GetDialogItem(G_Input, G_Thickness, DType, DItem, tempRect);        RealToString(Specimen_Thickness / 1E-7, 5, 3, str);        IF Running_Thin_Mode THEN SetDialogItemText(DItem, str)        ELSE SetDialogItemText(DItem, 'N/A');        GetDialogItem(G_Input, G_KV, DType, DItem, tempRect);        IF Running_Thin_Mode THEN RealToString(thin_KV, 5, 3, str)        ELSE RealToString(Bulk_KV, 5, 3, str);        SetDialogItemText(DItem, str);        ExitDialog := FALSE;      END; { Procedure SETUP }    BEGIN { PROCEDURE D_Generate_Input }      G_Input := GetNewDialog(432, NIL, Pointer( - 1));      ShowWindow(G_Input);      SelectWindow(G_Input);      SetPort(G_Input);	  GetDialogItem(G_Input, Insert_in_Database, DType, DItem, tempRect);	  HiliteControl(controlhandle(DItem), 255);	  GetDialogItem(G_Input, Remove_Item, DType, DItem, tempRect);	  HiliteControl(controlhandle(DItem), 255);      SetRect(Rect_I_List1, 194, 189, 615, 332); { l,t,r,b }      tempRect := Rect_I_List1;      tempRect.Right := tempRect.Right - 15;      IF (tempRect.Right <= (tempRect.Left + 15)) THEN tempRect.Right := tempRect.Left + 15;      InsetRect(tempRect, - 1, - 1);      FrameRect(tempRect);      InsetRect(tempRect, 1, 1);      SetRect(dataBounds, 0, 0, 1, 0);      cSize.h := tempRect.Right - tempRect.Left;      cSize.v := 0;      cList := LNew(tempRect, dataBounds, cSize, 0, G_Input, true, FALSE, FALSE, true);      cList^^.selFlags := lOnlyOne + lNoNilHilite;      LSetDrawingMode(FALSE, cList);      strt_str := 'Enter Here name of new item in database (<32 chars)';      GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);      SetDialogItemText(DItem, strt_str);      cSize.v := 0;      LSetSelect(true, cSize, cList);      Refresh_Dialog;      Number_of_Entries := 0;      OpenNew_Database := FALSE;      IF (DataBase_Open = true) THEN	   begin	    LSetDrawingMode(true, cList);	    Open_Database;		  GetDialogItem(G_Input,Insert_in_Database,DType,DItem,tempRect);		  HiliteControl(controlhandle(DItem), 0); 		  GetDialogItem(G_Input,Remove_Item,DType,DItem,tempRect);		  HiliteControl(controlhandle(DItem), 0); 				  LdelRow(0, 1, cList);		  LSetDrawingMode(FALSE, cList);		  if Comp_handles then			begin			  FOR Index := 1 TO Number_of_Entries DO				BEGIN				  IF NOT (Comp_Data[Index]^^.C_Name = '') THEN					BEGIN					  numtostring(Index, str1);					  str2 := Strip_Trailing_Blanks(str1);					  str1 := Strip_Trailing_Blanks(Comp_Data[Index]^^.C_Name);					  str := CONCAT(str2, '  ', str1);					  Add_LStr(str, cList);					END;				END;			end;		  LSetDrawingMode(true, cList);		  cSize.v := 0;		  LSetSelect(true, cSize, cList); { this selects the first entry }				Refresh_Dialog;	   end;      IF ((Active_Chemical_Scale < 1) OR (Active_Chemical_Scale > 5)) THEN Active_Chemical_Scale := 1;      Chem_Scale := 1; {always starts with wtfract}      GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);      SetDialogItemText(XDItem, 'Weight Fraction');      GetDialogItem(G_Input, R_Wt_Fr, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);	  	  {Zero_the_Comps;}		{Done in SETUP}      SETUP; {gets values and num_elements}      IF Num_Elements > 0 THEN        BEGIN          SetGValues;          Do_GSums;        END;      Quick_Exit := FALSE;      { end of setup for window; start getting input }      OldItem := 1;      Response_InTo_Results := FALSE;      called_for_generate := true;      Called_for_Work_Spec := FALSE;      KludgeBoolean := true; {temp bool to grey resp-to-rslts if cuming from bg subtr}      theValues := theGenRec^^; { for generate or background subt }      theRange_keeper := Range_Keeper;      { theGenRec may have bulk values...what to do about thin_kv, etc? Set after accept.}      IF (WDS_Active) AND (Running_Thin_Mode) THEN        BEGIN          putmessage('The current generate parameters are suitable for WDS but', 'I cannot yet generate a thin WDS Spectrum.',                     'I will change the spectroscopy to EDS but please', 'supply appropriate Detector Parameters and Channel Info.')           ;          GetDialogItem(G_Input, I_EDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 1);          GetDialogItem(G_Input, I_WDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 0);          Si_Active := true;          Ge_Active := FALSE;          WDS_Active := FALSE;          {WDS_Active must be set to put inDetector Parameters and Channel Info call:}          Detector_Parameters; { values go to theValues; called for D_Generate_Input }          Refresh_Dialog;        END;      Accept_All := FALSE;    {for generate we calc the new response if generate exits the main dialog;     for work we calc a new response if the box is checked;  for background subtract only we always calc a new response: }      IF (Called_for_Work_Spec) THEN Do_a_Calc := FALSE      ELSE Do_a_Calc := true;      IF (WDS_Active) THEN        BEGIN          GetDialogItem(G_Input, I_WDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 1);          GetDialogItem(G_Input, I_EDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 0);        END          { If (Si_Active) then...what if Ge_Active? Use if not WDS then EDS! }      ELSE        BEGIN          GetDialogItem(G_Input, I_EDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 1);          GetDialogItem(G_Input, I_WDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 0);        END;      Logic_Over_ride := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@GFilter), itemHit);        GetDialogItem(G_Input, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit > 100) AND (itemHit < 999) THEN          BEGIN            temp := itemHit - 100;            GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);			if Comp_handles then			  begin			    Zero_the_Comps;				str7 := Strip_Trailing_Blanks(Comp_Data[temp]^^.C_Name);				SetDialogItemText(DItem, str7);				Num_Elements := Comp_Data[temp]^^.C_Number;				Thin_density := Comp_Data[temp]^^.C_Density;				{Specimen_Thickness := Comp_Data[temp]^^.C_Thick;}				FOR Index := 1 TO Num_Elements DO				  BEGIN					G_At_Num[Index] := Comp_Data[temp]^^.C_Atno[Index];					G_Concentration[Index] := Comp_Data[temp]^^.C_WtFr[Index];					if ((Comp_Data[temp]^^.C_Valence[Index] < 1) OR (Comp_Data[temp]^^.C_Valence[Index] >= 7)) then						Comp_Data[temp]^^.C_Valence[Index] := 0;		  					theValence[Index] := Comp_Data[temp]^^.C_Valence[Index];				  END;			  end;            GetDialogItem(G_Input, G_Density, DType, DItem, tempRect);            RealToString(Thin_density, 5, 3, str);            IF Running_Thin_Mode THEN SetDialogItemText(DItem, str)            ELSE SetDialogItemText(DItem, 'N/A');            GetDialogItem(G_Input, G_Thickness, DType, DItem, tempRect);            RealToString(Specimen_Thickness, 5, 3, str);            IF Running_Thin_Mode THEN SetDialogItemText(DItem, str)            ELSE SetDialogItemText(DItem, 'N/A');            GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);            GetDialogItem(G_Input, R_Wt_Fr, DType, DItem, tempRect);            SetDialogItemText(XDItem, 'Weight Fraction');            CItem := controlhandle(DItem);            Chem_Scale := 1;            SetGValues;            Do_GSums;            FOR Index := R_Wt_Fr TO R_Valence DO              BEGIN                GetDialogItem(G_Input, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0); {turn off all radios}              END;            SetControlValue(CItem, 1); {turn on the selected radio}            Refresh_Dialog;          END;        IF (itemHit >= R_Wt_Fr) AND (itemHit <= R_Valence) THEN { RADIO Buttons }          BEGIN            IF itemHit = R_Ox_Fr THEN              BEGIN                nn := 1;                REPEAT                  IF theValence[nn] > 0 THEN nn := nn + 1;                  IF nn > 15 THEN nn := 15;                UNTIL (theValence[nn] <= 0) OR (nn = Num_Elements);    {remember the valence[Num_Elements] is the valence[Oxygen] which     doesn't count.}                IF Num_Elements > 15 THEN Num_Elements := 15;                IF Num_Elements < 1 THEN Num_Elements := 1;                IF (theValence[nn] <= 0) AND (G_Concentration[1] > 0.0) THEN                  putmessage('I cannot give you the Oxide fractions without the valences.',                             'Another way to enter the data is to `zero all` then click the oxide',                             'button and enter formulas such as Al2O3. The valences will then be',                             'calculated from the stoichiometry relation.')                ELSE                  IF ((G_At_Num[Num_Elements] <> 8) AND (G_Concentration[1] > 0.0)) THEN                    putmessage('The last element must be oxygen for this conversion.', '', '', '')                  ELSE                    BEGIN                      GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);                      SetDialogItemText(XDItem, 'Oxide Weight Fraction');                      Chem_Scale := 2;                      GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);                      FOR Index := R_Wt_Fr TO R_Valence DO                        BEGIN                          GetDialogItem(G_Input, Index, DType, DItem, tempRect);                          SetControlValue(controlhandle(DItem), 0); {turn off all radios}                        END;                      SetControlValue(CItem, 1); {turn on the selected radio}                    END;              END { IF itemHit = R_Ox_Fr THEN...}            ELSE              BEGIN { IF itemHit <> R_Ox_Fr THEN...}                GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);                FOR Index := R_Wt_Fr TO R_Valence DO                  BEGIN                    GetDialogItem(G_Input, Index, DType, DItem, tempRect);                    SetControlValue(controlhandle(DItem), 0); {turn off all radios}                  END;                SetControlValue(CItem, 1); {turn on the selected radio}                IF itemHit = R_Wt_Fr THEN                  BEGIN                    SetDialogItemText(XDItem, 'Weight Fraction');                    Chem_Scale := 1;                  END                ELSE                  IF itemHit = R_Num_Atms THEN                    BEGIN                      SetDialogItemText(XDItem, '# of Atoms');                      Chem_Scale := 3;                    END                  ELSE                    IF itemHit = R_mMol_Dry_Wt THEN                      BEGIN                        SetDialogItemText(XDItem, 'mMol/kgDryWt');                        Chem_Scale := 4;                      END                    ELSE                      IF itemHit = R_Atm_Fr THEN                        BEGIN                          SetDialogItemText(XDItem, 'Atom Fraction');                          Chem_Scale := 5;                        END                      ELSE                        IF itemHit = R_Valence THEN                          BEGIN                            SetDialogItemText(XDItem, 'Valence');                            Chem_Scale := 6;                          END;              END; {IF itemHit <> R_Ox_Fr THEN...}            IF Num_Elements > 0 THEN              BEGIN                SetGValues;                Do_GSums;              END;          END; { IF (itemHit >= R_Wt_Fr) AND (itemHit <= R_Valence) THEN...}        IF (itemHit = I_Help) THEN          BEGIN            Generate_Help;            Refresh_Dialog;          END;        IF (itemHit = I_Display_Parameters) THEN          BEGIN            D_Display_Parameters;            Refresh_Dialog;            Accept_All := true;          END;        IF (itemHit = I_Load_Header_Info) THEN          BEGIN            theValues.number_of_channels := Plt_spec[10]^^.Expt_Info.number_of_channels;            IF Running_Thin_Mode THEN thin_KV := Plt_spec[10]^^.Expt_Info.kV            ELSE Bulk_KV := Plt_spec[10]^^.Expt_Info.kV;            theValues.kV := Plt_spec[10]^^.Expt_Info.kV;			Zero_the_Comps;              Num_Elements := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements;            FOR nn := 1 TO Num_Elements DO              BEGIN                G_At_Num[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Atomic_Number;                G_Concentration[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Weight_Fraction;                IF ((Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence >= 0.0) AND                	(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence < 7.0)) then					theValence[nn] := rinttol(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence)				ELSE					theValence[nn] := 0;              END;            IF Num_Elements > 15 THEN Num_Elements := 15;            Specimen_Thickness := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness;            Thin_density := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density;            Live_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;            Faraday_Current := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;            GetDialogItem(G_Input, G_Density, DType, DItem, tempRect);            RealToString(Thin_density, 5, 3, str);            IF Running_Thin_Mode THEN SetDialogItemText(DItem, str)            ELSE SetDialogItemText(DItem, 'N/A');            GetDialogItem(G_Input, G_Faraday, DType, DItem, tempRect);            RealToString(Faraday_Current, 5, 3, str);            SetDialogItemText(DItem, str);            GetDialogItem(G_Input, G_Time, DType, DItem, tempRect);            RealToString(Live_Time, 5, 3, str);            SetDialogItemText(DItem, str);            GetDialogItem(G_Input, G_Thickness, DType, DItem, tempRect);            RealToString(Specimen_Thickness / 1E-7, 5, 3, str);            IF Running_Thin_Mode THEN SetDialogItemText(DItem, str)            ELSE SetDialogItemText(DItem, 'N/A');            GetDialogItem(G_Input, G_KV, DType, DItem, tempRect);            IF Running_Thin_Mode THEN RealToString(thin_KV, 5, 3, str)            ELSE RealToString(Bulk_KV, 5, 3, str);            SetDialogItemText(DItem, str);            SetGValues;            Do_GSums;            Refresh_Dialog;          END;		IF (itemHit = I_Clear_Output_Pts) THEN          BEGIN          	IF Running_Thin_Mode THEN begin          		Thin_S1_Choice := 0;          		Thin_S2_Choice := 0;          		Thin_S3_Choice := 0;          		Thin_S4_Choice := 0;          		Thin_S5_Choice := 0;          		Thin_S6_Choice := 0;          		Thin_S7_Choice := 0;          		Thin_S8_Choice := 0;          		Thin_Rslt_Choice := 0;          	end          	ELSE begin          		Bulk_S1_Choice := 0;          		Bulk_S2_Choice := 0;          		Bulk_S3_Choice := 0;          		Bulk_S4_Choice := 0;          		Bulk_S5_Choice := 0;          		Bulk_S6_Choice := 0;          		Bulk_S7_Choice := 0;          		Bulk_S8_Choice := 0;          		Bulk_Rslt_Choice := 0;          	end;          END;        IF (itemHit = G_Cancel) THEN          BEGIN      { if we ever hit WDS button we set WDS_Active := true  but if we CANCEL out of this     dialog we want theGenRec and WDS_ative to be consistent: theGenRec changes     only if we ACCEPT out of this dialog so...}            IF theGenRec^^.Detector.Spec = WDS THEN WDS_Active := true            ELSE WDS_Active := FALSE;            sili_response_calculated := true; {if there is a GenRec there is a response}            DisposeDialog(G_Input);			if Comp_handles then            FOR Index := 1 TO Number_of_Entries DO              H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');			Comp_handles := false;   {putmessage('About to dispose of the cList','','','');   LDispose(cList);}            BeginUpdate(BackPlane);            DrawAxesFull;            update_full;            EndUpdate(BackPlane);            UpDate_SiLi_Window(SiLiWindow);            Mouse_Active_Window;            Quick_Exit := true; {this is a global to thwart bad things that go bump in the night }            exit(D_Generate_Input);          END;        IF (itemHit = G_zero) THEN          BEGIN		    Zero_the_Comps;          END;        IF (itemHit = G_Accept) THEN          BEGIN            GetDialogItem(G_Input, G_KV, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            theValues.kV := MyStr2Num(sTemp);			IF ((theValues.dE <= 0.0) OR (theValues.number_of_channels < 256)) THEN			D_Display_Parameters;            ExitDialog := FALSE;            IF (Running_Thin_Mode) AND (theValues.kV < 50.0) THEN              IF answermessage('The Physics used to generate a "thin" spectrum are optimized for 50 < E0 < 300 keV.',                               'For low keV the continuum cross sections are particularly picky. If you use the',                               'MBH in this region, the background near E0 will be quite suspect.', 'Is that OK?') THEN                ExitDialog := true              ELSE ExitDialog := FALSE            ELSE              IF (Running_Bulk_Mode) AND (theValues.kV > 50.0) THEN                IF answermessage('The Physics used to generate a "bulk" spectrum are optimized for  E0 < 50 keV.',                                 'For your keV the absorption correction and the continuum expressions are particularly ',                                 'bad. Above 50 kV the results will be suspect.', 'Is that OK?') THEN                  ExitDialog := true                ELSE ExitDialog := FALSE              ELSE ExitDialog := true;			if Comp_handles then            FOR Index := 1 TO Number_of_Entries DO              H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');			Comp_handles := false;          END;        IF (itemHit = Insert_in_Database) THEN          BEGIN		  IF (DataBase_Open = TRUE) THEN			BEGIN            IF Number_of_Entries >= 50 THEN              BEGIN                putmessage('You have reached the maximum number', ' of compositions allowed for this file.',                           ' Please start a new data file for additional', ' compositions.');              END            ELSE              BEGIN                GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                str7 := Strip_Trailing_Blanks(sTemp);				if NOT (strt_str = str7) then				begin                Number_of_Entries := Number_of_Entries + 1;                {putmessage('str7 contains the name ',str7,' first','');}                Test_a_Handle(Handle(Comp_Data[Number_of_Entries]), 'Comp_Data[Number_of_Entries]');                Comp_Data[Number_of_Entries] := Comp_RecHdl(NewHandle(SizeOf(Comp_Rec)));                MoveHHi(Handle(Comp_Data[Number_of_Entries]));                HLock(Handle(Comp_Data[Number_of_Entries]));				Comp_handles := true;                {putmessage('str7 contains the name ',str7,' second','');}				  nn := Length(str7);				  if nn > 32 then					str7[0] := chr(32);                Comp_Data[Number_of_Entries]^^.C_Name := str7;                IF Num_Elements < 1 THEN Num_Elements := 1;                Comp_Data[Number_of_Entries]^^.C_Number := Num_Elements;              GetDialogItem(G_Input, G_Density, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              if (sTemp <> 'N/A') then              	Thin_density := MyStr2Num(sTemp)              else Thin_density := 0.0;              GetDialogItem(G_Input, G_Thickness, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Specimen_Thickness := MyStr2Num(sTemp);				                Comp_Data[Number_of_Entries]^^.C_Density := Thin_density;				Comp_Data[Number_of_Entries]^^.C_Thick := Specimen_Thickness;				{еее10/13/95еее}                FOR Index := 1 TO Num_Elements DO                  BEGIN                    Comp_Data[Number_of_Entries]^^.C_Atno[Index] := G_At_Num[Index];                    Comp_Data[Number_of_Entries]^^.C_WtFr[Index] := G_Concentration[Index];					if ((theValence[Index] < 1) OR (theValence[Index] > 7)) then						theValence[Index] := 0;                    Comp_Data[Number_of_Entries]^^.C_Valence[Index] := theValence[Index];                  END;                Add_to_Database;                numtostring(Number_of_Entries, str1);                str1 := Strip_Trailing_Blanks(str1);                str := CONCAT(str1, '  ', str7);                {putmessage('str7 contains the name ',str7,' third','');}                LSetDrawingMode(true, cList);                Add_LStr(str, cList);                Refresh_Dialog;				end;              END;			END;		{ IF (DataBase_Open = TRUE) }          END;        IF (itemHit = Name_New_Database) THEN          BEGIN            DataBase_Open := FALSE;            LdelRow(0, 1, cList);            Create_Database;			  GetDialogItem(G_Input,Insert_in_Database,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			  GetDialogItem(G_Input,Remove_Item,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0);             Refresh_Dialog;          END;        IF (itemHit = Retreive_Item) THEN          BEGIN            OpenNew_Database := true;            LSetDrawingMode(true, cList);            Open_Database;			  GetDialogItem(G_Input,Insert_in_Database,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			  GetDialogItem(G_Input,Remove_Item,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0);             cSize.v := 0;            LSetSelect(true, cSize, cList); { this selects the first entry }            {Refresh_Dialog;}            LdelRow(0, 1, cList);            LSetDrawingMode(FALSE, cList);            FOR Index := 1 TO Number_of_Entries DO              BEGIN                IF NOT (Comp_Data[Index]^^.C_Name = '') AND (Comp_handles) THEN                  BEGIN                    numtostring(Index, str1);                    str2 := Strip_Trailing_Blanks(str1);                    str1 := Strip_Trailing_Blanks(Comp_Data[Index]^^.C_Name);                    str := CONCAT(str2, '  ', str1);                    Add_LStr(str, cList);                  END;              END;            LSetDrawingMode(true, cList);            Refresh_Dialog;            cSize.v := 0;            LSetSelect(true, cSize, cList); { this selects the first entry }            OpenNew_Database := FALSE;          END;		  		  IF (itemHit = Remove_Item) THEN			BEGIN			  StringToNum(str_info, tempLong);			  if (tempLong > 0) then				begin			  Remove_from_Database(tempLong);			  if Comp_handles then			  H_UnLock_Dispose(Handle(Comp_Data[Number_of_Entries]), 'Comp_Data handle');			  cSize.v := 0;			  LSetSelect(true, cSize, cList); { this selects the first entry }			  LSetDrawingMode(true, cList);			  LdelRow(0, 1, cList);			  Number_of_Entries := Number_of_Entries - 1;			  LSetDrawingMode(false, cList);			  for index := 1 to Number_of_Entries do				begin				  IF NOT (Comp_Data[Index]^^.C_Name = '') AND (Comp_handles) THEN					BEGIN					  str7 := Comp_Data[index]^^.C_Name;					  numtostring(index, str1);					  str1 := Strip_Trailing_Blanks(str1);					  str := CONCAT(str1, '  ', str7);					  Add_LStr(str, cList);					END;				end;			  LSetDrawingMode(true, cList);			  Refresh_Dialog;			  cSize.v := 0;			  LSetSelect(true, cSize, cList); { this selects the first entry }			  end;	{ if (tempLong > 0) }			END;        IF (itemHit = G_Choose_Extended) THEN          BEGIN            D_Output_Opts;            Refresh_Dialog;          END;        IF (itemHit = G_Choose_X_Sects) THEN          BEGIN            IF Running_Thin_Mode THEN D_Thin_X_Sects;            IF Running_Bulk_Mode THEN D_Bulk_X_Sects;            Refresh_Dialog;          END;        IF (Running_Thin_Mode) AND (itemHit = I_WDS) THEN          putmessage('Sorry, I cannot yet generate a thin target spectrum for WDS', '', '', '')        ELSE          IF (itemHit = I_EDS) OR (itemHit = I_WDS) THEN            BEGIN              IF (itemHit = I_EDS) THEN                BEGIN                  GetDialogItem(G_Input, I_EDS, DType, DItem, tempRect);                  SetControlValue(controlhandle(DItem), 1);                  GetDialogItem(G_Input, I_WDS, DType, DItem, tempRect);                  SetControlValue(controlhandle(DItem), 0);                  WDS_Active := FALSE;                  Ge_Active := FALSE;                  Si_Active := true; { must be set for Detector_Parameters}                  Detector_Parameters; { calls D_WDS_Chooser or D_Si_Li_Parameters and checks FWHM}                END;              IF (itemHit = I_WDS) THEN                BEGIN                  GetDialogItem(G_Input, I_WDS, DType, DItem, tempRect);                  SetControlValue(controlhandle(DItem), 1);                  GetDialogItem(G_Input, I_EDS, DType, DItem, tempRect);                  SetControlValue(controlhandle(DItem), 0);                  WDS_Active := true; { must be set for Detector_Parameters }                  Ge_Active := FALSE;                  Si_Active := FALSE;                  Detector_Parameters; { calls D_WDS_Chooser or D_Si_Li_Parameters and checks FWHM }                END;              Refresh_Dialog; {a simple refresh}            END;        IF (itemHit = SiLi_Params) THEN          BEGIN            Detector_Parameters; { PROCEDURE D_Generate_Input }            {theGenRec and Plt_Spec[10] will get theValues only if accept from Generate}            Refresh_Dialog; {a simple refresh}          END;        IF (itemHit >= I_Z1) AND (itemHit <= I_Value + 28) THEN          BEGIN            GetGValues;            Do_GSums;          END;        {ееее}      UNTIL ExitDialog;{ We now have selected generate so start putting values into theGenRec and Plt_Spec[10];  if we have changed any values in detector windows, sili_response_calculated is false.  Can only get here if we accept.}      WITH Plt_spec[10]^^.Expt_Info DO        BEGIN          LastSpect := 1;          FirstSpec := 1;          Specimen_ID := 'Generated Spectra';          MCA_Filename := 'Not yet saved.';          Specimen_Comment_Field := 'Comments here.';          RefFile := FALSE;		  energy_slope := 1.0;		  energy_intercept := 0.0;        END;      Active_Chemical_Scale := Chem_Scale;      	WITH X_SectRec^^ DO	  BEGIN      IF Running_Thin_Mode THEN        BEGIN          str := concat(' K - ',Thin_X_Xec_List[Thin_K_Xsect],          				' L - ',Thin_X_Xec_List[Thin_L_Xsect + 14],          				' M - ',Thin_X_Xec_List[Thin_M_Xsect + 26],          				' Cont ',Thin_X_Xec_List[Thin_CONT_Xsect + 32]);          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated Thin Final Composite Spectrum ', str);        END      ELSE IF Running_Bulk_Mode THEN        BEGIN          str := concat(' K - ',Bulk_X_Xec_List[Bulk_K_Xsect],          				' L - ',Bulk_X_Xec_List[Bulk_L_Xsect + 15],          				' M - ',Bulk_X_Xec_List[Bulk_M_Xsect + 31],          				' Cont ',Bulk_X_Xec_List[Bulk_CONT_Xsect + 43]);          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field :=		  	CONCAT('Generated Bulk Final Composite Spectrum ',str);        END;	 END;	{WITH X_SectRec^^ DO}	      GetDialogItem(G_Input, G_Faraday, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday := MyStr2Num(sTemp);      Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;      GetDialogItem(G_Input, G_Time, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time := MyStr2Num(sTemp);      Faraday_Current := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;      Live_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;      Plt_spec[10]^^.SpectrumStuff.Acq_Info.Real_Time := Live_Time;      Values_to_Work;      {we are not leaving the display as it was}      Spectrum_Size := theValues.number_of_channels;      Range_Keeper := theRange_keeper;      New_Range := Spectrum_Size;      ChannelMax := Spectrum_Size;      ChannelMin := 1;      WITH Plt_spec[10]^^.SpectrumStuff.Spectrum_Info DO        BEGIN          IF Num_Elements > 15 THEN Num_Elements := 15;          IF Num_Elements < 1 THEN Num_Elements := 1;          Number_of_Elements := Num_Elements;          IF Running_Thin_Mode THEN            BEGIN              thin_KV := theValues.kV;              GetDialogItem(G_Input, G_Density, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Thin_density := MyStr2Num(sTemp);              Specimen_Density := Thin_density;              GetDialogItem(G_Input, G_Thickness, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Specimen_Thickness := MyStr2Num(sTemp) * 1E-7;              FOR nn := 1 TO  15 DO                BEGIN                  a^.Thin_At_Num[nn] := G_At_Num[nn];                  a^.Thin_Concentration[nn] := G_Concentration[nn];				  a^.Thin_Valence[nn] := theValence[nn];                  Element_Info[nn].Weight_Fraction := G_Concentration[nn];                  Element_Info[nn].Atomic_Number := G_At_Num[nn];                  Element_Info[nn].Valence := theValence[nn];                END;            END { IF Running]Thin_Mode }          ELSE            BEGIN              Bulk_KV := theValues.kV;              FOR nn := 1 TO  15 DO                BEGIN                  a^.Bulk_At_Num[nn] := G_At_Num[nn];                  a^.Bulk_Concentration[nn] := G_Concentration[nn];				  a^.Bulk_Valence[nn] := theValence[nn];                  Element_Info[nn].Weight_Fraction := G_Concentration[nn];                  Element_Info[nn].Atomic_Number := G_At_Num[nn];                  Element_Info[nn].Valence := theValence[nn];                END;            END; { ELSE BEGIN }        END; {WITH...}      {an unfortunate choice of variable names requires the next two lines to be outside the "WITH"}      Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Average_Z := Average_Z;      Specimen_Thickness := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness;      {Compare theValues to theGenRec and set SiLi_Response_Calculated true or false }      {еееSet_Response_Bool(theGenRec, sili_response_calculated);еее 7/25/97}      sili_response_calculated := false;      theGenRec^^ := theValues;	  theGenRec^^.Energy_Intercept := 0.0;	  theGenRec^^.Energy_slope :=1.0;      IF (not sili_response_calculated) THEN     (* ELSE*)        BEGIN          Detector_efficiency(theGenRec, sili_response_calculated);          BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, SizeOf(Det_Effic_P^))        END;      IF Response_InTo_Results THEN        BEGIN          BlockMove(@Det_Effic_P^, @Plt_spec[9]^^.S, SizeOf(Plt_spec[9]^^.S));          Spectrum_Full[9] := true;          CheckItem(FullMenu, a^.C_Full[9], Spectrum_Full[9]);          UpDate_Max_Min(9);        END;	  Xray_Data_Request := true;	{to get the uncalibrated true table values}      IF Running_Thin_Mode THEN Thin_Film      ELSE IF Running_Bulk_Mode THEN Bulk;	  GetDateTime(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time);      specwork_has_been_changed := true;      saved_displayed := FALSE;	  BlockMove(@theGenRec^^, @theBGRec^^, SizeOf(Sili_Rec));      Spectrum_Full[10] := true;      CheckItem(FullMenu, a^.C_Full[10], Spectrum_Full[10]);      UpDate_Max_Min(10);	  if Comp_handles then      FOR Index := 1 TO Number_of_Entries DO        H_UnLock_Dispose(Handle(Comp_Data[Index]), 'Comp_Data handle');	  Comp_handles := false;      DisposeDialog(G_Input);      BeginUpdate(BackPlane);      DrawAxesFull;      update_full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);      Mouse_Active_Window;      Reset_Range_Buttons;    END; { PROCEDURE D_Generate_Input }  {=================================}  PROCEDURE D_Detector_Geometry; {ее For the Expt Header ее}    CONST      I_Accept                      = 1;      Azimuthal                     = 4;      Elevation                     = 5;      SpecDetDist                   = 15;      xtilt                         = 13;      ytilt                         = 14;             {``}      beta                          = 6;      TOA                           = 12;      I_Geometry                    = 17;              { the picture }      I_Exit                        = 2;    VAR      Geometry_ExitDialog           : boolean;      tempRect                      : Rect;      DType                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      Error                         : boolean;      rtemp1, rtemp2, rtemp3, rtemp4: real;      str                           : str255;    PROCEDURE Get_the_Values; {ее For the Expt Header ее}            BEGIN        GetDialogItem(Geom_Dialog, Azimuthal, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        geom.Azimuthal_angle := MyStr2Num(sTemp);        GetDialogItem(Geom_Dialog, Elevation, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        geom.elevation_angle := MyStr2Num(sTemp);        GetDialogItem(Geom_Dialog, beta, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        geom.Beta_Angle := MyStr2Num(sTemp);      END; { Get_the_Values }    BEGIN {PROCEDURE D_Detector_Geometry; ее For the Expt Header ее}      Geom_Dialog := GetNewDialog(3091, NIL, Pointer( - 1)); {ее For the Expt Header ее}      ShowWindow(Geom_Dialog);      SelectWindow(Geom_Dialog);      SetPort(Geom_Dialog);      OutlineButton(Geom_Dialog, I_Accept, 16); { outline the accept button }      Error := FALSE;      {ееееееееееееееееSetup initial conditionsееееееееееееее}      { the Geom.values come from Plt_Spec[10] for this dialog; hold incoming values }      rtemp1 := geom.Azimuthal_angle;      rtemp2 := geom.elevation_angle;      rtemp3 := geom.Beta_Angle;      rtemp4 := geom.Angle_of_TakeOff;      GetDialogItem(Geom_Dialog, Azimuthal, DType, DItem, tempRect);      RealToString(geom.Azimuthal_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, Elevation, DType, DItem, tempRect);      RealToString(geom.elevation_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, beta, DType, DItem, tempRect);      RealToString(geom.Beta_Angle, 3, 2, str);      SetDialogItemText(DItem, str);      RealToString(geom.Angle_of_TakeOff, 5, 2, str);      str := CONCAT(str, ' Degrees');      GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, SpecDetDist, DType, DItem, tempRect);      RealToString(geom.Spec_Det_Dist, 3, 2, str);      SetDialogItemText(DItem, str);      Geometry_ExitDialog := FALSE;      GetDialogItem(Geom_Dialog, ytilt, DType, DItem, tempRect);      RealToString(geom.Y_Tilt_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, xtilt, DType, DItem, tempRect);      RealToString(geom.X_Tilt_angle, 3, 2, str);      SetDialogItemText(DItem, str);      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(Geom_Dialog, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = beta) OR { Button }           (itemHit = Elevation) OR { Button }           (itemHit = Azimuthal) THEN { Button }          BEGIN            Get_the_Values;            Calc_the_Angles; { uses geom }            RealToString(geom.Angle_of_TakeOff, 3, 2, str);            str := CONCAT(str, ' Degrees');            GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);            SetDialogItemText(DItem, str);          END;        IF (itemHit = I_Accept) THEN { Button }          BEGIN            Get_the_Values;            IF (geom.elevation_angle < -90.0) OR (geom.elevation_angle > 90.0) THEN              BEGIN                putmessage(' Elevation must be between -90 and +90 Degrees !!', '', '', '');                RealToString(Plt_spec[10]^^.Expt_Info.Elevation, 3, 2, str);                SetDialogItemText(DItem, str);              END              (*IF (geom.Azimuthal_angle < 0.0) OR (geom.Azimuthal_angle > 360.0) THEN                BEGIN                  putmessage(' Azimuth must be between 0 and +360 Degrees !!', '', '', '');                  RealToString(Plt_spec[10]^^.Expt_Info.Azimuth, 3, 2, str);                  SetDialogItemText(DItem, str);                END;*)                ELSE IF (geom.Beta_Angle < -90.0) OR (geom.Beta_Angle > 90.0) THEN                  BEGIN                    putmessage('Uh-Oh!', 'Beta Angle must be between -90 and +90 Degrees but not 0.!!',                               'Angle is relative to the detector surface and', 'the line to the specimen.');                    RealToString(Plt_spec[10]^^.Expt_Info.Detector_tilt, 3, 2, str);                    SetDialogItemText(DItem, str);                  END                  ELSE BEGIN                    Calc_the_Angles; { uses geom }                    RealToString(geom.Angle_of_TakeOff, 3, 2, str);                    str := CONCAT(str, ' Degrees');                    GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);                    SetDialogItemText(DItem, str);                    Geometry_ExitDialog := true;                  END;          END;        IF (itemHit = I_Geometry) THEN {Handle a mouse hit in the Picture}          BEGIN            BeepBeep;          END;        IF (itemHit = I_Exit) THEN          BEGIN            geom.Azimuthal_angle := rtemp1;            geom.elevation_angle := rtemp2;            geom.Beta_Angle := rtemp4;            geom.Angle_of_TakeOff := rtemp4;            Geometry_ExitDialog := true;          END;      UNTIL Geometry_ExitDialog;      DisposeDialog(Geom_Dialog);    END; { D_Detector_Geometry #3091}  PROCEDURE Header_To_Generate;    BEGIN      WITH theGenRec^^ DO        BEGIN          BN_Thickness := Plt_spec[10]^^.Expt_Info.BN_Thickness;          SiN_Thickness := Plt_spec[10]^^.Expt_Info.SiN_Thickness;          Mylar := Plt_spec[10]^^.Expt_Info.Mylar;          Moxtek := Plt_spec[10]^^.Expt_Info.Moxtek;          Paralene := Plt_spec[10]^^.Expt_Info.Paralene;          Diamond := Plt_spec[10]^^.Expt_Info.Diamond;          Quantum := Plt_spec[10]^^.Expt_Info.Quantum;          Detector_Area := Plt_spec[10]^^.Expt_Info.Detector_Area;          Si_Resolution := Plt_spec[10]^^.Expt_Info.Si_Resolution;          WDS_Resolution := Plt_spec[10]^^.Expt_Info.WDS_Resolution;          Detector_Thickness := Plt_spec[10]^^.Expt_Info.Detector_Thickness;          Si_Thickness := Plt_spec[10]^^.Expt_Info.Si_Thickness;          Au_Thickness := Plt_spec[10]^^.Expt_Info.Au_Thickness;          Be_Thickness := Plt_spec[10]^^.Expt_Info.Be_Thickness;          Ice_Thickness := Plt_spec[10]^^.Expt_Info.Ice_Thickness;          C_Thickness := Plt_spec[10]^^.Expt_Info.C_Thickness;          Al_Thickness := Plt_spec[10]^^.Expt_Info.Al_Thickness;          Azimuth := Plt_spec[10]^^.Expt_Info.Azimuth;          Elevation := Plt_spec[10]^^.Expt_Info.Elevation;          Detector_tilt := Plt_spec[10]^^.Expt_Info.Detector_tilt;          Spec_Detector_Distance := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;          Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;          Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;          X_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;        END; { WITH theGenRec }    END;  PROCEDURE Generate_Detector_Geometry;    CONST      I_Accept                      = 1;      Azimuthal                     = 4;      Elevation                     = 5;      SpecDetDist                   = 7;      xtilt                         = 9;      ytilt                         = 8;      TOA                           = 12;      beta                          = 6;      I_Geometry                    = 17;              { the picture }      I_Exit                        = 2;      I_Load_From_WORK              = 18;    VAR      Geometry_ExitDialog           : boolean;      tempRect                      : Rect;      DType                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      rtemp1, rtemp2, rtemp3, rtemp4, rtemp5, rtemp6, rtemp7: real;      Error                         : boolean;      str                           : str255;LABEL	100;    BEGIN { PROCEDURE Generate_Detector_Geometry; }      Geom_Dialog := GetNewDialog(3093, NIL, Pointer( - 1));      ShowWindow(Geom_Dialog);      SelectWindow(Geom_Dialog);      SetPort(Geom_Dialog);      OutlineButton(Geom_Dialog, I_Accept, 16); { outline the accept button }      Error := FALSE;      {ееееееееееееееееSetup initial conditionsееееееееееееее}      { in this dialog the Geom.values are from theGenRec }      rtemp1 := geom.Azimuthal_angle;      rtemp2 := geom.elevation_angle;      rtemp3 := geom.Spec_Det_Dist;      rtemp4 := geom.Y_Tilt_angle;      rtemp5 := geom.X_Tilt_angle;      rtemp6 := geom.Beta_Angle;      rtemp7 := geom.Angle_of_TakeOff;      GetDialogItem(Geom_Dialog, Azimuthal, DType, DItem, tempRect);      RealToString(geom.Azimuthal_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, Elevation, DType, DItem, tempRect);      RealToString(geom.elevation_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, SpecDetDist, DType, DItem, tempRect);      RealToString(geom.Spec_Det_Dist, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, ytilt, DType, DItem, tempRect);      RealToString(geom.Y_Tilt_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, xtilt, DType, DItem, tempRect);      RealToString(geom.X_Tilt_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, beta, DType, DItem, tempRect);      RealToString(geom.Beta_Angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);      RealToString(geom.Angle_of_TakeOff, 3, 2, str);      str := CONCAT(str, ' Degrees');      SetDialogItemText(DItem, str);	        Geometry_ExitDialog := FALSE;100:   REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(Geom_Dialog, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = ytilt) THEN          BEGIN            GetDialogItem(Geom_Dialog, ytilt, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            geom.Y_Tilt_angle := MyStr2Num(sTemp);          END        ELSE          IF (itemHit = Azimuthal) THEN            BEGIN              GetDialogItem(Geom_Dialog, Azimuthal, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              geom.Azimuthal_angle := MyStr2Num(sTemp);            END          ELSE            IF (itemHit = beta) THEN              BEGIN                GetDialogItem(Geom_Dialog, beta, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                geom.Beta_Angle := MyStr2Num(sTemp);              END            ELSE              IF (itemHit = Elevation) THEN                BEGIN                  GetDialogItem(Geom_Dialog, Elevation, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  geom.elevation_angle := MyStr2Num(sTemp);                END              ELSE                IF (itemHit = SpecDetDist) THEN                  BEGIN                    GetDialogItem(Geom_Dialog, SpecDetDist, DType, DItem, tempRect);                    GetDialogItemText(DItem, sTemp);                    geom.Spec_Det_Dist := MyStr2Num(sTemp);                  END                ELSE                  IF (itemHit = xtilt) THEN                    BEGIN                      GetDialogItem(Geom_Dialog, xtilt, DType, DItem, tempRect);                      GetDialogItemText(DItem, sTemp);                      geom.X_Tilt_angle := MyStr2Num(sTemp);                    END;        IF (itemHit = I_Accept) THEN { Button }          BEGIN                IF (geom.X_Tilt_angle <= - 90) OR (geom.X_Tilt_angle >= 90.0) THEN                  BEGIN                    putmessage('X_Tilt must be between -90 and +90 Degrees!!',                               'Angle is relative to the "normal" plane.', '', '');                    RealToString(rtemp5, 3, 2, str);                    SetDialogItemText(DItem, str);                    GOTO 100;                  END;	          IF (geom.Y_Tilt_angle < -90) OR (geom.Y_Tilt_angle > 90.0) THEN	            BEGIN	              putmessage('Y_Tilt must be between -90 and +90 Degrees!!', 'Angle is relative to the "normal" plane.', '', '');	              RealToString(rtemp4, 3, 2, str);	              SetDialogItemText(DItem, str);	              GOTO 100;	            END;              (*IF (geom.Azimuthal_angle < 0.0) OR (geom.Azimuthal_angle > 360.0) THEN                BEGIN                  putmessage(' Azimuthal must be between zero and 360.0 Degrees !!', '', '', '');                  RealToString(rtemp1, 3,2, str);                  SetDialogItemText(DItem, str);                END;*)              IF (geom.Beta_Angle < -90.0) OR (geom.Beta_Angle > 90.0) THEN                BEGIN                  putmessage('Uh-Oh!', 'Beta Angle must be between -90 and +90 Degrees.',                             'Angle is relative to the detector surface and', 'the line to the specimen.');                  RealToString(rtemp6, 3, 2, str);                  SetDialogItemText(DItem, str);                  GOTO 100;                END;              IF (geom.elevation_angle < -90.0) OR (geom.elevation_angle > 90.0) THEN                BEGIN                  putmessage(' Elevation must be between -90 and +90 Degrees !!', '', '', '');                  RealToString(rtemp2, 3, 2, str);                  SetDialogItemText(DItem, str);                  GOTO 100;                END;                              Calc_the_Angles; {=>geom.beam_entry_angle and geom.angle_of_takeoff }                IF (geom.Spec_Det_Dist <= 1.0) OR (geom.Spec_Det_Dist > 500.0) THEN                  BEGIN                    putmessage(' SiLi-Specimen Distance must be between 1.0 and 500.0 mm !!', '', '', '');                    RealToString(rtemp3, 3, 2, str);                    SetDialogItemText(DItem, str);                  END;            Geometry_ExitDialog := true;          END;        IF (itemHit = I_Geometry) THEN {Handle a mouse hit in the Picture}          BEGIN            BeepBeep;          END;        IF (itemHit = I_Exit) THEN { back to incoming values }          BEGIN            geom.Azimuthal_angle := rtemp1;            geom.elevation_angle := rtemp2;            geom.Spec_Det_Dist := rtemp3;            geom.Y_Tilt_angle := rtemp4;            geom.X_Tilt_angle := rtemp5;            geom.Beta_Angle := rtemp6;            geom.Angle_of_TakeOff := rtemp7;            Geometry_ExitDialog := true;          END;        IF (itemHit = I_Load_From_WORK) THEN          BEGIN            geom.Azimuthal_angle := Plt_spec[10]^^.Expt_Info.Azimuth;            geom.elevation_angle := Plt_spec[10]^^.Expt_Info.Elevation;            geom.Spec_Det_Dist := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;            geom.Y_Tilt_angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;            geom.X_Tilt_angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;            geom.Beta_Angle := Plt_spec[10]^^.Expt_Info.Detector_tilt;            geom.Angle_of_TakeOff := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;          END;        Calc_the_Angles;        GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);        RealToString(geom.Angle_of_TakeOff, 3, 2, str);        str := CONCAT(str, ' Degrees');        SetDialogItemText(DItem, str);      UNTIL Geometry_ExitDialog;      DisposeDialog(Geom_Dialog);    END; { PROCEDURE Generate_Detector_Geometry; #3093}  {$S Physics_Windows5 }  PROCEDURE D_Si_Li_Parameters; {Dialog #18}    CONST      Accept                        = 1;      Cancel              			= 2;      Calculate_Response            = 3;      Dead_Zone_Text                = 11;      I_Help                        = 16;      I_SiLi                        = 19;      I_GeLi                        = 20;      SiLi_Param_area               = 21;      SiLi_Param_Mn_FWHM            = 22;      SiLi_Param_Det_Thickness      = 23;      SiLi_Param_Si_DeadZone        = 24;      SiLi_Param_Au_Thickness       = 25;      SiLi_Param_Be_Window          = 26;      I_Static_txt                  = 27;      SiLi_Param_Oxygen_Window      = 30;      SiLi_Param_Carbon_Window      = 33;      SiLi_Param_Defaults           = 35;      SiLi_Param_Al_Coating         = 37;      SiLi_Param_Geometry           = 40;      SiLi_Param_BN_Window          = 41;      SiLi_Param_SiN_Window         = 44;      SiLi_Param_Mylar              = 47;      SiLi_Param_Moxtek             = 51;      Dead_Zone_RhoT_Text           = 53;      SiLi_Param_Diamond            = 62;      SiLi_Param_Quantum            = 65;      Response_To_Results           = 69;      (* Send_Work_Params              = 70;*)       Load_Work_Params             = 71;      I_See_Help					= 72;      SiLi_Param_paralene           = 73;    VAR      tempRect                      : Rect;      DType                         : integer;      Index                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      DoTheEdit, ToWork             : boolean;      str                           : str255;      SiLi_Param_ExitDialog         : boolean;    PROCEDURE Load_theValues; { for D_Si_Li_Parameters;}     { if coming from Expt_Header then loads work params; else loads generate set }      BEGIN        GetDialogItem(SiLi_Dialog, I_SiLi, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        GetDialogItem(SiLi_Dialog, I_GeLi, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        GetDialogItem(SiLi_Dialog, Dead_Zone_RhoT_Text, DType, DItem, tempRect);        WITH theValues DO          BEGIN { don't change Si_active or Ge_active }            IF Detector.ID = 2 THEN              BEGIN                SetDialogItemText(DItem, 'rho= 5.32 (┼0.1-0.2)');                GetDialogItem(SiLi_Dialog, I_GeLi, DType, DItem, tempRect);              END            ELSE              BEGIN                SetDialogItemText(DItem, 'rho= 2.33 (┼0.1-0.2)');                GetDialogItem(SiLi_Dialog, I_SiLi, DType, DItem, tempRect);              END;            SetControlValue(controlhandle(DItem), 1);            GetDialogItem(SiLi_Dialog, SiLi_Param_BN_Window, DType, DItem, tempRect);            RealToString(BN_Thickness, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Al_Coating, DType, DItem, tempRect);            RealToString(Al_Thickness, 3, 2, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_SiN_Window, DType, DItem, tempRect);            RealToString(SiN_Thickness, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Mylar, DType, DItem, tempRect);            RealToString(Mylar, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Moxtek, DType, DItem, tempRect);	{Moxtek}            RealToString(Moxtek, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Paralene, DType, DItem, tempRect);	{Paralene}            RealToString(Paralene, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_area, DType, DItem, tempRect);            RealToString(Detector_Area, 5, 2, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Mn_FWHM, DType, DItem, tempRect);            RealToString(Si_Resolution, 5, 2, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Det_Thickness, DType, DItem, tempRect);            RealToString(Detector_Thickness, 4, 2, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Si_DeadZone, DType, DItem, tempRect);            RealToString(Si_Thickness, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Oxygen_Window, DType, DItem, tempRect);            RealToString(Ice_Thickness, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Carbon_Window, DType, DItem, tempRect);            RealToString(C_Thickness, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Au_Thickness, DType, DItem, tempRect);            RealToString(Au_Thickness, 5, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Be_Window, DType, DItem, tempRect);            RealToString(Be_Thickness, 3, 4, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Diamond, DType, DItem, tempRect);            RealToString(Diamond, 3, 4, str);            RealToString(Diamond, 4, 2, str);            SetDialogItemText(DItem, str);            GetDialogItem(SiLi_Dialog, SiLi_Param_Quantum, DType, DItem, tempRect);            RealToString(Quantum, 3, 4, str);            SetDialogItemText(DItem, str);          END; { with theValues do begin...}      END; { Procedure Load_theValues for D_Si_Li_Parameters;}    PROCEDURE Get_the_Values; { for D_Si_Li_Parameters;}      BEGIN        WITH theValues DO          BEGIN            { the Geom values and display values are aleady in the theValues }            GetDialogItem(SiLi_Dialog, SiLi_Param_BN_Window, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            BN_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_SiN_Window, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            SiN_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Mylar, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Mylar := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Moxtek, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Moxtek := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Paralene, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Paralene := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Det_Thickness, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Detector_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Si_DeadZone, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Si_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Au_Thickness, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Au_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Be_Window, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Be_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Al_Coating, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Al_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Diamond, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Diamond := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Quantum, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Quantum := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Oxygen_Window, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Ice_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Carbon_Window, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            C_Thickness := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_area, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Detector_Area := MyStr2Num(sTemp);            GetDialogItem(SiLi_Dialog, SiLi_Param_Mn_FWHM, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Si_Resolution := MyStr2Num(sTemp);            Detector.Spec := EDS;			           (* Si_Active := true;            Ge_Active := FALSE;*)            GetDialogItem(SiLi_Dialog, I_GeLi, DType, DItem, tempRect);            CItem := controlhandle(DItem);            temp := GetControlValue(CItem);            IF temp = 1 THEN              BEGIN                Si_Active := FALSE;    			Detector.ID := 2;  				Ge_Active := true;                 { putmessage('Program not yet configured for Ge', '', '', '');}              END            ELSE              BEGIN                Detector.ID := 1;                Si_Active := true;				Ge_Active := FALSE;              END;          END; { with theValues }      END; { PROCEDURE Get_the_Values for D_Si_Li_Parameters;}    PROCEDURE Help;		{detector help}	{ For D_Si_Li_Parameters but this is the wrong text for the detector parameters. }      VAR        tempRect                      : Rect;        offset                        : integer;        Left                          : integer;        Top                           : integer;        n                             : integer;        G_Help                        : DialogPtr;        itemHit                       : integer;        DType                         : integer;        DItem                         : Handle;      CONST        G_Accept                      = 1;      BEGIN        G_Help := GetNewDialog(433, NIL, Pointer( - 1));        ShowWindow(G_Help);        SelectWindow(G_Help);        SetPort(G_Help);        OutlineButton(G_Help, 1, 16); { outline the OK button }        SetFont('Monaco', 9, []);        offset := 12;        Left := 5;        Top := 15;        n := 0;        moveto(Left, Top);        str := 'This dialog will allow entry of all detector parameters. The lithium-drifted';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'silicon (Si) detector is the default; however, the germanium (Ge) detector may';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'also be selected. Fill in the detector area and thickness as provided by the';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'manufacturer. An approximate resolution for MnKalpha must be entered. This value';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'can be adjusted after fitting some peaks and a better value is obtained.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'Enter the thicknesses of your detector window, the dead-layer, and the gold';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'surface contact (this number should not change very much). There is also a';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'place to enter a thickness of ice which will build up on the detector window.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'The window and dead-layer thicknesses should be adjusted to obtain the best';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'approximation to a real spectrum measured with your detector.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'The "Detector Geometry" button allows you to define the configuration of your';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'instrument/specimen. From the Experiment Header, the instrument parameters may';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'be set and from the Specimen Header, angles and distances relating to the';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'specimen may be defined. From the Generate window, all of the parameters may';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'be defined.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'е Care in setting these parameters will help you to fit the x-ray peaks faster';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'and with more accuracy. е';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'ее IMPORTANT ее';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);		str := '1. For Moxtek AP1.3, the window is 0.3 um. You must also add about 0.04 um of Al.';		DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);		str := '2. For Moxtek AP1.7, the window is 0.6 um. You must also add about 0.06 um of Al.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);		str := '3. The paralene window used for the bolometer detector has 3 separate layers.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);		str := '		Each layer is 0.1 um thick and needs 0.14 um of Al added to it.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);		        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);          IF (itemHit = G_Accept) THEN            BEGIN              ExitDialog := true;            END;        UNTIL ExitDialog;        ExitDialog := FALSE;        DisposeDialog(G_Help);		  beginupdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);      END; {End of G_Help procedure}    BEGIN { PROCEDURE D_Si_Li_Parameters; }      SiLi_Dialog := GetNewDialog(418, NIL, Pointer( - 1));      ShowWindow(SiLi_Dialog);      SelectWindow(SiLi_Dialog);      SetPort(SiLi_Dialog);      OutlineButton(SiLi_Dialog, 1, 16); { outline the accept button }      ToWork := FALSE;      IF BG_Active THEN theValues := theBGRec^^;      {For header or generate, theValues defined in calling routine}      thePtr := SiLi_RecPtr(NewPtr(SizeOf(Sili_Rec)));      IF thePtr = NIL THEN        BEGIN          SysBeep(1);          putmessage('Not enough memory available for this operation',                     'Quit the program, then  do a "get info" and assign more memory to DTSA.', '', '');          exit(D_Si_Li_Parameters);        END;      IF (called_for_generate) THEN        BEGIN          GetDialogItem(SiLi_Dialog, I_Static_txt, DType, DItem, tempRect);          sTemp := 'New values are saved when you select GENERATE in the main dialog.';          SetDialogItemText(DItem, sTemp);        END;      GetDialogItem(SiLi_Dialog, Calculate_Response, DType, DItem, tempRect);      CItem := controlhandle(DItem);      IF (Called_for_Work_Spec) THEN        BEGIN          SetControlValue(CItem, 0);          GetDialogItem(SiLi_Dialog, Load_Work_Params, DType, DItem, tempRect);          CItem := controlhandle(DItem);          HideControl(CItem);        END      ELSE HideControl(CItem); {Calculate_Response}      GetDialogItem(SiLi_Dialog, Response_To_Results, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      IF display_ref THEN { hide the irrelevent stuff }        BEGIN          GetDialogItem(SiLi_Dialog, SiLi_Param_Geometry, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(SiLi_Dialog, Load_Work_Params, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(SiLi_Dialog, SiLi_Param_Defaults, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(SiLi_Dialog, Response_To_Results, DType, DItem, tempRect);          HideControl(controlhandle(DItem));        END;      Load_theValues; { loads into STRINGS the work values or generate values,etc depending on calling dialog; obviously does not do                       the geom dialog strings }					         SiLi_Param_ExitDialog := FALSE;      DoTheEdit := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(SiLi_Dialog, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = SiLi_Param_Geometry) THEN          BEGIN            WITH theValues DO              BEGIN                geom.Spec_Det_Dist := Spec_Detector_Distance;                geom.X_Tilt_angle := X_Tilt;                geom.Y_Tilt_angle := Y_Tilt;                geom.Angle_of_TakeOff := Take_Off_Angle;                geom.Azimuthal_angle := Azimuth;                geom.elevation_angle := Elevation;                geom.Beta_Angle := Detector_tilt;                {geom.Beam_Entry_Angle := already stored for old vals; calculated for new}              END; { WITH...}            IF Called_for_Work_Spec THEN              D_Detector_Geometry { #3091 }            ELSE Generate_Detector_Geometry; { #3093 }   {#3092 is called from spectrum_header but it should be replaced with #3091     with the tilts and distance shown but greyed out so user knows if he needs     to edit them}            WITH theValues DO              BEGIN { new/old geom values go back to theValues }                Spec_Detector_Distance := geom.Spec_Det_Dist;                X_Tilt := geom.X_Tilt_angle;                Y_Tilt := geom.Y_Tilt_angle;                Take_Off_Angle := geom.Angle_of_TakeOff;                Azimuth := geom.Azimuthal_angle;                Elevation := geom.elevation_angle;                Detector_tilt := geom.Beta_Angle;                Take_Off_Angle := geom.Angle_of_TakeOff;                {geom.Beam_Entry_Angle := already stored for old vals; calculated for new}              END; { WITH...}            OutlineButton(SiLi_Dialog, 1, 16); { outline the accept button }          END; { IF (itemHit = SiLi...}        IF (itemHit = I_Help) OR (itemHit = I_See_Help) THEN          BEGIN            Help;			OutlineButton(SiLi_Dialog, 1, 16);          END;        (*IF (itemHit = I_GeLi) THEN          putmessage('The Germanium detector capability is not functional',                     'in this version of the program but will be in an upcoming update.', '', '');		ееееееееееееееееее		*)         IF (itemHit = I_Sili) or (itemHit = I_Geli) THEN        BEGIN      for index := I_Sili to I_Geli do begin        GetDialogItem(SiLi_Dialog, index, DType, DItem, tempRect);      CItem := controlhandle(DItem);      temp := GetControlValue(CItem);      SetControlValue(CItem, (temp + 1) MOD 2); { change the button }   end;         GetDialogItem(SiLi_Dialog, Dead_Zone_RhoT_Text, DType, DItem, tempRect);   If (temp = 0) then begin   { temp was old value for I_Geli }            Ge_Active := true;            Si_Active := FALSE;			theValues.Detector.ID := 2;    SetDialogItemText(DItem, 'rho= 5.32 (┼0.1-0.2)')   end      else begin            Ge_Active := FALSE;            Si_Active := true;			theValues.Detector.ID := 1;    SetDialogItemText(DItem, 'rho= 2.33 (┼0.1-0.2)');    end;  END;        IF (itemHit = Accept) THEN          BEGIN            SiLi_Param_ExitDialog := true;            Accept_All := true;            GetDialogItem(SiLi_Dialog, SiLi_Param_Mn_FWHM, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            theValues.Si_Resolution := MyStr2Num(sTemp);            IF (theValues.Si_Resolution <= 1.0) THEN              BEGIN                IF NOT answermessage('The resolution is less than 100.0 eV; this is too low for EDS.',                                     'If IT`S OK I will set it to 145.0 eV,', 'otherwise you can change ',                                     'the value to what you want greater than 100 eV') THEN                  SiLi_Param_ExitDialog := FALSE                ELSE theValues.Si_Resolution := 145.0;              END;            WDS_Active := FALSE;           (* Ge_Active := FALSE;            Si_Active := true;*)          END;        IF (itemHit = Cancel) THEN          BEGIN            SiLi_Param_ExitDialog := true;          END;        IF (itemHit = SiLi_Param_Defaults) THEN          BEGIN            WITH theValues DO              BEGIN                Detector.ID := 1;				Detector.Spec := EDS;                Detector_Area := 30.0;                Detector_Thickness := 4.0;                C_Thickness := 0.1;                Diamond := 0.0;                Mylar := 0.0;                Moxtek := 0.0;                Paralene := 0.0;                BN_Thickness := 0.0;                SiN_Thickness := 0.0;                Ice_Thickness := 1.0;                Au_Thickness := 0.02;                Al_Thickness := 0.0;                Be_Thickness := 7.6;                Si_Thickness := 0.1;                Si_Resolution := 158;                WDS_Resolution := 10.0;                Quantum := 0.0;                Spec_Detector_Distance := 16.4;                Take_Off_Angle := 40.0;                Azimuth := -90.0;                Elevation := 40.0;                Detector_tilt := 90.0;                X_Tilt := 0.0;                Y_Tilt := 0.0;              END; {with}            Load_theValues; { theValues to strings }            sili_response_calculated := FALSE;          END;        IF (itemHit = Response_To_Results) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN Response_InTo_Results := true            ELSE Response_InTo_Results := FALSE;          END;        IF (itemHit = Load_Work_Params) THEN          BEGIN            IF (Called_for_Work_Spec) OR (answermessage('Are you sure IT`S OK to move all the "Work Spectrum" parameters',                                                        'into thefields of this dialog??',                                                        'Number of channels and ev/channel will also change.',                                                        'Hit the Channel Specs button for a dialog to access them.')) THEN              BEGIN                thePtr := @Plt_spec[10]^^.Expt_Info.Detector;                theValues := thePtr^; {this gets geom stuff: Azimuth,Elevation,Detector_tilt}                WITH theValues DO                  BEGIN                    Spec_Detector_Distance := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;                    X_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;                    Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;                    Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;                  END;                Load_theValues;              END;          END;        IF (itemHit = Calculate_Response) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN Do_a_Calc := true            ELSE Do_a_Calc := FALSE;          END;      UNTIL SiLi_Param_ExitDialog;      IF Accept_All THEN        BEGIN          Get_the_Values; { reads strings into theValues; the Geom and display values		  					are aleady in the theValues if the dialogs were exited via accept }          { put theValues into work... }          {See what Sili_Response_Calculated should be }          IF BG_Active THEN            BEGIN              Set_Response_Bool(theBGRec, SiLi_Buffer_Calculated);              theBGRec^^ := theValues;            END;        END; { IF Accept_All...}      DisposePtr(Ptr(thePtr));	  thePtr := NIL;      IF BG_Active THEN theBGRec^^ := theValues;      tempRect := SiLi_Dialog^.portRect;      DisposeDialog(SiLi_Dialog);      FillWhiteSpace(tempRect);    END; { PROCEDURE D_Si_Li_Parameters; }  PROCEDURE D_WDS_Chooser;    CONST      I_Accept                      = 1;      I_Cancel                      = 2;      I_MYR                         = 3;      I_NaCl                        = 4;      I_KAP                         = 5;      I_RAP                         = 6;      I_TAP                         = 7;      I_PET                         = 8;      I_LiF                         = 9;      I_LOD                         = 10;      I_LDE1                        = 11;      I_V_C                         = 12;      I_MoB4C                       = 13;      I_SiO2_1011                   = 14;      I_SiO2_1010                   = 15;      I_Si                          = 16;      I_Graphite                    = 17;      I_Pb_Stearate                 = 18;      I_Mica                        = 19;      I_EDDT                        = 20;      I_User1                       = 21;      I_User2                       = 22;      I_TOA                         = 28;      I_2d                          = 31;      I_Help                        = 36;      I_One_Coeff                   = 37;      I_Two_Coeff                   = 38;      I_Resolution                  = 44;      I_Geom                        = 47;    VAR      ExitDialog                    : boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : integer;      Index		                      : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp		                    : integer;      str                           : str255;    LABEL      100;    PROCEDURE Help;	{WDS_Chooser help}      VAR        tempRect                      : Rect;        offset                        : integer;        Left                          : integer;        Top                           : integer;        n                             : integer;        G_Help                        : DialogPtr;        itemHit                       : integer;        DType                         : integer;        DItem                         : Handle;      CONST        G_Accept                      = 1;      BEGIN        G_Help := GetNewDialog(433, NIL, Pointer( - 1));        ShowWindow(G_Help);        SelectWindow(G_Help);        SetPort(G_Help);        OutlineButton(G_Help, 1, 16); { outline the OK button }        SetFont('Monaco', 9, []);        offset := 12;        Left := 5;        Top := 15;        n := 0;        moveto(Left, Top);        DrawString(' ');        n := n + 1;        moveto(Left, Top + n * offset);        str := 'This dialog will allow entry of those quantities unique to WDS. This version of DTSA has';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'not fully implemented the WDS capability; however, WDS spectra may be generated or';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'fitted using the parameters selected in this dialog. The correct d-spacing will be used';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'for the crystal selected. The x-ray take-off angle should be set using the "Specimen-';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'Detector Geometry" button and the Resolution should be entered in the box provided.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'The "Digital Filter Multiplier" may be defined but we have found that 1.0 works';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'reasonably well for LiF crystals. Other values may be better for other crystals.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'The "Hypermet Number" must be defined for the Simplex to fit a WDS peak. Some';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'experimentation with different values must be done to find the best fit. Different';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'crystals will probably require different Hypermet Numbers.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'е Note that the values range from 0 to 1. е';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'The Hypermet Number may be temporarily changed from inside the Simplex routine.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);          IF (itemHit = G_Accept) THEN            BEGIN              ExitDialog := true;            END;        UNTIL ExitDialog;        ExitDialog := FALSE;        DisposeDialog(G_Help);		  beginupdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);      END; {End of G_Help procedure}    BEGIN      GetSelection := GetNewDialog(419, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);    100:      OutlineButton(GetSelection, 1, 16); { outline the accept button }      {ееееееееееSetup initial conditionsеееееееееееее}    { Construct a WDSGenRec and a WDSValues with the necessary fields for calculating   a response. Do not change theGenRec which should be kept for EDS detectors only.   Values from this dialog do go to theValues and therefore to WORK and/or a file.}      GetDialogItem(GetSelection, I_2d, DType, DItem, tempRect);      RealToString(WDS_Two_d, 5, 5, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, I_LiF, DType, DItem, tempRect);      IF WDS_Two_d = WDS_MYR THEN GetDialogItem(GetSelection, I_MYR, DType, DItem, tempRect);      IF WDS_Two_d = WDS_NaCl THEN GetDialogItem(GetSelection, I_NaCl, DType, DItem, tempRect);      IF WDS_Two_d = WDS_KAP THEN GetDialogItem(GetSelection, I_KAP, DType, DItem, tempRect);      IF WDS_Two_d = WDS_RAP THEN GetDialogItem(GetSelection, I_RAP, DType, DItem, tempRect);      IF WDS_Two_d = WDS_TAP THEN GetDialogItem(GetSelection, I_TAP, DType, DItem, tempRect);      IF WDS_Two_d = WDS_PET THEN GetDialogItem(GetSelection, I_PET, DType, DItem, tempRect);      IF WDS_Two_d = WDS_LiF THEN GetDialogItem(GetSelection, I_LiF, DType, DItem, tempRect);      IF WDS_Two_d = WDS_LOD THEN GetDialogItem(GetSelection, I_LOD, DType, DItem, tempRect);      IF WDS_Two_d = WDS_LDE1 THEN GetDialogItem(GetSelection, I_LDE1, DType, DItem, tempRect);      IF WDS_Two_d = WDS_V_C THEN GetDialogItem(GetSelection, I_V_C, DType, DItem, tempRect);      IF WDS_Two_d = WDS_MoB4C THEN GetDialogItem(GetSelection, I_MoB4C, DType, DItem, tempRect);      IF WDS_Two_d = WDS_SiO2_1011 THEN GetDialogItem(GetSelection, I_SiO2_1011, DType, DItem, tempRect);      IF WDS_Two_d = WDS_SiO2_1010 THEN GetDialogItem(GetSelection, I_SiO2_1010, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Si THEN GetDialogItem(GetSelection, I_Si, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Graphite THEN GetDialogItem(GetSelection, I_Graphite, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Pb_Stearate THEN GetDialogItem(GetSelection, I_Pb_Stearate, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Mica THEN GetDialogItem(GetSelection, I_Mica, DType, DItem, tempRect);      IF WDS_Two_d = WDS_EDDT THEN GetDialogItem(GetSelection, I_EDDT, DType, DItem, tempRect);      IF WDS_Two_d = WDS_User1 THEN GetDialogItem(GetSelection, I_User1, DType, DItem, tempRect);      IF WDS_Two_d = WDS_User2 THEN GetDialogItem(GetSelection, I_User2, DType, DItem, tempRect);      CItem := controlhandle(DItem);      SetControlValue(CItem, 1);      {one_Coeff := Pierson_Num ;}      GetDialogItem(GetSelection, I_One_Coeff, DType, DItem, tempRect);      RealToString(one_Coeff, 5, 5, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, I_Two_Coeff, DType, DItem, tempRect);      RealToString(two_Coeff, 5, 5, str);      SetDialogItemText(DItem, str); (*  Now in the calling procedure...   IF Called_for_Work_Spec then BEGIN        thePtr := SiLi_RecPtr(NewPtr(sizeof(Sili_Rec)));       if thePtr = NIL then         begin        SysBeep(1);           putmessage('Not enough memory available for this operation',        'Quit the program, then  do a "get info" and assign more memory to DTSA.','','');         exit(D_WDS_Chooser);      end;        thePtr := @Plt_Spec[10]^^.Expt_Info.Detector;    theValues := thePtr^;{this gets some geom stuff: Azimuth,Elevation,Detector_tilt}     with theValues do begin      Spec_Detector_Distance := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;       X_Tilt := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;       Y_Tilt := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;       Take_Off_Angle := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;      end;    DisposePtr(Ptr(thePtr));  END  ELSE theValues := theGenRec^^; { for generate or background subt }*)      IF (theValues.WDS_Resolution > 90.0) THEN theValues.WDS_Resolution := 10.0;      IF WDS_Active THEN  WDS_eV := theValues.dE	  else      IF Si_Active OR Ge_Active  THEN EDS_eV := theValues.dE;        GetDialogItem(GetSelection, I_TOA, DType, DItem, tempRect);      RealToString(theValues.Take_Off_Angle, 5, 5, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);      RealToString(theValues.WDS_Resolution, 5, 2, str);      SetDialogItemText(DItem, str);      ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;            GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            theValues.WDS_Resolution := MyStr2Num(sTemp);            IF (theValues.WDS_Resolution > 90.0) THEN              BEGIN                IF NOT answermessage('The resolution is >90 eV.', 'This is rather high for WDS.', 'However, If IT`S OK I`ll go on,'                                     , 'otherwise you can change the value.') THEN                  ExitDialog := FALSE;              END;          END;        IF (itemHit = I_Cancel) THEN          BEGIN            DisposeDialog(GetSelection);            exit(D_WDS_Chooser);          END;        IF (itemHit = I_Help) THEN          BEGIN            Help;          END;        IF (itemHit = I_Geom) THEN          BEGIN            WITH theValues DO              BEGIN                geom.Spec_Det_Dist := Spec_Detector_Distance;                geom.X_Tilt_angle := X_Tilt;                geom.Y_Tilt_angle := Y_Tilt;                geom.Angle_of_TakeOff := Take_Off_Angle;                geom.Azimuthal_angle := Azimuth;                geom.elevation_angle := Elevation;                geom.Beta_Angle := Detector_tilt;                geom.Angle_of_TakeOff := Take_Off_Angle;                {geom.Beam_Entry_Angle := already stored for old vals; calculated for new}              END; { WITH...}            IF Called_for_Work_Spec THEN              D_Detector_Geometry { #3091 }            ELSE Generate_Detector_Geometry; { #3093 }   {#3092 is called from spectrum_header but it should be replaced with #3091     with the tilts and distance shown but greyed out so user knows if he needs     to edit them}	 			OutlineButton(GetSelection, 1, 16);            WITH theValues DO              BEGIN { new/old geom values go back to theValues }                Spec_Detector_Distance := geom.Spec_Det_Dist;                X_Tilt := geom.X_Tilt_angle;                Y_Tilt := geom.Y_Tilt_angle;                Take_Off_Angle := geom.Angle_of_TakeOff;                Azimuth := geom.Azimuthal_angle;                Elevation := geom.elevation_angle;                Detector_tilt := geom.Beta_Angle;                Take_Off_Angle := geom.Angle_of_TakeOff;                {geom.Beam_Entry_Angle := already stored for old vals; calculated for new}              END; { WITH...}          END;        IF (itemHit >= I_MYR) AND (itemHit <= I_User2) THEN          BEGIN            FOR Index := I_MYR TO I_User2 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            IF itemHit = I_MYR THEN WDS_Two_d := WDS_MYR;            IF itemHit = I_NaCl THEN WDS_Two_d := WDS_NaCl;            IF itemHit = I_KAP THEN WDS_Two_d := WDS_KAP;            IF itemHit = I_RAP THEN WDS_Two_d := WDS_RAP;            IF itemHit = I_TAP THEN WDS_Two_d := WDS_TAP;            IF itemHit = I_PET THEN WDS_Two_d := WDS_PET;            IF itemHit = I_LiF THEN WDS_Two_d := WDS_LiF;            IF itemHit = I_LOD THEN WDS_Two_d := WDS_LOD;            IF itemHit = I_LDE1 THEN WDS_Two_d := WDS_LDE1;            IF itemHit = I_V_C THEN WDS_Two_d := WDS_V_C;            IF itemHit = I_MoB4C THEN WDS_Two_d := WDS_MoB4C;            IF itemHit = I_SiO2_1011 THEN WDS_Two_d := WDS_SiO2_1011;            IF itemHit = I_SiO2_1010 THEN WDS_Two_d := WDS_SiO2_1010;            IF itemHit = I_Si THEN WDS_Two_d := WDS_Si;            IF itemHit = I_Graphite THEN WDS_Two_d := WDS_Graphite;            IF itemHit = I_Pb_Stearate THEN WDS_Two_d := WDS_Pb_Stearate;            IF itemHit = I_Mica THEN WDS_Two_d := WDS_Mica;            IF itemHit = I_EDDT THEN WDS_Two_d := WDS_EDDT;            IF itemHit = I_User1 THEN WDS_Two_d := WDS_User1;            IF itemHit = I_User2 THEN WDS_Two_d := WDS_User2;            GetDialogItem(GetSelection, I_2d, DType, DItem, tempRect);            RealToString(WDS_Two_d, 5, 5, str);            SetDialogItemText(DItem, str);          END;        IF (itemHit = I_One_Coeff) THEN          BEGIN            GetDialogItem(GetSelection, I_One_Coeff, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            IF (MyStr2Num(sTemp) < 0) OR (MyStr2Num(sTemp) > 1.0) THEN              BEGIN                putmessage('Value must be between 0 and 1. A value of zero means the profile will',                           'be pure Lorentzian, and a value one means a pure Gauss curve.', '', '');                one_Coeff := 0.5;                RealToString(one_Coeff, 5, 5, str);                SetDialogItemText(DItem, str);              END;          END;      UNTIL ExitDialog;      Index := I_MYR;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        temp := GetControlValue(controlhandle(DItem));        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > I_User2);      temp := Index - I_MYR + 1;      GetDialogItem(GetSelection, I_One_Coeff, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      one_Coeff := MyStr2Num(sTemp);      {Pierson_Num := one_Coeff;}      GetDialogItem(GetSelection, I_Two_Coeff, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      two_Coeff := MyStr2Num(sTemp);      GetDialogItem(GetSelection, I_TOA, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      theValues.Take_Off_Angle := MyStr2Num(sTemp);      GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      theValues.WDS_Resolution := MyStr2Num(sTemp);      theValues.Detector.Spec := WDS;	  theValues.dE := WDS_eV;      IF (Called_for_Work_Spec) THEN Values_to_Work; { only some change; maybe this should go after accept in the header dialog???                                                       }      tempRect := GetSelection^.portRect;      DisposeDialog(GetSelection);      FillWhiteSpace(tempRect);    END; { D_WDS_Chooser }  PROCEDURE Detector_Parameters;        VAR      str1                          : str255;    BEGIN      IF WDS_Active THEN D_WDS_Chooser      ELSE D_Si_Li_Parameters; { At this point, the values read from the dialogs are in theValues...they go to   theGenRec or Plt_SPec[10] only if you Edit the Header or Generate. }      IF (WDS_Active) AND (theValues.WDS_Resolution > 90.0) THEN        BEGIN          RealToString(theValues.WDS_Resolution, 5, 2, str1);          str1 := CONCAT('Uh-Oh! The  resolution is ', str1, ' eV; that`s high for a WDS spectrometer.');          theValues.WDS_Resolution := 15.0;          IF NOT answermessage(str1, 'If IT`S OK, I will change it to 15 eV.',                               'If IT`S NOT OK, either go back to the Detector Dialog and',                               'change the resolution, or I`ll use the high value.') THEN            ExitDialog := FALSE;        END;      IF (Si_Active) AND (theValues.Si_Resolution < 1.0) THEN        BEGIN          RealToString(theValues.Si_Resolution, 5, 2, str1);          (*theValues.Si_Resolution := 145.0;*)          str1 := CONCAT('Uh-Oh! The detector resolution is ', str1, ' eV; that`s too low for an EDS spectrometer.');          IF NOT answermessage(str1, 'If IT`S OK, I will change it to 145 eV.',                               'If IT`S NOT OK, then go back to the Detector Dialog and',                               'change the resolution to what you want greater than 100 eV.') THEN            ExitDialog := FALSE;        END;    END; { PROCEDURE Detector_Parameters; }  FUNCTION DateStr2Lint(thestr: str255; is_PM: boolean): longint;        VAR      theLint, theSecs              : longint;      Index, max                    : integer;      str8                     : str255;{1} BEGIN      str8 := '';	  max := Length(thestr);	  theDateTime.second := 0;	  theDateTime.day := 0;	  theDateTime.minute := 0;	  theDateTime.hour := 0;	  theDateTime.year := 0;	  theDateTime.month := 0;      Index := 1;      REPEAT	    if (ord(thestr[Index]) < 58) and (ord(thestr[Index]) > 47)        	then str8 := CONCAT(str8, thestr[Index]);        Index := Index + 1;      UNTIL ( index > max) or (ord(thestr[Index]) > 57) or (ord(thestr[Index]) < 48);      StringToNum(str8, theLint);      theDateTime.day := theLint;{2}   if index < max then begin		{index was not a number so increment it again if < max}		str8 := '';		Index := Index + 1;		REPEAT		  if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)			  then str8 := CONCAT(str8, thestr[Index]);		  Index := Index + 1;		UNTIL ( index > max) or (ord(thestr[Index]) > 57) or (ord(thestr[Index]) < 48);		StringToNum(str8, theLint);		theDateTime.month := theLint;		{3} 	if index < max then begin		  {index was not a number so increment it again if < max}		  str8 := '';		  Index := Index + 1;		  REPEAT			if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)				then str8 := CONCAT(str8, thestr[Index]);			Index := Index + 1;		  UNTIL ( index > max) or (ord(thestr[Index]) > 57) or (ord(thestr[Index]) < 48);		  StringToNum(str8, theLint);		  IF theLint < 100 THEN {assume only last 1 or 2 digits of year given, ie 4 0f 2004}			IF theLint < 60 THEN theLint := theLint + 2000			ELSE theLint := 1900 + theLint;		  theDateTime.year := theLint;		  {4}	      if index < max then begin			{index was not a number so increment it again if < max}			str8 := '';			Index := Index + 1;			REPEAT			  if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)				  then str8 := CONCAT(str8, thestr[Index]);			  Index := Index + 1;			UNTIL ( index > max) or (ord(thestr[Index]) > 57) or (ord(thestr[Index]) < 48);			StringToNum(str8, theLint);			IF ((is_PM) AND (theLint < 12)) THEN theLint := theLint + 12			ELSE IF ((theLint = 12) AND (NOT is_PM)) THEN theLint := 0;			theDateTime.hour := theLint;		   {5}		    if index < max then begin			  {index was not a number so increment it again if < max}			  str8 := '';			  Index := Index + 1;			  REPEAT				if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)					then str8 := CONCAT(str8, thestr[Index]);				Index := Index + 1;			  UNTIL ( index > max) or (ord(thestr[Index]) > 57) or (ord(thestr[Index]) < 48);			  StringToNum(str8, theLint);			  theDateTime.minute := theLint;			  {6}		      if index < max then begin				{index was not a number so increment it again if < max}				str8 := '';				Index := Index + 1;				REPEAT				  if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)					  then str8 := CONCAT(str8, thestr[Index]);				  Index := Index + 1;				UNTIL ( index > max) or (ord(thestr[Index]) > 57) or (ord(thestr[Index]) < 48);				StringToNum(str8, theLint);				theDateTime.second := theLint;{6}	 	      END;	{index < max...){5}	 	    END;	{index < max...){4} 	  END;	{index < max...){3}     END;	{index < max...){2}   END;	{index < max...}	   DateToSeconds(theDateTime, theSecs);{converts theDateTime record to secs}	   DateStr2Lint := theSecs;	{assigns secs value to function}{1} END; {Function DateStr2Lint(theStr:str255,is_PM:boolean):longint;}  {$S Physics_Windows6 }(*  PROCEDURE D_Num_Channels_forFile;    CONST      Display_Accept                = 1;      Display_Cancel                = 2;      Display_256                   = 9;      Display_512                   = 10;      Display_1024                  = 11;      Display_2048                  = 12;      Display_4096                  = 13;      Display_8192                  = 14;      Message_1                     = 17;      Message_2                     = 7;    VAR      Display_GetSelection          : DialogPtr;      {Name of dialog}      Display_Rect                  : Rect;           {Temporary tectangle}      Display_DType                 : integer;      Display_Index                 : integer;      Display_DItem                 : Handle;      Display_CItem                 : controlhandle;      Display_CTempItem             : controlhandle;      Display_itemHit               : integer;      Display_temp                  : integer;        {Get selection, Display_temp holding}      Index                         : integer;      sTemp, str, str1              : str255;      errCode                       : integer;      refnum                        : integer;      bytecount                     : longint;      Display_ExitDialog            : boolean;      DType                         : integer;      DItem                         : Handle;    PROCEDURE Refresh_Dialog;            VAR        rDisplay_Rect                 : Rect;         {Display_temp rectangle used for drawing}        Index                         : integer;        str                           : str255;      BEGIN        SetPort(Display_GetSelection);        OutlineButton(Display_GetSelection, 1, 16); { outline the accept button }        FOR Index := Display_256 TO Display_8192 DO {9 to14}          BEGIN            GetDialogItem(Display_GetSelection, Index, Display_DType, Display_DItem, Display_Rect);            Display_CItem := Pointer(Display_DItem);            IF (theValues.number_of_channels = 2 ** (Index - 9) * 256) THEN SetControlValue(Display_CItem, 1)            ELSE SetControlValue(Display_CItem, 0);          END; { FOR index ...}      END; {PROCEDURE Refresh_Dialog;}    BEGIN {PROCEDURE D_Display_Parameters...}      Display_GetSelection := GetNewDialog(753, NIL, Pointer( - 1));      ShowWindow(Display_GetSelection);      SelectWindow(Display_GetSelection);      SetPort(Display_GetSelection);      OutlineButton(Display_GetSelection, 1, 16); { outline the accept button }      {еееееееее Setup initial conditions еееееееееее}      Refresh_Dialog; { puts up the dialog with theValue values }      Display_ExitDialog := FALSE;      IF save_work_open THEN        BEGIN          str := CONCAT('NOTE !!! You already have a file open for saving into, you will not ',                        'be able to change the "number of channels" quantity for it. The only ',                        'purpose in changing the number is if you are about to create a new file. ');          str1 := CONCAT('The active file for saving into is ее ', Write_DTSA_Spec.name, ' ее');          GetDialogItem(Display_GetSelection, Message_1, DType, DItem, tempRect);          SetDialogItemText(DItem, str);          GetDialogItem(Display_GetSelection, Message_2, DType, DItem, tempRect);          SetDialogItemText(DItem, str1);        END;      REPEAT        ModalDialog(@DefaultFilter, Display_itemHit);        GetDialogItem(Display_GetSelection, Display_itemHit, Display_DType, Display_DItem, Display_Rect); {Get item information}        Display_CItem := Pointer(Display_DItem);        IF (Display_itemHit = Display_Cancel) THEN          BEGIN            DisposeDialog(Display_GetSelection);            exit(D_Num_Channels_forFile);          END;        IF (Display_itemHit >= Display_256) AND (Display_itemHit <= Display_8192) THEN          BEGIN            FOR Display_Index := Display_256 TO Display_8192 DO              BEGIN                GetDialogItem(Display_GetSelection, Display_Index, Display_DType, Display_DItem, Display_Rect);                Display_CTempItem := Pointer(Display_DItem);                SetControlValue(Display_CTempItem, 0);              END;            SetControlValue(Display_CItem, 1); { for the itemhit }          END;        IF (Display_itemHit = Display_Accept) THEN          BEGIN            Display_ExitDialog := true;            Display_Index := Display_256;            REPEAT              Display_Index := Display_Index + 1;              GetDialogItem(Display_GetSelection, Display_Index, Display_DType, Display_DItem, Display_Rect);              Display_CItem := Pointer(Display_DItem); {Change dialog handle to control handle}              Display_temp := GetControlValue(Display_CItem);            UNTIL (Display_temp = 1) OR (Display_Index = Display_8192);            IF (Display_temp = 1) THEN              BEGIN                theValues.number_of_channels := 2 ** (Display_Index - 9) * 256;                theRange_keeper := Display_Index - 4; {not leaving the display as it was}                numtostring(theValues.number_of_channels, str);                {putmessage('theValues.number_of_channels is',str,'','');}              END { if (Display_temp = 1) then begin...}            ELSE              BEGIN                Display_ExitDialog := FALSE;                putmessage('Something is wrong!', 'I found all Number of Channels buttons off!', '', '');              END;          END; { IF (Display_itemHit = Display_Accept)...}      UNTIL Display_ExitDialog;		Spectrum_Size := theValues.number_of_channels;      DisposeDialog(Display_GetSelection);		UpDate_SiLi_Window(SiLiWindow);    END; {End of procedure D_Num_Channels_forFile}*)  PROCEDURE D_Expt_Hdr;    CONST      I_Accept                      = 1;      I_Cancel                      = 2;             {button}      I_EDS                         = 4;              {radio butt}      I_WDS                         = 5;              {radio butt}      I_EELS                        = 6;              {radio butt}      I_Analyst                     = 10;             {edit text}      I_Spec_Comments               = 11;             {edit text}      I_Expt_Title                  = 13;             {edit text}      I_Date                        = 14;             {edit text}      I_kV                          = 16;             {edit text}      I_EDIT                        = 17;             {button}      I_detector                    = 18;             {button}      I_Instruct                    = 19;      I_Today                       = 20;      I_AM                          = 21;      I_PM                          = 22;      I_DatetoAll                   = 23;      I_Help                        = 25;             {button}      I_Channel_Info                = 26;             {button}    VAR      ExitDialog, DoTheEdit, isPM, copy, today     : boolean;      GetSelection                          : DialogPtr;      tempRect                              : Rect;      DType, Index, itemHit, errCode, temp  : integer;      DItem                                 : Handle;      CItem			                        : controlhandle;      sTemp                                 : str255;      bytecount, theLint   					: longint;      str, str1, str2, str3                 : str255;        PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    PROCEDURE Help;	{Experiment Header help}      VAR        tempRect                      : Rect;        offset                        : integer;        Left                          : integer;        Top                           : integer;        n                             : integer;        G_Help                        : DialogPtr;        itemHit                       : integer;        DType                         : integer;        DItem                         : Handle;        str                           : str255;            CONST        G_Accept                      = 1;      BEGIN        G_Help := GetNewDialog(433, NIL, Pointer( - 1));        ShowWindow(G_Help);        SelectWindow(G_Help);        SetPort(G_Help);        OutlineButton(G_Help, 1, 16); { outline the OK button }        SetFont('Monaco', 9, []);        offset := 12;        Left := 5;        Top := 15;        n := 0;        moveto(Left, Top);        DrawString('This dialog permits editing those quantities that are common to all spectra in an');        n := n + 1;        moveto(Left, Top + n * offset);        str := 'already existing disk file. It also serves the purpose of creating valid and appropriate';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'fields for a new disk file or for the spectrum in WORK.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'The EELS (electron energy loss feature is not available in this version of DTSA.) ';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'If there is a file of DTSA spectra active for reading, then it is possible to "Edit" the';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'Experiment Header of this file by entering your desired changes then pushing the еEditе...';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'button.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);          IF (itemHit = G_Accept) THEN            BEGIN              ExitDialog := true;            END;        UNTIL ExitDialog;        ExitDialog := FALSE;        DisposeDialog(G_Help);		  beginupdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);      END; {End of G_Help procedure}    BEGIN { PROCEDURE D_Expt_Hdr; }      GetSelection := GetNewDialog(4553, NIL, Pointer( - 1));      SelectWindow(GetSelection);      ShowWindow(GetSelection);      SetPort(GetSelection);      OutlineButton(GetSelection, 1, 16); { outline the accept button }      thePtr := SiLi_RecPtr(NewPtr(SizeOf(Sili_Rec)));      IF thePtr = NIL THEN        BEGIN          SysBeep(1);          putmessage('Not enough memory available for this operation',                     'Quit the program, then  do a "get info" and assign more memory to DTSA.', '', '');          exit(D_Expt_Hdr);        END;      thePtr := @Plt_spec[10]^^.Expt_Info.Detector;      theValues := thePtr^; {this gets some geom stuff: Azimuth,Elevation,Detector_tilt}      sTemp := '';      Response_InTo_Results := FALSE;      IF (saved_displayed) THEN        BEGIN          str1 := 'Date/Time displayed spectrum was created (in file open to read).';          str2 := 'File Date/Time cannot be edited. The Spectrum Header ';          str3 := 'dialog also displays this information for each spectrum.';		  sTemp := CONCAT(str1, str2, str3);        END      ELSE        BEGIN { grey stuff out }          GetDialogItem(GetSelection, I_EDIT, DType, DItem, tempRect);          HiliteControl(controlhandle(DItem), 255);          GetDialogItem(GetSelection, I_DatetoAll, DType, DItem, tempRect);          HiliteControl(controlhandle(DItem), 255);          GetDialogItem(GetSelection, I_PM, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 0);          GetDialogItem(GetSelection, I_AM, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 0);        END; {IF (saved_displayed)...ELSE BEGIN...}	      GetDialogItem(GetSelection, I_DatetoAll, DType, DItem, tempRect);          HideControl(controlhandle(DItem));	   	   GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect); 		HiliteControl(controlhandle(DItem), 255);      textface([italic]);      GetDialogItem(GetSelection, I_Instruct, DType, DItem, tempRect); {Get the item handle}      SetDialogItemText(DItem, sTemp);      textface([]);      WITH theValues DO        BEGIN          Spec_Detector_Distance := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;          X_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;          Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;          Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;        END; {with...}(*е If we want the datetime of the expt header to be the datetime of the 1st spec in   the file we need to get this info...}	  errCode := FSOpen(RdBinaryName, Binary_VolNum_Read, Hold_RefNum);	  bytecount := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) + SizeOf(Spectrum_InfoRec) +	              7 * SizeOf(real);	  errCode := setFPos(Hold_RefNum,fsFromStart,bytecount);	  bytecount := sizeof(real);	  errcode := FSRead(Hold_RefNum,bytecount,@theLint);      errCode := FSClose(Hold_RefNum);	  SecondsToDate(theLint, theDateTime);*){If we want the datetime of the expt header to be the datetime of the displayed spec...}  		  SecondsToDate(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time, theDateTime);		  theLint := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time;          GetDialogItem(GetSelection, I_Date, DType, DItem, tempRect);          SetDialogItemText(DItem, DTRec2Str); {DTSA: converts theDateTime to string}          IF (theDateTime.hour) >= 12 THEN            BEGIN              GetDialogItem(GetSelection, I_PM, DType, DItem, tempRect);              SetControlValue(controlhandle(DItem), 1);            END          ELSE            BEGIN              GetDialogItem(GetSelection, I_AM, DType, DItem, tempRect);              SetControlValue(controlhandle(DItem), 1);            END;      {DisposePtr(Ptr(thePtr));}      GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      GetDialogItem(GetSelection, I_WDS, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      IF (Plt_spec[10]^^.Expt_Info.Detector.Spec = WDS) THEN        BEGIN          GetDialogItem(GetSelection, I_WDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 1);          WDS_Active := true; { boolean determines which detector dialog appears }          Si_Active := FALSE;          Ge_Active := FALSE;        END;               IF Plt_spec[10]^^.Expt_Info.Detector.Spec = EELS THEN          BEGIN            GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);            WDS_Active := FALSE;            Si_Active := FALSE;            Ge_Active := FALSE;          END;         		 IF (Plt_spec[10]^^.Expt_Info.Detector.Spec = EDS) THEN          BEGIN            GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);            WDS_Active := FALSE;			IF (Plt_spec[10]^^.Expt_Info.Detector.ID = 2) then begin				Si_Active := FALSE;				Ge_Active := true;			end			else begin				Si_Active := true;				Ge_Active := FALSE;			end;          END;      GetDialogItem(GetSelection, I_Analyst, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.Expt_Info.Analyst);      GetDialogItem(GetSelection, I_Expt_Title, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.Expt_Info.Specimen_ID);      GetDialogItem(GetSelection, I_Spec_Comments, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.Expt_Info.Specimen_Comment_Field);      GetDialogItem(GetSelection, I_kV, DType, DItem, tempRect);      RealToString(Plt_spec[10]^^.Expt_Info.kV, 5, 2, str);      SetDialogItemText(DItem, str);	  		Refresh_Dialog;      ExitDialog := FALSE;      DoTheEdit := FALSE;      copy := FALSE;	  today := FALSE;		DisposePtr(Ptr(thePtr));		thePtr := NIL;      Called_for_Work_Spec := true;      called_for_generate := FALSE;      REPEAT { until exit_dialog }        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;          END;        IF (itemHit = I_Help) THEN          BEGIN            Help;			Refresh_Dialog;          END;        {```}       (* IF (itemHit = I_Channel_Info) THEN          BEGIN            D_Num_Channels_forFile;			Refresh_Dialog;          END;	   *)      (* IF (itemHit = I_DatetoAll) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN copy := true            ELSE copy := FALSE;          END;*)        IF (itemHit = I_EDIT) THEN          BEGIN            IF (NOT saved_displayed) THEN              BEGIN                BeepBeep;                putmessage('A saved DTSA file must be active ', 'to use the "Edit" feature.', '', '');              END { if MCA_Spectrum_Active = False...}            ELSE              BEGIN                IF answermessage('Are you sure you want to replace the EXPERIMENT HEADER',                                 'information with the values from the dialog(s)??? If "Its OK"',                                 'the operation will be done when you hit the OK button', '') THEN                  DoTheEdit := true                ELSE DoTheEdit := FALSE;              END;          END;        IF (itemHit = I_Cancel) THEN          BEGIN            ExitDialog := true;          END;	        IF (itemHit = I_detector) THEN          BEGIN     {we copied Plt_spec[10] stuff to theValues; if accept header dialog      then theValues go to Plt_Spec[10]; we need the current value of kV for   sili_response calculation if chosen so...}    {we don't do the sili calc until we accept the header dialog so...     GetDialogItem(GetSelection, I_kV, DType, DItem, tempRect);     GetDialogItemText(DItem, sTemp);     theValues.kV := MyStr2Num(sTemp); }            Detector_Parameters; { PROCEDURE D_Expt_Hdr; }			Refresh_Dialog;          END;        IF (itemHit = I_Today) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN              BEGIN			   today := true;			   GetDateTime(theLint);			 END			 ELSE BEGIN			   today := false;			   theLint := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time;			 END;			 SecondsToDate(theLint, theDateTime);			 GetDialogItem(GetSelection, I_Date, DType, DItem, tempRect);			 SetDialogItemText(DItem, DTRec2Str);			 IF (theDateTime.hour) >= 12 THEN			   BEGIN				 GetDialogItem(GetSelection, I_PM, DType, DItem, tempRect);				 SetControlValue(controlhandle(DItem), 1);				 GetDialogItem(GetSelection, I_AM, DType, DItem, tempRect);				 SetControlValue(controlhandle(DItem), 0);			   END			 ELSE			   BEGIN				 GetDialogItem(GetSelection, I_AM, DType, DItem, tempRect);				 SetControlValue(controlhandle(DItem), 1);				 GetDialogItem(GetSelection, I_PM, DType, DItem, tempRect);				 SetControlValue(controlhandle(DItem), 0);			   END;          END;	{IF (itemHit = I_Today) THEN...}        IF (itemHit = I_AM) OR (itemHit = I_PM) THEN          FOR Index := I_AM TO I_PM DO            BEGIN              GetDialogItem(GetSelection, Index, DType, DItem, tempRect);              temp := GetControlValue(controlhandle(DItem));              SetControlValue(controlhandle(DItem), (temp + 1) MOD 2);            END;        IF (itemHit = I_EDS) then	  begin	    GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect); 		SetControlValue(controlhandle(DItem),1);	    GetDialogItem(GetSelection, I_WDS, DType, DItem, tempRect); 		SetControlValue(controlhandle(DItem),0);	    GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect); 		SetControlValue(controlhandle(DItem),0);		WDS_Active := FALSE;		Si_Active := true;		Ge_Active := FALSE; 		EDS_eV := Plt_spec[10]^^.Expt_Info.dE;	{ее3/5/94ее}		theValues.dE := EDS_eV;		{Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := true;}		Detector_Parameters; { PROCEDURE D_Expt_Hdr; }		Refresh_Dialog;		EDS_eV := theValues.dE;	  end;      IF (itemHit = I_WDS) then	  begin	    GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect); 		SetControlValue(controlhandle(DItem),0);	    GetDialogItem(GetSelection, I_WDS, DType, DItem, tempRect); 		SetControlValue(controlhandle(DItem),1);	    GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect); 		SetControlValue(controlhandle(DItem),0);		WDS_Active := true;		Si_Active := FALSE;		Ge_Active := FALSE; 		WDS_eV := Plt_spec[10]^^.Expt_Info.dE;	{ее3/5/94ее}		theValues.dE := WDS_eV;		if NOT WDS_Convert_only_X_axis then		Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := FALSE		else		Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := true;		Detector_Parameters; { PROCEDURE D_Expt_Hdr; }		Refresh_Dialog;		WDS_eV := theValues.dE;	  end;        UNTIL ExitDialog;      IF (itemHit <> I_Cancel) THEN        BEGIN          GetDialogItem(GetSelection, I_kV, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          theValues.kV := MyStr2Num(sTemp);          Values_to_Work;          IF Do_a_Calc THEN            BEGIN              Set_Response_Bool(theBGRec, sili_response_calculated);              IF (sili_response_calculated) THEN BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, SizeOf(Det_Effic_P^))              ELSE                BEGIN                  theBGRec^^ := theValues;                  Detector_efficiency(theBGRec, sili_response_calculated);                END;              IF Response_InTo_Results THEN                BEGIN                  BlockMove(@Det_Effic_P^, @Plt_spec[9]^^.S, SizeOf(Plt_spec[9]^^.S));                  Spectrum_Full[9] := true;                  CheckItem(FullMenu, a^.C_Full[9], Spectrum_Full[9]);                  UpDate_Max_Min(9);                END;            END;          GetDialogItem(GetSelection, I_Analyst, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          IF length(sTemp) > 50 THEN            BEGIN              putmessage('The Analyst field is limited to 50 characters, I will truncate what you entered', 'to this length.', '',                         '');              temp := length(sTemp);              FOR Index := temp DOWNTO 51 DO                Delete(sTemp, Index, 1);            END;          Plt_spec[10]^^.Expt_Info.Analyst := sTemp;          GetDialogItem(GetSelection, I_Spec_Comments, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          IF length(sTemp) > 255 THEN            BEGIN              putmessage('The Comment field is limited to 255 characters, I will truncate what you entered', 'to this length.', '',                         '');              temp := length(sTemp);              FOR Index := temp DOWNTO 255 DO                Delete(sTemp, Index, 1);            END;          Plt_spec[10]^^.Expt_Info.Specimen_Comment_Field := sTemp;          GetDialogItem(GetSelection, I_Expt_Title, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          IF length(sTemp) > 50 THEN            BEGIN              putmessage('The title field is limited to 50 characters, I will truncate what you entered', 'to this length.', '', '')               ;              temp := length(sTemp);              FOR Index := temp DOWNTO 51 DO                Delete(sTemp, Index, 1);            END;          Plt_spec[10]^^.Expt_Info.Specimen_ID := sTemp;		  GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect);          temp := GetControlValue(controlhandle(DItem));          IF temp = 1 THEN Plt_spec[10]^^.Expt_Info.Detector.Spec := EDS          ELSE Plt_spec[10]^^.Expt_Info.Detector.Spec := WDS;          WITH Plt_spec[10]^^, Expt_Info, SpectrumStuff DO            BEGIN              IF DoTheEdit THEN                BEGIN				  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;                  IF errCode <> NoErr THEN BeepBeep                  ELSE                    BEGIN					  {ееееее set this true to make a demo spectrum ееееее}					  if OptionKeyDown then Plt_spec[10]^^.Expt_Info.spare2 := TRUE					  ELSE Plt_spec[10]^^.Expt_Info.spare2 := False;                      errCode := setfpos_err(Hold_RefNum, FSFromSTART, 0, '');                      bytecount := SizeOf(expt_infoRec);                      errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.Expt_Info, '');  (*Begin_Time Not Editable:    sizecnt := 28 + SizeOf(Spectrum_InfoRec) + SizeOf(Plot_InfoRec) + SizeOf(expt_infoRec);                      bytecount := 4;                      errCode := SetFPos(Hold_RefNum, FSFromSTART, sizecnt);                      errCode := FSWrite(Hold_RefNum, bytecount, @Acq_Info.Begin_Time);*)                    END; { ELSE BEGIN...}                  errCode := FSClose(Hold_RefNum);                  errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                END; { IF DoTheEdit...}				          GetDialogItem(GetSelection, I_Date, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          str := CONCAT(sTemp[1], sTemp[2]);		  {The date that shows in expt header window is displayed spectrum date.		   Cannot change the date on a saved file.If generated or acquired it will have		   the correct date... of its creation. If from foreign format will have translation date???}		  			IF (today or (str = 'DD')) {put in current date and time}				then GetDateTime(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time)			ELSE			BEGIN			  GetDialogItem(GetSelection, I_PM, DType, DItem, tempRect);			  temp := GetControlValue(controlhandle(DItem));			  isPM := FALSE;			  IF temp = 1 THEN isPM := true;			  Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time := DateStr2Lint(sTemp, isPM);			END; { If (today...else}           (*   IF copy THEN                BEGIN { off if ref }				  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;                  IF errCode <> NoErr THEN BeepBeep                  ELSE                    BEGIN                      errCode := GetEOF(Hold_RefNum, theEOF);                      sizecnt := 28 + SizeOf(Spectrum_InfoRec) + SizeOf(Plot_InfoRec) + SizeOf(expt_infoRec);                      bytecount := 4;                      REPEAT                        errCode := SetFPos(Hold_RefNum, FSFromSTART, sizecnt);                        {errCode := FSWrite(Hold_RefNum, bytecount, @Acq_Info.Begin_Time);}                        sizecnt := sizecnt + SizeOf(SpectrumStuff) + Longint(4 * number_of_channels);                      UNTIL sizecnt > theEOF;                    END; { ELSE BEGIN...}                  errCode := FSClose(Hold_RefNum);                  errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                END; { IF copy THEN...}	*)            END; { WITH...}        END; { IF (itemHit <> I_Cancel)...}      tempRect := GetSelection^.portRect;      DisposeDialog(GetSelection);      BeginUpdate(BackPlane);      DrawAxesFull;      update_full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);      Mouse_Active_Window;      update_full;    END; {End of procedure D_Expt_Header}  {=================================}  PROCEDURE D_RefExpt_Hdr;    CONST      I_Accept                      = 1;      I_Cancel                      = 2;              {button}      I_EDS                         = 4;              {radio butt}      I_WDS                         = 5;              {radio butt}      I_EELS                        = 6;              {radio butt}      I_Analyst                     = 10;             {edit text}      I_Spec_Comments               = 11;             {edit text}      I_Expt_Title                  = 13;             {edit text}      I_Date                        = 14;             {edit text}      I_kV                          = 16;             {edit text}      I_EDIT                        = 17;             {button}      I_detector                    = 18;             {button}      I_Instruct                    = 19;    VAR      ExitDialog, DoTheEdit			: boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType, Index, itemHit, errCode, temp: integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      bytecount						: longint;      str, str1, str2, str3         : str255;    PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN { PROCEDURE D_RefExpt_Hdr; }      GetSelection := GetNewDialog(132, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      OutlineButton(GetSelection, I_Accept, 16); { outline the accept button }      thePtr := SiLi_RecPtr(NewPtr(SizeOf(Sili_Rec)));      IF thePtr = NIL THEN        BEGIN          SysBeep(1);          putmessage('Not enough memory available for this operation',                     'Quit the program, then  do a "get info" and assign more memory to DTSA.', '', '');          exit(D_RefExpt_Hdr);        END;      thePtr := @Plt_spec[10]^^.Expt_Info.Detector;      theValues := thePtr^; {this gets some geom stuff: Azimuth,Elevation,Detector_tilt}      DisposePtr(Ptr(thePtr));      thePtr := NIL;      GetDialogItem(GetSelection, I_Analyst, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.Expt_Info.Analyst);      GetDialogItem(GetSelection, I_Expt_Title, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.Expt_Info.Specimen_ID);      GetDialogItem(GetSelection, I_Spec_Comments, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.Expt_Info.Specimen_Comment_Field);      GetDialogItem(GetSelection, I_kV, DType, DItem, tempRect);      RealToString(Plt_spec[10]^^.Expt_Info.kV, 5, 2, str);      SetDialogItemText(DItem, str);   (*  GetDialogItem(GetSelection, I_Edit, DType, DItem, tempRect);     CItem := POINTER(DItem);     HiliteControl(CItem, 0);  *)      sTemp := '';      IF Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated THEN        str1 := 'Date/Time the spectrum for the first reference was generated.'      ELSE str1 := 'Date/Time the spectrum for the first reference was acquired.';      str2 := ' Date/Time and most other reference information cannot be changed.';      str3 := ' Please use SHOW HEADER for complete information on this reference. ';      sTemp := CONCAT(str1, str2, str3);      textface([italic]);      GetDialogItem(GetSelection, I_Instruct, DType, DItem, tempRect); {Get the item handle}      SetDialogItemText(DItem, sTemp);      textface([]);      sTemp := '';      SecondsToDate(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time, theDateTime);      sTemp := DTRec2Str;      IF (theDateTime.hour) >= 12 THEN sTemp := CONCAT(sTemp, ' PM')      ELSE sTemp := CONCAT(sTemp, ' AM');      GetDialogItem(GetSelection, I_Date, DType, DItem, tempRect);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      GetDialogItem(GetSelection, I_WDS, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 0);      IF (Plt_spec[10]^^.Expt_Info.Detector.Spec = WDS) THEN        BEGIN          GetDialogItem(GetSelection, I_WDS, DType, DItem, tempRect);          SetControlValue(controlhandle(DItem), 1);          WDS_Active := true; { boolean determines which detector dialog appears }          Si_Active := FALSE;          Ge_Active := FALSE;         END;               IF Plt_spec[10]^^.Expt_Info.Detector.Spec = EELS THEN          BEGIN            GetDialogItem(GetSelection, I_EELS, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);            WDS_Active := FALSE;            Si_Active := FALSE;            Ge_Active := FALSE;          END;		  IF Plt_spec[10]^^.Expt_Info.Detector.Spec = EDS THEN           BEGIN            GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);            WDS_Active := FALSE;            Si_Active := True;            Ge_Active := FALSE;          END;      ExitDialog := FALSE;      DoTheEdit := FALSE;      Called_for_Work_Spec := FALSE; { ?? was true but this dialog is not for a spectrum}      called_for_generate := FALSE;      REPEAT { until exit_dialog }        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := true;          END;         (*IF (itemHit = I_Help) THEN            BEGIN             Help;          END;*)        IF (itemHit = I_EDIT) THEN          BEGIN            IF answermessage('Are you sure you want to replace the EXPERIMENT HEADER',                             'information with the values from the dialog(s)??? If "Its OK"',                             'the operation will be done when you hit the ACCEPT button', '') THEN              DoTheEdit := true            ELSE DoTheEdit := FALSE;          END;        IF (itemHit = I_Cancel) THEN          BEGIN            ExitDialog := true;          END;        IF (itemHit = I_detector) THEN          BEGIN     {we copied Plt_spec[10] stuff to theValues; if accept in the dialog      then theValues go to Plt_Spec[10]; we need the current value of kV for   sili_response calculation if chosen so...}            GetDialogItem(GetSelection, I_kV, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            theValues.kV := MyStr2Num(sTemp);            Detector_Parameters; { PROCEDURE D_Expt_Hdr; }            Refresh_Dialog;          END;        IF (itemHit = I_EDS) OR (itemHit = I_WDS) THEN          BEGIN            FOR Index := I_EDS TO I_WDS DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                CItem := controlhandle(DItem);                temp := GetControlValue(CItem);                SetControlValue(CItem, (temp + 1) MOD 2);              END;            { When loop ends, temp is the value for WDS before the click therefore:}            IF (temp = 0) THEN WDS_Active := true            ELSE WDS_Active := FALSE;            Detector_Parameters; { PROCEDURE D_Expt_Hdr; }            Refresh_Dialog          END;      UNTIL ExitDialog;      IF (itemHit <> I_Cancel) THEN        BEGIN          {```}          Plt_spec[10]^^.Expt_Info.Si_Resolution := theValues.Si_Resolution;          {```}          Plt_spec[10]^^.Expt_Info.WDS_Resolution := theValues.WDS_Resolution;          GetDialogItem(GetSelection, I_Analyst, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          IF length(sTemp) > 50 THEN            BEGIN              putmessage('The Analyst field is limited to 50 characters, I will truncate what you entered', 'to this length.', '',                         '');              temp := length(sTemp);              FOR Index := temp DOWNTO 51 DO                Delete(sTemp, Index, 1);            END;          Plt_spec[10]^^.Expt_Info.Analyst := sTemp;          GetDialogItem(GetSelection, I_Spec_Comments, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          IF length(sTemp) > 255 THEN            BEGIN              putmessage('The Comment field is limited to 255 characters, I will truncate what you entered', 'to this length.', '',                         '');              temp := length(sTemp);              FOR Index := temp DOWNTO 255 DO                Delete(sTemp, Index, 1);            END;          Plt_spec[10]^^.Expt_Info.Specimen_Comment_Field := sTemp;          GetDialogItem(GetSelection, I_Expt_Title, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          IF length(sTemp) > 50 THEN            BEGIN              putmessage('The title field is limited to 50 characters, I will truncate what you entered', 'to this length.', '', '')               ;              temp := length(sTemp);              FOR Index := temp DOWNTO 51 DO                Delete(sTemp, Index, 1);            END;          Plt_spec[10]^^.Expt_Info.Specimen_ID := sTemp;          GetDialogItem(GetSelection, I_kV, DType, DItem, tempRect);          GetDialogItemText(DItem, sTemp);          theValues.kV := MyStr2Num(sTemp);          Plt_spec[10]^^.Expt_Info.kV := theValues.kV;          GetDialogItem(GetSelection, I_EDS, DType, DItem, tempRect);          temp := GetControlValue(controlhandle(DItem));          IF temp = 1 THEN Plt_spec[10]^^.Expt_Info.Detector.Spec := EDS          ELSE Plt_spec[10]^^.Expt_Info.Detector.Spec := WDS;          IF DoTheEdit THEN            WITH Plt_spec[10]^^, Expt_Info, SpectrumStuff DO              BEGIN				errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;                IF errCode <> NoErr THEN BeepBeep                ELSE                  BEGIN                    errCode := setfpos_err(Hold_RefNum, FSFromSTART, 0, '');                    bytecount := SizeOf(expt_infoRec);                    errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.Expt_Info, '');                  END; { ELSE BEGIN...}                errCode := FSClose(Hold_RefNum);                errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);              END; { IF DoTheEdit...}        END; { IF (itemHit <> I_Cancel)...}      tempRect := GetSelection^.portRect;      DisposeDialog(GetSelection);      BeginUpdate(BackPlane);      DrawAxesFull;      update_full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);      Mouse_Active_Window;      update_full;    END; {End of procedure D_Expt_Header}  {=================================}{$S Physics_Windows7 }  PROCEDURE Spec_Det_Params; {geom has Plt_Spec[10] valuesее For the Spectrum Header ее the first time you get here but once you                              acceot this dialog geom keeps what is read from the strings...that's why you need the rtemps, in case                              you exit}    CONST      I_Accept                      = 1;      SpecDetDist                   = 4;      xtilt                         = 6;      ytilt                         = 5;              {``}      TOA                           = 9;      I_beta						= 13;      I_elev						= 11;      I_azim						= 12;      I_Exit                        = 2;    VAR      Geometry_ExitDialog           : boolean;      str                           : str255;      tempRect                      : Rect;      DType                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      Error                         : boolean;      rtemp3, rtemp4, rtemp5, rtemp6: real;    PROCEDURE Get_the_Values;            BEGIN        GetDialogItem(Geom_Dialog, SpecDetDist, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        geom.Spec_Det_Dist := MyStr2Num(sTemp);        GetDialogItem(Geom_Dialog, ytilt, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        geom.Y_Tilt_angle := MyStr2Num(sTemp);        GetDialogItem(Geom_Dialog, xtilt, DType, DItem, tempRect);        GetDialogItemText(DItem, sTemp);        geom.X_Tilt_angle := MyStr2Num(sTemp);      END; { Get_the_Values }    BEGIN {ее For the Spectrum Header ее}      Geom_Dialog := GetNewDialog(3092, NIL, Pointer( - 1));      ShowWindow(Geom_Dialog);      SelectWindow(Geom_Dialog);      SetPort(Geom_Dialog);      OutlineButton(Geom_Dialog, I_Accept, 16); { outline the accept button }      Error := FALSE;      {ееееееееееееееееSetup initial conditionsееееееееееееее}   { hold incoming values: they came from the header, why can't I get them back from there?     Because geom comes from header before the calling dialog repeat begins. We may get here  more than once and the 2nd time the geom is no longer the same as the header     because get_the_values and CalctheAngles uses geom so we must read strings into geom before  we actually accept the values. If you exit rather then accept must be able to get the  incoming geom which may no longer be the header values.}      rtemp4 := geom.Spec_Det_Dist;      rtemp5 := geom.Y_Tilt_angle;      rtemp6 := geom.X_Tilt_angle;      rtemp3 := geom.Angle_of_TakeOff;      { load geom into strings; geom has plt_spec[10]^^ values }      GetDialogItem(Geom_Dialog, I_azim, DType, DItem, tempRect);      RealToString(geom.Azimuthal_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, I_elev, DType, DItem, tempRect);      RealToString(geom.elevation_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, I_beta, DType, DItem, tempRect);      RealToString(geom.Beta_Angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, SpecDetDist, DType, DItem, tempRect);      RealToString(geom.Spec_Det_Dist, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, ytilt, DType, DItem, tempRect);      RealToString(geom.Y_Tilt_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, xtilt, DType, DItem, tempRect);      RealToString(geom.X_Tilt_angle, 3, 2, str);      SetDialogItemText(DItem, str);      GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);      RealToString(geom.Angle_of_TakeOff, 5, 2, str);      str := CONCAT(str, ' Degrees');      SetDialogItemText(DItem, str);      Geometry_ExitDialog := FALSE;      RealToString(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle, 3, 1, str);      str := CONCAT(str, ' Degrees');      GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);      SetDialogItemText(DItem, str);      Geometry_ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(Geom_Dialog, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = ytilt) OR (itemHit = xtilt) OR (itemHit = SpecDetDist) THEN          BEGIN            Get_the_Values;            Calc_the_Angles;            GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);            RealToString(geom.Angle_of_TakeOff, 5, 3, str);            str := CONCAT(str, ' Degrees');            SetDialogItemText(DItem, str);          END;        IF (itemHit = I_Accept) THEN { Button }          BEGIN            GetDialogItem(Geom_Dialog, SpecDetDist, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            geom.Spec_Det_Dist := MyStr2Num(sTemp);            IF (geom.Spec_Det_Dist <= 1.0) OR (geom.Spec_Det_Dist > 500.0) THEN              putmessage(' SiLi-Specimen Distance must be between 1.0 and 500.0 mm !!', '', '', '')            ELSE              BEGIN                GetDialogItem(Geom_Dialog, ytilt, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                geom.Y_Tilt_angle := MyStr2Num(sTemp);                IF (geom.Y_Tilt_angle <= - 90) OR (geom.Y_Tilt_angle >= 90.0) THEN                  putmessage('Y_Tilt must be > -90 and < +90 Degrees !!', 'Angle is relative to the "normal" plane.', '', '')                ELSE                  BEGIN                    GetDialogItem(Geom_Dialog, xtilt, DType, DItem, tempRect);                    GetDialogItemText(DItem, sTemp);                    geom.X_Tilt_angle := MyStr2Num(sTemp);                    IF (geom.X_Tilt_angle <= - 90) OR (geom.X_Tilt_angle >= 90.0) THEN                      putmessage('X_Tilt must be > -90 and < +90 Degrees !!', 'Angle is relative to the "normal" plane.', '', '')                    ELSE                      BEGIN                        Calc_the_Angles;                        RealToString(geom.Angle_of_TakeOff, 5, 2, str);                        str := CONCAT(str, ' Degrees');                        GetDialogItem(Geom_Dialog, TOA, DType, DItem, tempRect);                        SetDialogItemText(DItem, str);                        Geometry_ExitDialog := true;                      END; { else begin }                  END; { Else Begin }              END; { ELSE BEGIN }          END; {IF (itemHit...}        IF (itemHit = I_Exit) THEN { Button }          BEGIN            {replace geom with incoming values }            geom.Angle_of_TakeOff := rtemp3;            geom.Spec_Det_Dist := rtemp4;            geom.Y_Tilt_angle := rtemp5;            geom.X_Tilt_angle := rtemp6;            Geometry_ExitDialog := true;          END;      UNTIL Geometry_ExitDialog;      DisposeDialog(Geom_Dialog);    END; { Spec_Det_Params; for spectrum header }  PROCEDURE Spectrum_Header_Dialog;      CONST      I_Exit                        = 2;              {button}      I_Help                        = 69;              {button}      I_Composition                 = 3;              {button}      I_Specimen_Case               = 4;              {button}      I_EDIT                        = 5;              {check box}      I_13                          = 6;              {radio button}      I_12                          = 7;              {radio button}      I_11                          = 8;              {radio button}      I_10                          = 9;              {radio button}      I_9                           = 10;             {radio button}      I_8                           = 11;             {radio button}      I_7                           = 12;             {radio button}      I_6                           = 13;             {radio button}      I_5                           = 14;             {radio button}      I_4                           = 15;             {radio button}      I_3                           = 16;             {radio button}      I_2                           = 17;             {radio button}      I_1                           = 18;             {radio button}      I_AM                          = 19;             {radio button}      I_PM                          = 20;             {radio button}      I_DELETE_SPECTRUM             = 21;             {button}      I_nA                          = 22;             {radio button}      I_uA                          = 23;             {radio button}      Disp_Spec_Number              = 25;      I_INSERT_SPECTRUM             = 26;             {button}      Detector_Params               = 29;             {Button}      AM_PM                         = 33;             {edit text}      Expt_Title                    = 37;      Edit_Date                     = 39;      I_Subsequent                  = 40;             {checkbox}      I_Get_Next_Head               = 41;             {checkbox}{disabled}      I_Do_Chkd                     = 42;             {button}      I_Clear                       = 44;             {button}      CITZAF_Particle               = 46;             {button}      I_Y_Position                  = 47;      I_X_Position                  = 48;      I_End_Current                 = 49;      I_Begin_Current               = 50;      I_Class_13                    = 51;             {edittext}      I_Class_12                    = 52;             {edittext}      I_Class_11                    = 53;             {edittext}      I_Class_10                    = 54;             {edittext}      I_Class_9                     = 55;             {edittext}      I_Class_8                     = 56;             {edittext}      I_Class_7                     = 57;             {edittext}      I_Class_6                     = 58;             {edittext}      I_Class_5                     = 59;             {edittext}      I_Class_4                     = 60;             {edittext}      I_Class_3                     = 61;             {edittext}      I_Class_2                     = 62;             {edittext}      I_Class_1                     = 63;             {edittext}      I_Spectrum_Comments           = 64;             {edittext}      I_Time                        = 68;      I_OK                   	    = 1; 			  {button}  {I_Attach}      Specimen_Density              = 70;             {edit}      Specimen_Thickness            = 73;             {edit}      I_spec_nm                     = 76;             {radio}      I_spec_um                     = 77;             {radio}      I_spec_mm                     = 78;             {radio}      I_Show_Prv                    = 80;             {button}      I_Show_Nxt                    = 81;             {button}      I_sec                         = 83;             {radio}      I_min                         = 84;             {radio}    VAR      get_next                      : boolean;	  get_Prev                      : boolean;	  edit_subsequent               : boolean;	  do_chkd                       : boolean;	  did_clear                     : boolean;	  message_up                    : boolean;	  ExitDialog                    : boolean;	  attach                        : boolean;      tempRect                      : Rect;      DType                         : integer;      Index, nn, nindex             : integer;      DItem                         : Handle;      CItem, CTempItem              : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      rtemp                         : real {double_t};      errCode                       : integer;      bytecount, notepos,bytestrt   : longint;      bytecount_2                   : longint;      DoTheEdit, isPM               : boolean;      saved_header                  : spectrum_structure;      time_mult, curr_mult, spec_mult: real {double_t};      LastHold                      : integer;      N_Channels                    : longint;      str, str1                     : str255;      T_X_Position                  : real;           { dimensionless }      T_Y_Position                  : real;           { dimensionless }      T_Begin_Faraday               : real;           { nA }      T_End_Faraday                 : real;           { nA }      T_Real_Time                   : real;           { The time on the wall }      T_Live_Time                   : real;      T_RequestedLiveTime           : longint;      T_ActualLiveTime              : longint;      T_Spectrum_Comment_Field      : str255;      T_Spectrum_Class              : STRING[25];      T_Theoretically_Generated     : boolean;      T_This_is_a_Standard          : boolean;      T_BkgSubtracted               : boolean;      T_X_Tilt                      : real;      T_Y_Tilt                      : real;      T_Take_Off_Angle              : real;      T_Spec_Detector_Distance      : real;           { mm }      T_Specimen_Thickness          : real;           { cm }      T_Specimen_Density            : real;           { g/cm sq. }      T_Number_of_Elements          : integer;      T_Weight_Fraction             : ARRAY [1..15] OF real;      T_Atomic_Number               : ARRAY [1..15] OF integer;      T_Valence                     : ARRAY [1..15] OF real;      B_X_Position                  : boolean;      B_Y_Position                  : boolean;      B_Begin_Faraday               : boolean;      B_End_Faraday                 : boolean;      B_Real_Time                   : boolean;      B_Live_Time                   : boolean;      B_RequestedLiveTime           : boolean;      B_ActualLiveTime              : boolean;      B_Spectrum_Comment_Field      : boolean;      B_Spectrum_Class              : boolean;      B_Theoretically_Generated     : boolean;      B_This_is_a_Standard          : boolean;      B_BkgSubtracted               : boolean;      B_X_Tilt                      : boolean;      B_Y_Tilt                      : boolean;      B_Take_Off_Angle              : boolean;      B_Spec_Detector_Distance      : boolean;      B_Specimen_Thickness          : boolean;      B_Specimen_Density            : boolean;      B_Number_of_Elements          : boolean;      B_Weight_Fraction             : ARRAY [1..15] OF boolean;      B_Atomic_Number               : ARRAY [1..15] OF boolean;      B_Valence                     : ARRAY [1..15] OF boolean;    PROCEDURE Help;	{Spectrum_Header help}      VAR        tempRect                      : Rect;        offset                        : integer;        Left                          : integer;        Top                           : integer;        n                             : integer;        G_Help                        : DialogPtr;        itemHit                       : integer;        DType                         : integer;        DItem                         : Handle;      CONST        G_Accept                      = 1;      BEGIN        G_Help := GetNewDialog(433, NIL, Pointer( - 1));        ShowWindow(G_Help);        SelectWindow(G_Help);        SetPort(G_Help);        OutlineButton(G_Help, 1, 16); { outline the OK button }        SetFont('Monaco', 9, []);        offset := 12;        Left := 5;        Top := 15;        n := 0;        moveto(Left, Top);        DrawString('This Dialog permits editing those quantities that may change, from spectrum to spectrum,');        n := n + 1;        moveto(Left, Top + n * offset);        str := 'in the disk file. This Dialog, like the Experiment Header Dialog, is multipurpose. It can';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'be used to review and edit the header of an already existing file. It is also used to create';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'valid and appropriate fields as a new disk file is being created, spectrum by spectrum.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'The SPECIMEN CLASS column of text edit boxes is a convenience feature for that class of ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'specimens that consist of a number of distinct and namable phases. By filling in the fields,';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'which may be as long as 50 characters, before the analysis proceeds, then it only remains';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'to "click" the appropriate radio button to attach the label to the spectrum.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'A number of the other text edit boxes are used by DTSA only to "pass through" the values';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'to some other program, like a spread sheet. Only the time and current fields are used by';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'the quantitation procedures in DTSA.';        DrawString(str);        n := n + 2;        moveto(Left, Top + n * offset);        str := 'The 3 in-column check boxes and the "Make It So" button are for editing an existing file';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'on disk. WARNING!!! in this version the "Copy to Subsequent Headers" feature will only copy';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'changed fields into ALL subsequent spectrum headers. This applies to information from the';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := 'sub-dialogs.';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        str := ' ';        DrawString(str);        n := n + 1;        moveto(Left, Top + n * offset);        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);          IF (itemHit = G_Accept) THEN            BEGIN              ExitDialog := true;            END;        UNTIL ExitDialog;		ExitDialog := FALSE;		DisposeDialog(G_Help);		  beginupdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);      END; {End of G_Help procedure}    BEGIN      Header_Dialog := GetNewDialog(4550, NIL, Pointer( - 1));      ShowWindow(Header_Dialog);      SelectWindow(Header_Dialog);      SetPort(Header_Dialog);      OutlineButton(Header_Dialog, 1, 16); { outline the exit button }      {еееееее Setup initial conditions еееееееее}      {ееее HIDE THE DEAD STUFF еееееее}      GetDialogItem(Header_Dialog, CITZAF_Particle, DType, DItem, tempRect);      HideControl(controlhandle(DItem));      GetDialogItem(Header_Dialog, I_min, DType, DItem, tempRect);      HideControl(controlhandle(DItem));      IF (MCA_Spectrum_Active = FALSE) OR (saved_displayed = FALSE) THEN { grey it out }        BEGIN          GetDialogItem(Header_Dialog, I_EDIT, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(Header_Dialog, I_Do_Chkd, DType, DItem, tempRect);          HideControl(controlhandle(DItem));           GetDialogItem(Header_Dialog, I_Show_Prv, DType, DItem, tempRect);          HideControl(controlhandle(DItem));           GetDialogItem(Header_Dialog, I_Show_Nxt, DType, DItem, tempRect);          HideControl(controlhandle(DItem));           GetDialogItem(Header_Dialog, I_Subsequent, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(Header_Dialog, I_Get_Next_Head, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(Header_Dialog, I_DELETE_SPECTRUM, DType, DItem, tempRect);          HideControl(controlhandle(DItem));          GetDialogItem(Header_Dialog, I_INSERT_SPECTRUM, DType, DItem, tempRect);          HideControl(controlhandle(DItem));		         END { IF (MCA_Spectrum_Active = False)...}      ELSE        BEGIN          IF (Plt_spec[10]^^.Expt_Info.LastSpect = Plt_spec[10]^^.Expt_Info.FirstSpec) THEN            BEGIN              GetDialogItem(Header_Dialog, I_Subsequent, DType, DItem, tempRect);              HideControl(controlhandle(DItem));              GetDialogItem(Header_Dialog, I_Show_Nxt, DType, DItem, tempRect);              HideControl(controlhandle(DItem));            END; { IF (Plt_Spec[10]^^....}        END; { ELSE BEGIN }      ExitDialog := FALSE;      get_next := FALSE;	  get_Prev := FALSE;      do_chkd := FALSE;      did_clear := FALSE; {when a new header goes up this must be false}      message_up := FALSE;	 	 {We'er in Spectrum_Header_Dialog}		(*  If (saved_displayed = FALSE) then	  begin			GetDateTime(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time);	  end;	{ If (saved_displayed = FALSE)...}	*)       REPEAT {until ExitDialog = true; this repeat is the loop for stepping thru headers}        {Begin_Time has the no. of secs since midnight, Jan1,1904 til spect creation}		SecondsToDate(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time, theDateTime);        sTemp := DTRec2Str;        GetDialogItem(Header_Dialog, Edit_Date, DType, DItem, tempRect);        SetDialogItemText(DItem, sTemp);        GetDialogItem(Header_Dialog, I_PM, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        GetDialogItem(Header_Dialog, I_AM, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        IF (theDateTime.hour) >= 12 THEN          BEGIN            GetDialogItem(Header_Dialog, I_PM, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);          END        ELSE          BEGIN            GetDialogItem(Header_Dialog, I_AM, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);          END;        GetDialogItem(Header_Dialog, I_uA, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        GetDialogItem(Header_Dialog, I_nA, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 1); { stored in na }        GetDialogItem(Header_Dialog, I_spec_nm, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 1);        GetDialogItem(Header_Dialog, I_spec_um, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        GetDialogItem(Header_Dialog, I_spec_mm, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0);        GetDialogItem(Header_Dialog, I_sec, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 1);        GetDialogItem(Header_Dialog, I_Y_Position, DType, DItem, tempRect);        RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position, 5, 2, str);        SetDialogItemText(DItem, str);        GetDialogItem(Header_Dialog, I_X_Position, DType, DItem, tempRect);        RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position, 5, 2, str);        SetDialogItemText(DItem, str);   { currents stored in namps so that button turns on to start, but we want the value scaled     to the larger units for the dialog}        curr_mult := 1.0;        IF (Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday) >= 1E3 THEN          BEGIN            curr_mult := 1E-3;            GetDialogItem(Header_Dialog, I_uA, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 1);            GetDialogItem(Header_Dialog, I_nA, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 0);          END;        { we do not change the value of the current variables, just the displayed value }        GetDialogItem(Header_Dialog, I_Begin_Current, DType, DItem, tempRect);        RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday * curr_mult, 5, 4, str);        SetDialogItemText(DItem, str);        GetDialogItem(Header_Dialog, I_End_Current, DType, DItem, tempRect);        RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday * curr_mult, 5, 4, str);        SetDialogItemText(DItem, str);        GetDialogItem(Header_Dialog, I_Time, DType, DItem, tempRect);        RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time, 5, 2, str);        SetDialogItemText(DItem, str);        FOR nn := I_Class_13 TO I_Class_1 DO { 51 to 63 }          BEGIN { put in the current set of classes and turn on the button for this spectrum }            GetDialogItem(Header_Dialog, nn, DType, DItem, tempRect);            SetDialogItemText(DItem, a^.Spectrum_Class_Holding_String[nn + 1 - I_Class_13]);            GetDialogItem(Header_Dialog, nn - 45, DType, DItem, tempRect);            CItem := controlhandle(DItem);            IF ((a^.Spectrum_Class_Holding_String[nn + 1 - I_Class_13] <> '') AND (a^.Spectrum_Class_Holding_String[nn + 1 -               I_Class_13] = Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class)) THEN              SetControlValue(CItem, 1)            ELSE SetControlValue(CItem, 0);          END;        GetDialogItem(Header_Dialog, I_Spectrum_Comments, DType, DItem, tempRect);        SetDialogItemText(DItem, Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);        GetDialogItem(Header_Dialog, Specimen_Density, DType, DItem, tempRect);        RealToString(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density, 5, 2, str);        SetDialogItemText(DItem, str);        { stored in cm, convert to nm, the on button; then determine best units & change on butt }        rtemp := (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness * 1E7);        GetDialogItem(Header_Dialog, I_spec_nm, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 1);        IF (rtemp >= 1E3) THEN          BEGIN            GetDialogItem(Header_Dialog, I_spec_nm, DType, DItem, tempRect);            SetControlValue(controlhandle(DItem), 0); {turn off nm units}            IF (rtemp < 1E6) THEN              BEGIN                GetDialogItem(Header_Dialog, I_spec_um, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 1);                rtemp := rtemp * 1E-4;              END { if (rtemp < 1E6) then begin...}            ELSE              BEGIN                GetDialogItem(Header_Dialog, I_spec_mm, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 1);                rtemp := rtemp * 1E-7;              END; { else begin...}          END; { if (rtemp >= 1E3) then begin...}        GetDialogItem(Header_Dialog, Specimen_Thickness, DType, DItem, tempRect);        RealToString(rtemp, 5, 2, str);        SetDialogItemText(DItem, str);        numtostring(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number, str1);        Write_Static_Text(Header_Dialog, Disp_Spec_Number, str1);        Write_Static_Text(Header_Dialog, Expt_Title, Plt_spec[10]^^.Expt_Info.Specimen_ID);   { if we load the geom here and change it in the geometry dialog then the    changes will always appear if we return to that dialog. Plt_spec[10] won't change    until we EDIT or ATTACH below }        { the below is because a lot of old files have 90 in them; this works only if they edit. }        IF (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt <= - 90) OR (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt >=           90.0) THEN          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt := 0.0;        IF (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt <= - 90) OR (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt >=           90.0) THEN          Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt := 0.0;        WITH Plt_spec[10]^^, Expt_Info, SpectrumStuff.Spectrum_Info DO          BEGIN            geom.Spec_Det_Dist := Spec_Detector_Distance;            geom.X_Tilt_angle := X_Tilt;            geom.Y_Tilt_angle := Y_Tilt;            geom.Angle_of_TakeOff := Take_Off_Angle;            geom.Azimuthal_angle := Azimuth;            geom.elevation_angle := Elevation;            geom.Beta_Angle := Detector_tilt;            geom.Angle_of_TakeOff := Take_Off_Angle;          END;        ExitDialog := FALSE;        DoTheEdit := FALSE;        attach := FALSE;        get_next := FALSE;		get_Prev := FALSE;        edit_subsequent := FALSE;        time_mult := 1.0; { for now assume all times in sec }        {did_clear := false when get_next do_chkd are done}        T_X_Position := Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position;        T_Y_Position := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position;        T_Begin_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;        T_End_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday;        T_Real_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Real_Time;        T_Live_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;        T_RequestedLiveTime := Plt_spec[10]^^.SpectrumStuff.Acq_Info.RequestedLiveTime;        T_ActualLiveTime := Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime;        T_Spectrum_Comment_Field := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field;        T_Spectrum_Class := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class;        T_Theoretically_Generated := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated;        T_This_is_a_Standard := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard;        T_BkgSubtracted := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted;        T_X_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;        T_Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;        T_Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;        T_Spec_Detector_Distance := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;        T_Specimen_Thickness := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness;        T_Specimen_Density := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density;        T_Number_of_Elements := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements;        FOR nn := 1 TO  15 DO          BEGIN            T_Weight_Fraction[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Weight_Fraction;            T_Atomic_Number[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Atomic_Number;            IF ((Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence >= 0.0) AND            	(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence < 7.0)) then            	T_Valence[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence            else            	T_Valence[nn] := 0.0;          END;        B_X_Position := FALSE;        B_Y_Position := FALSE;        B_Begin_Faraday := FALSE;        B_End_Faraday := FALSE;        B_Real_Time := FALSE;        B_Live_Time := FALSE;        B_RequestedLiveTime := FALSE;        B_ActualLiveTime := FALSE;        B_Spectrum_Comment_Field := FALSE;        B_Spectrum_Class := FALSE;        B_Theoretically_Generated := FALSE;        B_This_is_a_Standard := FALSE;        B_BkgSubtracted := FALSE;        B_X_Tilt := FALSE;        B_Y_Tilt := FALSE;        B_Take_Off_Angle := FALSE;        B_Spec_Detector_Distance := FALSE;        B_Specimen_Thickness := FALSE;        B_Specimen_Density := FALSE;        B_Number_of_Elements := FALSE;        FOR nn := 1 TO 15 DO          BEGIN            B_Weight_Fraction[nn] := FALSE;            B_Atomic_Number[nn] := FALSE;            B_Valence[nn] := FALSE;          END;        REPEAT {until (exitdialog or (do_chkd and get_next) or (Item_hit = I_Clear))...}          ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);          GetDialogItem(Header_Dialog, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          IF (itemHit = I_Composition) THEN            BEGIN              D_Standard_Entry;              OutlineButton(Header_Dialog, 1, 16);            END;          IF (itemHit = I_Help) THEN            BEGIN              Help;			  OutlineButton(Header_Dialog, 1, 16);            END;          IF (itemHit = Detector_Params) THEN            BEGIN              Spec_Det_Params; { the geom has plt_spec[10] values; see above }			  OutlineButton(Header_Dialog, 1, 16);            END;          IF (itemHit = I_AM) OR (itemHit = I_PM) THEN            BEGIN              FOR Index := I_AM TO I_PM DO                BEGIN                  GetDialogItem(Header_Dialog, Index, DType, DItem, tempRect);                  SetControlValue(controlhandle(DItem), 0);                END;              SetControlValue(CItem, 1);            END;          IF (itemHit = I_Clear) THEN            BEGIN              BeepBeep;              IF did_clear THEN                BEGIN {so restore this time}                  did_clear := FALSE;                  Plt_spec[10]^^.SpectrumStuff := saved_header;                  RealToString(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_counts, 5, 2, str1);                END              ELSE                BEGIN {did_clear is false so we are clearing}                  did_clear := true;                  IF answermessage('I will clear everything and substitute zero for all parameter values.',                                   'You must supply correct values if all program functions', 'are to work correctly.',                                   'I"ll do it, if IT`S OK.') THEN                    BEGIN                      saved_header := Plt_spec[10]^^.SpectrumStuff;                      Clear_The_Headers(FALSE, true);                      BeepBeep;                      RealToString(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_counts, 5, 2, str1);                    END;                END;            END;          IF (itemHit = I_Subsequent) THEN            BEGIN              IF answermessage('Are you sure you want to copy what you just changed in this Spectrum ',                               'Header to ееALLее of the remaining Spectrum Headers in this file??? ',                               'If you are sure, hit It`s OK and I will do it, otherwise, hit it`s NOT OK', '') THEN                BEGIN                  temp := GetControlValue(CItem);                  SetControlValue(CItem, (temp + 1) MOD 2);                  IF temp = 0 THEN                    BEGIN                      IF (Plt_spec[10]^^.Expt_Info.LastSpect = Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number) THEN                        BEGIN                          putmessage('There are no more spectra in the file.', '', '', '');                          GetDialogItem(Header_Dialog, I_Subsequent, DType, DItem, tempRect);                          SetControlValue(controlhandle(DItem), 0);                          edit_subsequent := FALSE;                        END                      ELSE edit_subsequent := true;                    END                  ELSE                    BEGIN                      edit_subsequent := FALSE;                    END;                END; { if AnswerMessage...}            END;        (*  IF (itemHit = I_Get_Next_Head) THEN		еееdisabledеее            BEGIN              temp := GetControlValue(CItem);              SetControlValue(CItem, (temp + 1) MOD 2);              get_next := FALSE;              IF temp = 0 THEN                BEGIN                  IF (Plt_spec[10]^^.Expt_Info.LastSpect =				      Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number) THEN                    BEGIN                      putmessage('There are no more spectra in the file.', '', '', '');                      GetDialogItem(Header_Dialog, I_Get_Next_Head, DType, DItem, tempRect);                      CItem := Pointer(DItem);                      SetControlValue(CItem, 0);                    END { if (Plt_spec[10]^^...}                  ELSE get_next := true;                END; {If temp = 0...}            END;						*)          IF (itemHit = I_Do_Chkd) THEN            BEGIN              do_chkd := true;            END;          IF (itemHit = I_Show_Nxt) THEN            BEGIN              do_chkd := true;                  IF (Plt_spec[10]^^.Expt_Info.LastSpect =				      Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number) THEN                     putmessage('There are no more spectra in the file.', '', '', '')					 ELSE get_next := true;             END;           IF (itemHit = I_Show_Prv) THEN            BEGIN              do_chkd := true;                  IF (Plt_spec[10]^^.Expt_Info.FirstSpec = Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number) THEN                     putmessage('You are at the beginning of the file.', '', '', '')					 ELSE get_Prev := true;             END;           		  IF (itemHit = I_OK) THEN            BEGIN              attach := true;              ExitDialog := true;            END;          IF (itemHit = CITZAF_Particle) THEN            BEGIN              D_Particle_Geometry;            END;         IF (itemHit = I_DELETE_SPECTRUM) THEN		  BEGIN	{delete spec_displayed but don't change anything so you could get it back}		   IF (MCA_Spectrum_Active) THEN		   BEGIN			BeepBeep;			IF answermessage('                ееLAST CHANCEее    ееARE YOU SURE??ее',							 'Deleting a spectrum will remove both the header and histogram from the file.',							 '...No, there will not be a hole in your file.', ' ') THEN			BEGIN			 errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;			 IF errCode = NoErr THEN			 BEGIN			   {get_next and get_prev change all the work spectrum info				and the counts and spec_displayed changes so...}			  LastHold := Plt_spec[10]^^.Expt_Info.LastSpect;			  N_Channels := Plt_spec[10]^^.Expt_Info.number_of_channels;			  bytecount := SizeOf(spectrum_structure);			  bytecount_2:= N_Channels * 4;			  index := spec_displayed - 1;			  {where to write...either EOF or next spectrum in file...}			  bytestrt := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +						  longint(index * longint(bytecount + bytecount_2));			 IF spec_displayed < LastHold THEN BEGIN			 {there is at least one more to read and move to deleted's position}			  Index := spec_displayed;			  {where to read...at end of spec_displayed...then at index+1,etc...}			  notepos := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +						  longint(index * longint(bytecount + bytecount_2)); 			   REPEAT			{ еPosition mark at beginning of spectrum to read }			   errCode := setfpos_err(Hold_RefNum, FSFromSTART, notepos, '');			   spinCursor;			 { put what will move up...next spectrum...into saved_header and Col_1 }			   errCode := FSREAD_err(Hold_RefNum, bytecount, @saved_header, '');			   IF errCode = 0 THEN	errCode := FSREAD(Hold_RefNum, bytecount_2, @Col_1^);			   IF (errCode = 0) or (errcode = EOFerr) THEN			    BEGIN				{get where next to read...ie, where we now are...}				 errCode := getfpos(Hold_RefNum,notepos);			    { еgo to writing position...so we can write stuff just read}		         errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytestrt, '');			    { еcorrect Spectrum_number and Write spectrum and header from RESULTS into the file }				 saved_header.Spectrum_Info.Spectrum_number := 					               saved_header.Spectrum_Info.Spectrum_number - 1;				 errCode := FSWRITE_err(Hold_RefNum, bytecount, @saved_header, '');				 errCode := FSWRITE_err(Hold_RefNum, bytecount_2, @Col_1^, '');				 errCode := getfpos(Hold_RefNum,bytestrt);{ write here next }				END;			    index := index + 1;		     UNTIL (Index >= LastHold);		    END;	{ IF spec_displayed < LastHold...}		    errCode := SetEOF(Hold_RefNum, bytestrt);		    errCode := setfpos(Hold_RefNum,FSFromSTART,0);		    Plt_spec[10]^^.Expt_Info.LastSpect :=		   							       Plt_spec[10]^^.Expt_Info.LastSpect - 1;			bytestrt := sizeof(integer); 			errCode := FSWRITE_err(Hold_RefNum, bytestrt, @Plt_spec[10]^^.Expt_Info.LastSpect, '');			{ This stuff is if we decide to show the spectrum before the one deleted...			   will also need to get out of main REPEAT to refresh display and dialogs.			   Right now Plt_spec[10]^^ still has deleted stuff so it could be copied to RESULTS			   and inserted back into file...}			  spec_displayed := spec_displayed -1;			  if spec_displayed < 1 then spec_displayed := 1;			  index := spec_displayed - 1;	         {beginning of spectrum before one deleted or the 1st spectrum...}			  bytestrt := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +						  longint(index * longint(bytecount + bytecount_2));			  bytecount := bytecount + bytecount_2;		      errCode := setfpos(Hold_RefNum,FSFromSTART,bytestrt);			  errCode := FSREAD_err(Hold_RefNum, bytecount,			  						@Plt_spec[10]^^.SpectrumStuff, '');			 		    errCode := FSClose(Hold_RefNum);		    errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);			spectrum_counter := spec_displayed;			Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;		    specwork_has_been_changed := true;		    ChangeCursor(ArrowC);		   END;	{ IF errCode = NoErr...}		   END;	{ IF answermessage...}		  END	{ IF (MCA_Spectrum_Active)...}		  ELSE putmessage('There is not a DTSA file of spectra currently active.', '', '', ''); { IF (MCA_Spectrum_Active...) }          END; { button I_DELETE_SPECTRUM }          IF (itemHit = I_INSERT_SPECTRUM) THEN          BEGIN			IF (MCA_Spectrum_Active) THEN			BEGIN			  BeepBeep;			  IF answermessage('               ееLAST CHANCEее       ееARE YOU SURE??ее',							   'Inserting RESULTS spectrum will insert both the header and histogram into the file',							   'and will "shuffle" all remaining spectra and headers up one position. The insertion ',							   'occurs AFTER the spectrum currently displayed in WORK. ') THEN			  BEGIN				errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;				IF errCode = NoErr THEN				BEGIN				  Index := spec_displayed; { starts at # of spectrum in header}				  LastHold := Plt_spec[10]^^.Expt_Info.LastSpect;				  N_Channels := Plt_spec[10]^^.Expt_Info.number_of_channels;				  bytecount := SizeOf(spectrum_structure);				  bytecount_2:= N_Channels * 4;				  bytestrt := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +							  longint(spec_displayed * longint(bytecount + bytecount_2));				 { еPosition mark at end of displayed spectrum }				  errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytestrt, '');				  IF errCode <> 0 THEN exit(Spectrum_Header_Dialog);				   Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := spec_displayed;				  IF index < LastHold THEN				  REPEAT	{ Until index = LastHold; }					spinCursor;					IF index < LastHold THEN BEGIN					{ put what will be overwritten...next spectrum...into saved_header and theCounts }					  errCode := getfpos(Hold_RefNum, bytestrt);					  errCode := FSRead_err(Hold_RefNum, bytecount, @saved_header, '');					  IF errCode = 0 THEN	errCode := FSRead_err(Hold_RefNum, bytecount_2, @Col_1^, '');					  IF (errCode = 0) or (errcode = eoferr) THEN						{ еRewind mark back one spectrum...so we can write 9 here}						errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytestrt, '');					END;	{IF index < LastHold...}					IF errCode = 0 THEN BEGIN					  { е correct Spectrum_number and Write spectrum and header from RESULTS into the file }					   Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := 							Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number + 1;					   errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[9]^^.SpectrumStuff, '');					   errCode := FSWrite_err(Hold_RefNum, bytecount_2, @Plt_spec[9]^^.S, '');					  {now at end of overwritten data...}						  index := index + 1;					  IF Index < LastHold then BEGIN					  {we just wrote over what's in saved...if there's another spectrum,					   read it into 9 but get the current position first}						 errCode := getfpos(Hold_RefNum,bytestrt);						 errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[9]^^.SpectrumStuff, '');						 IF errCode = 0 THEN						   errCode := FSRead_err(Hold_RefNum, bytecount_2, @Plt_spec[9]^^.S, '');					  {and go back to beginning of what we just copied...to write 9 there}						 errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytestrt, '');					END;	{IF errCode = 0 THEN BEGIN...}					IF Index <= LastHold then BEGIN						index := index + 1;						{ е correct Spectrum_number and Write spectrum and header from saved into the file }						saved_header.Spectrum_Info.Spectrum_number := saved_header.Spectrum_Info.Spectrum_number + 1;						errCode := FSWrite_err(Hold_RefNum, bytecount, @saved_header, '');						errCode := FSWrite_err(Hold_RefNum, bytecount_2, @Col_1^, '');					END;				   END;	{IF errCode = 0 THEN BEGIN...}				  UNTIL (Index > LastHold)				  ELSE begin					{ еWrite spectrum and header from RESULTS after the last position }					Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := 					   Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Spectrum_number + 1;					errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[9]^^.SpectrumStuff, '');					errCode := FSWrite_err(Hold_RefNum, bytecount_2, @Plt_spec[9]^^.S, '');				  END;				  {е Now flush the toilet and zip up}				  Plt_spec[10]^^.Expt_Info.LastSpect := Plt_spec[10]^^.Expt_Info.LastSpect + 1;				  errCode := setfpos_err(Hold_RefNum, FSFromSTART, 0, '');				  bytecount := SizeOf(integer);				  errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.Expt_Info.LastSpect, '');				  Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;				  				  { еPosition mark where it was to begin...at the end of spec_displayed}								  bytecount := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +							  (Spec_Displayed) * (SizeOf(spectrum_structure) +												longint(Plt_spec[10]^^.Expt_Info.number_of_channels) * 4);				  errCode := SetFPos(Hold_RefNum, FSFromSTART, bytecount);	  				errCode := FSClose(Hold_RefNum);				errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);				ChangeCursor(ArrowC);			   END;	{FSOpen...IF errCode = NoErr THEN...}			  END; 	{ IF answermessage...}			END	{ IF (MCA_Spectrum_Active) THEN...}			ELSE putmessage('There is not a DTSA file of spectra currently active.', '', '', ''); { IF (MCA_Spectrum_Active...) }           END; { button I_INSERT_SPECTRUM }          IF (itemHit = I_Exit) THEN { now CANCEL }            BEGIN              DisposeDialog(Header_Dialog);              BeginUpdate(BackPlane);              DrawAxesFull;              update_full;              EndUpdate(BackPlane);              UpDate_SiLi_Window(SiLiWindow);              Mouse_Active_Window;              update_full;              exit(Spectrum_Header_Dialog);            END;          IF (itemHit = I_Specimen_Case) THEN            BEGIN              putmessage('You may enter 13 "classes" of objects as the sources of the spectra in this file:',                         'film, grid, nucleus,...grain boundry, catalyst, etc.',                         'Then just click on the appropriate button for each spectrum.',						 'Support film => film; grid, polepiece, etc => bulk.');              OutlineButton(Header_Dialog, 1, 16); { outline the accept button }            END;          IF (itemHit = I_EDIT) THEN            BEGIN              temp := GetControlValue(CItem);              SetControlValue(CItem, (temp + 1) MOD 2);              IF (temp = 1) THEN DoTheEdit := FALSE              ELSE              BEGIN				IF (message_up) THEN DoTheEdit := true				ELSE				BEGIN				  numtostring(spectrum_counter, str);				  str := CONCAT('If "IT`S OK", the spectrum header of number ', str);				  IF answermessage(str, 'will be replaced with the information in the dialog',								   'when you hit the "Do Checked" button.', '')						THEN DoTheEdit := true				  ELSE				  BEGIN					  GetDialogItem(Header_Dialog, I_EDIT, DType, DItem, tempRect);					  SetControlValue(controlhandle(DItem), 0);				  END;				  message_up := true;				END; { if (not message_up)...}              END; {if (temp = 1)...else begin...}            END;          IF (itemHit >= I_13) AND (itemHit <= I_1) THEN            BEGIN              FOR Index := I_13 TO I_1 DO                BEGIN                  GetDialogItem(Header_Dialog, Index, DType, DItem, tempRect);                  SetControlValue(controlhandle(DItem), 0);                END;              SetControlValue(CItem, 1);            END;      (*   IF (itemHit >= I_mm) AND (itemHit <= I_nm) THEN          BEGIN            FOR Index := I_mm TO I_nm DO              BEGIN                GetDialogItem(Header_Dialog, Index, DType, DItem, tempRect);                CTempItem := POINTER(DItem);                SetControlValue(CTempItem, 0);              END;            SetControlValue(CItem, 1);          END;     *)          {76,77,78}          IF (itemHit >= I_spec_nm) AND (itemHit <= I_spec_mm) THEN            BEGIN              FOR Index := I_spec_nm TO I_spec_mm DO                BEGIN                  GetDialogItem(Header_Dialog, Index, DType, DItem, tempRect);				  nindex := GetControlValue(controlhandle(DItem));				  if nindex >= 1 then temp := Index;                  SetControlValue(controlhandle(DItem), 0);                END;              SetControlValue(CItem, 1);			 (* numtostring(temp, str1);			  numtostring(ItemHit, str);			  putmessage(' temp = ',str1,' ItemHit = ',str);*)			  IF ((temp - ItemHit) = -1) then spec_mult := 1E-3			  ELSE IF ((temp - ItemHit) = 1) then spec_mult := 1E3			  ELSE IF ((temp - ItemHit) = -2) then spec_mult := 1E-7			  ELSE IF ((temp - ItemHit) = 2) then spec_mult := 1E7			  ELSE spec_mult := 1.0;        	  GetDialogItem(Header_Dialog, Specimen_Thickness, DType, DItem, tempRect);			  GetDialogItemText(DItem, sTemp);			  rtemp := MyStr2Num(sTemp) * spec_mult;        	  RealToString(rtemp, 5, 5, str);        	  SetDialogItemText(DItem, str);            END;          IF (itemHit >= I_nA) AND (itemHit <= I_uA) THEN            BEGIN              FOR Index := I_nA TO I_uA DO                BEGIN                  GetDialogItem(Header_Dialog, Index, DType, DItem, tempRect);                  CTempItem := controlhandle(DItem);				  nindex := GetControlValue(CTempItem);				  if nindex = 1 then temp := Index;				  SetControlValue(CTempItem, 0);                END;              SetControlValue(CItem, 1);			  IF temp > itemHit then curr_mult := 1E3			  ELSE IF temp < itemHit then curr_mult := 1E-3			  ELSE curr_mult := 1.0;			  GetDialogItem(Header_Dialog, I_End_Current, DType, DItem, tempRect);			  GetDialogItemText(DItem, sTemp);			  rtemp := MyStr2Num(sTemp) * curr_mult;			  RealToString(rtemp,5,4,sTemp);			  SetDialogItemText(DItem, sTemp);			  GetDialogItem(Header_Dialog, I_Begin_Current, DType, DItem, tempRect);			  GetDialogItemText(DItem, sTemp);			  rtemp := MyStr2Num(sTemp) * curr_mult;			  RealToString(rtemp,5,4,sTemp);			  SetDialogItemText(DItem, sTemp);			              END; { IF (itemHit >= I_nA) AND (itemHit...}          IF (attach OR (do_chkd AND (DoTheEdit OR edit_subsequent))) THEN          BEGIN              GetDialogItem(Header_Dialog, I_Y_Position, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position := MyStr2Num(sTemp);			  IF T_Y_Position <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position			  THEN begin			  	B_Y_Position := true;				T_Y_Position := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position;			  end			  ELSE B_Y_Position := FALSE;              GetDialogItem(Header_Dialog, I_X_Position, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position := MyStr2Num(sTemp);			  IF T_X_Position <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position			  THEN begin			  	B_X_Position := true;				T_X_Position := Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position;			  end			  ELSE B_Y_Position := FALSE;              {get the string and save value in namps}              curr_mult := 1.0; { assume na button on; stored in nAmps ) GetDialogItem(Header_Dialog, I_uA, DType, DItem, tempRect);                                 CTempItem := POINTER(DItem); temp := GetControlValue(CTempItem); { is ua on or off? }              IF temp = 1 THEN curr_mult := 1E3; { uamp on: convert to namps }              GetDialogItem(Header_Dialog, I_End_Current, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday := MyStr2Num(sTemp) * curr_mult;			  IF T_End_Faraday <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday THEN			  begin				  B_End_Faraday := true;				  T_End_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday;			  end			  ELSE B_End_Faraday := FALSE;			  {...these booleans indicated val should be chgd in file}			  			  GetDialogItem(Header_Dialog, I_Begin_Current, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday := MyStr2Num(sTemp) * curr_mult;			  IF T_Begin_Faraday <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday THEN			  begin				  B_Begin_Faraday := true;				  T_Begin_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;			  end			  ELSE B_Begin_Faraday := FALSE;              WITH Plt_spec[10]^^, Expt_Info, SpectrumStuff, Spectrum_Info DO              BEGIN                  { these are the only values that can change via the geometry dialog }                  Spec_Detector_Distance := geom.Spec_Det_Dist;				  IF T_Spec_Detector_Distance <> Spec_Detector_Distance				  THEN begin					B_Spec_Detector_Distance := true;					T_Spec_Detector_Distance := Spec_Detector_Distance;				  end				  ELSE B_Spec_Detector_Distance := FALSE;                  X_Tilt := geom.X_Tilt_angle;				  IF T_X_Tilt <> X_Tilt				  THEN begin					B_X_Tilt := true;					T_X_Tilt := X_Tilt;				  end				  ELSE B_X_Tilt := FALSE;                  Y_Tilt := geom.Y_Tilt_angle;				  IF T_Y_Tilt <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt				  THEN begin					B_Y_Tilt := true;					T_Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;				  end				  ELSE B_Y_Tilt := FALSE;                  Take_Off_Angle := geom.Angle_of_TakeOff;				  IF T_Take_Off_Angle <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle				  THEN begin					B_Take_Off_Angle := true;					T_Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;				  end				  ELSE B_Take_Off_Angle := FALSE;                END;	{ WITH Plt_spec[10]^^,...}                           			  FOR nn := 6 TO 18 DO {I_6 to I_18, the radio buttons}			  BEGIN				sTemp := '';				GetDialogItem(Header_Dialog, nn - 6 + I_Class_13, DType, DItem, tempRect);				GetDialogItemText(DItem, sTemp);				IF length(sTemp) > 0 THEN				BEGIN					Index := 1;					WHILE (ord(sTemp[Index]) = 32) DO					  Index := Index + 1;{count the blanks and remove}					IF Index > 1 THEN Delete(sTemp, 1, Index - 1);					IF length(sTemp) > 25 THEN					  BEGIN						putmessage('The Class field is limited to 25 characters, I will truncate what you entered',								   'to this length.', '', '');						temp := length(sTemp) - 25;						Delete(sTemp, 26, temp);					  END;					a^.Spectrum_Class_Holding_String[nn - 5] := sTemp; { to get all current non-blank classes }					GetDialogItem(Header_Dialog, nn - 6 + I_13, DType, DItem, tempRect);					temp := GetControlValue(controlhandle(DItem));					IF (temp = 1) THEN { Radio Button was on}						Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class := a^.Spectrum_Class_Holding_String[nn - 5];				 END; { if length(stemp) <> 0...}               END; {FOR nn := 6 TO 18...}			  IF T_Spectrum_Class <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class			  THEN begin			  	B_Spectrum_Class := true;				T_Spectrum_Class := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class;			  end			  ELSE B_Spectrum_Class := FALSE;              GetDialogItem(Header_Dialog, I_Spectrum_Comments, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);			  if (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_generated) then			  begin			  	temp := Pos('Generated',sTemp);				if temp = 0 then sTemp := concat('Generated ',stemp);			  end;              IF length(sTemp) > 255 THEN                BEGIN                  putmessage('The Comment field is limited to 255 characters, I will truncate what you entered', 'to this length.',                             '', '');                  temp := length(sTemp);                  FOR Index := temp DOWNTO 255 DO                    Delete(sTemp, Index, 1);                END;              IF length(sTemp) <> 0 THEN                BEGIN                  Index := 1;                  WHILE (ord(sTemp[Index]) = 32) DO                    Index := Index + 1;                  IF Index > 1 THEN Delete(sTemp, 1, Index - 1);                END              ELSE sTemp := 'No comments.';              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field := sTemp;			  IF T_Spectrum_Comment_Field <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field THEN			  begin				  B_Spectrum_Comment_Field := true;				  T_Spectrum_Comment_Field := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field;			  end			  ELSE B_Spectrum_Comment_Field := FALSE;			               GetDialogItem(Header_Dialog, Specimen_Density, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density := MyStr2Num(sTemp);			  IF T_Specimen_Density <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density THEN			  begin				  B_Specimen_Density := true;				  T_Specimen_Density := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density;			  end			  ELSE B_Specimen_Density := FALSE;              Index := I_spec_nm; {76}              REPEAT { find the on button to get the units; store in cm }                GetDialogItem(Header_Dialog, Index, DType, DItem, tempRect);                temp := GetControlValue(controlhandle(DItem));                Index := Index + 1;              UNTIL (temp <> 0) OR (Index > I_spec_mm);              spec_mult := 1E-7; { dimensions of saved are cm; assume nm button on to start }              temp := Index - I_spec_nm; { 1 => nm, 2 => um, 3 => mm for spec units }              IF (temp = 2) THEN spec_mult := 1E-3              ELSE IF (temp = 3) THEN spec_mult := 1{E-1};              GetDialogItem(Header_Dialog, Specimen_Thickness, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness := MyStr2Num(sTemp) * spec_mult;			  IF T_Specimen_Thickness <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness THEN			  begin				  B_Specimen_Thickness := true;				  T_Specimen_Thickness := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness;			  end			  ELSE B_Specimen_Thickness := FALSE;              GetDialogItem(Header_Dialog, I_Time, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time := MyStr2Num(sTemp) * time_mult;			  IF T_Live_Time <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time THEN			  begin				  B_Live_Time := true;				  T_Live_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;			  end			  ELSE B_Live_Time := FALSE;{the next three are acquisition defined...}        IF T_Real_Time <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.Real_Time THEN		BEGIN			T_Real_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Real_Time;			B_Real_Time := true	    end        ELSE B_Real_Time := FALSE;        		IF T_RequestedLiveTime <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.RequestedLiveTime THEN		begin			B_RequestedLiveTime := true;			T_RequestedLiveTime := Plt_spec[10]^^.SpectrumStuff.Acq_Info.RequestedLiveTime;			end        ELSE B_RequestedLiveTime := FALSE;        		IF T_ActualLiveTime <> Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime THEN		begin			B_ActualLiveTime := true;			T_ActualLiveTime := Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime;			end        ELSE B_ActualLiveTime := FALSE;{the next n Plt_spec[10]^^.SpectrumStuff.Spectrum_Info were defined in another dialog...}       		IF T_Theoretically_Generated <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated THEN        begin  		  B_Theoretically_Generated := true;		  T_Theoretically_Generated := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated;		  end        ELSE B_Theoretically_Generated := FALSE;        		IF T_This_is_a_Standard <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard THEN		begin			B_This_is_a_Standard := true;			T_This_is_a_Standard := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard;			end        ELSE B_This_is_a_Standard := FALSE;        		IF T_BkgSubtracted <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted THEN		begin			B_BkgSubtracted := true;			T_BkgSubtracted := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted;			end        ELSE B_BkgSubtracted := FALSE;        IF T_Number_of_Elements <> Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements THEN		begin			B_Number_of_Elements := true;			T_Number_of_Elements:=Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements;			end        ELSE B_Number_of_Elements := FALSE;        		FOR nn := 1 TO 15 do With Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn]		DO BEGIN            IF T_Weight_Fraction[nn] <> Weight_Fraction THEN             begin 			  B_Weight_Fraction[nn] := true;			  T_Weight_Fraction[nn] := Weight_Fraction;			  end            ELSE B_Weight_Fraction[nn] := FALSE;            IF T_Atomic_Number[nn] <> Atomic_Number THEN			begin              B_Atomic_Number[nn] := true;			  T_Atomic_Number[nn] := Atomic_Number;			  end            ELSE B_Atomic_Number[nn] := FALSE;            IF T_Valence[nn] <> Valence THEN			begin				B_Valence[nn] := true;				T_Valence[nn] := Valence;				end            ELSE B_Valence[nn] := FALSE;          END;              IF (do_chkd) THEN              BEGIN			   IF (DoTheEdit) THEN			   BEGIN 				 errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;				 IF errCode <> NoErr THEN BeepBeep				 ELSE				   BEGIN(*				   numtostring(spectrum_counter,str);		realtostring(Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday,2,-2,str1);		putmessage('the End_Faraday is',str1,'now edit the spectrum #',str);	*)					 { to position mark at end of spectrum preceeding the spectrum of interest}					 bytecount := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +								  longint(spectrum_counter - 1) * (SizeOf( spectrum_structure) +								  longint(Plt_spec[10]^^.Expt_Info.number_of_channels) * 4);					 errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytecount, '');					 bytecount := SizeOf(spectrum_structure);					 errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff, '');				   END;				 errCode := FSClose(Hold_RefNum);				 errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);				 DoTheEdit := FALSE;				 {turn off the check box}				 GetDialogItem(Header_Dialog, I_EDIT, DType, DItem, tempRect);				 SetControlValue(controlhandle(DItem), 0);			  END; { IF DoTheEdit THEN...}                  IF edit_subsequent THEN                  BEGIN					  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  		RdBinaryName := Read_DTSA_Spec.name;                      IF errCode <> NoErr THEN BeepBeep                      ELSE BEGIN                           bytecount_2 := SizeOf(spectrum_structure);                           Index := spectrum_counter;                             REPEAT							spinCursor;                            bytecount := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +								         longint(Index * (bytecount_2 +											 	 longint(Plt_spec[ 10]^^.Expt_Info.number_of_channels * 4)));                   			{ to position mark at end of spectrum currently of interest and edit subsequent}         					errCode := SetFPos(Hold_RefNum, FSFromSTART, bytecount);                            errCode := FSRead_err(Hold_RefNum, bytecount_2, @Plt_spec[10]^^.SpectrumStuff, '');														{read all the current info about the spectrum then make changes...}                            IF B_X_Position THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position := T_X_Position;                            IF B_Y_Position THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position := T_Y_Position;                            IF B_Begin_Faraday THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday := T_Begin_Faraday;                            IF B_End_Faraday THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday := T_End_Faraday;                            IF B_Real_Time THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.Real_Time := T_Real_Time;                            IF B_Live_Time THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time := T_Live_Time;                            IF B_RequestedLiveTime THEN                              Plt_spec[10]^^.SpectrumStuff.Acq_Info.RequestedLiveTime := T_RequestedLiveTime;                            IF B_ActualLiveTime THEN Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime := T_ActualLiveTime;                            IF B_Spectrum_Comment_Field THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field := T_Spectrum_Comment_Field;                            IF B_Spectrum_Class THEN Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class := T_Spectrum_Class;                            IF B_Theoretically_Generated THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated := T_Theoretically_Generated;                            IF B_This_is_a_Standard THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard := T_This_is_a_Standard;                            IF B_BkgSubtracted THEN Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted := T_BkgSubtracted;                            IF B_X_Tilt THEN Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt := T_X_Tilt;                            IF B_Y_Tilt THEN Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt := T_Y_Tilt;                            IF B_Take_Off_Angle THEN Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle := T_Take_Off_Angle;                            IF B_Spec_Detector_Distance THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance := T_Spec_Detector_Distance;                            IF B_Specimen_Thickness THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness := T_Specimen_Thickness;                            IF B_Specimen_Density THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density := T_Specimen_Density;                            IF B_Number_of_Elements THEN                              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements := T_Number_of_Elements;                            FOR nn := 1 TO  15 DO                              BEGIN                                IF B_Weight_Fraction[nn] THEN                                  Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Weight_Fraction := T_Weight_Fraction[                                   nn];                                IF B_Atomic_Number[nn] THEN                                  Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Atomic_Number := T_Atomic_Number[nn];                                IF B_Valence[nn] THEN                                  Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence := T_Valence[nn];                              END;							{we read the spectrum info, now go back and write the values...}                              errCode := SetFPos(Hold_RefNum, FSFromSTART, bytecount);                            IF errCode = NoErr THEN                              BEGIN                                errCode := FSWrite_err(Hold_RefNum, bytecount_2, @Plt_spec[10]^^.SpectrumStuff, '');								IF errCode = NoErr THEN index := index + 1;                              END                            ELSE IF errCode = eoferr THEN putmessage('uh-oh, the leof!', '', '', '');                          UNTIL (Index = Plt_spec[10]^^.Expt_Info.LastSpect);				   {Now, read spec_displayed stuff back into  Plt_spec[10]...}(*$$*)			   Index := spectrum_counter - 1; 				   bytecount := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) +									   longint(Index * (bytecount_2 +									   longint(Plt_spec[ 10]^^.Expt_Info.number_of_channels * 4)));				   errCode := SetFPos(Hold_RefNum, FSFromSTART, bytecount);				   errCode := FSRead_err(Hold_RefNum, bytecount_2, @Plt_spec[10]^^.SpectrumStuff, '');(*$$*)				  						  ChangeCursor(ArrowC);                        END;					                        errCode := FSClose(Hold_RefNum);                      errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                      edit_subsequent := FALSE;                      {turn off the check box}                      GetDialogItem(Header_Dialog, I_Subsequent, DType, DItem, tempRect);                      SetControlValue(controlhandle(DItem), 0);                    END; { IF edit_subsequent THEN...}                END; { IF do_chkd...}              attach := FALSE;			  {Cannot edit begin_time so this comes after edit stuff... }		      GetDialogItem(Header_Dialog, Edit_Date, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              str := CONCAT(sTemp[1], sTemp[2]);              IF (str = 'DD') THEN {put in current date and time}                GetDateTime(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time)              ELSE			  BEGIN				GetDialogItem(Header_Dialog, I_PM, DType, DItem, tempRect);				temp := GetControlValue(controlhandle(DItem));				isPM := FALSE;				IF temp = 1 THEN isPM := true;				Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time := DateStr2Lint(sTemp, isPM);			  END; { If (sTemp[1] <> 'D')...}            END; { IF ((attach) or ((do_chkd) and ((dotheEdit) or (edit_subsequent))))...}          IF ((do_chkd) AND (get_next) or (get_Prev)) THEN            BEGIN			  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;              IF errCode <> NoErr THEN BeepBeep              ELSE                BEGIN                  if get_Prev then index := spec_displayed - 2				  else if get_next then index := spec_displayed; 				  bytecount := SizeOf(expt_infoRec) + SizeOf(Plot_InfoRec) + longint(index ) * 				                    (SizeOf(spectrum_structure) + longint(Plt_spec[10]^^.Expt_Info.number_of_channels) * 4);                  errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytecount, '');                  IF errCode = NoErr THEN                    BEGIN                      bytecount := SizeOf(spectrum_structure) +					  			   longint(Plt_spec[10]^^.Expt_Info.number_of_channels) * 4;                      {Read spectrum info, acq info and counts into work}					  errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff, '');                    END;                END;              errCode := FSClose(Hold_RefNum);              errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);			  			  {the next four lines of code imply that the displayed work spectrum changes}			  if get_Prev then Spec_Displayed := Spec_Displayed - 1;              if get_next then Spec_Displayed := Spec_Displayed + 1;              spectrum_counter := Spec_Displayed;              specwork_has_been_changed := true;              			  T_X_Position := Plt_spec[10]^^.SpectrumStuff.Acq_Info.X_Position;              T_Y_Position := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Y_Position;              T_Begin_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;              T_End_Faraday := Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday;              T_Real_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Real_Time;              T_Live_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;              T_RequestedLiveTime := Plt_spec[10]^^.SpectrumStuff.Acq_Info.RequestedLiveTime;              T_ActualLiveTime := Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime;              T_Spectrum_Comment_Field := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field;              T_Spectrum_Class := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class;              T_Theoretically_Generated := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated;              T_This_is_a_Standard := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard;              T_BkgSubtracted := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted;              T_X_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;              T_Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;              T_Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;              T_Spec_Detector_Distance := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;              T_Specimen_Thickness := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness;              T_Specimen_Density := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density;              T_Number_of_Elements := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements;              FOR nn := 1 TO  15 DO                BEGIN                  T_Weight_Fraction[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Weight_Fraction;                  T_Atomic_Number[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Atomic_Number;                  IF ((Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence >= 0.0) AND                   		(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence < 7)) then                  	T_Valence[nn] := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence                  else                  	T_Valence[nn] := 0;                END;              {turn off the check box}              GetDialogItem(Header_Dialog, I_Get_Next_Head, DType, DItem, tempRect);              SetControlValue(controlhandle(DItem), 0);              did_clear := FALSE;            END { If ((do_chkd) and (get_next))...}          ELSE do_chkd := FALSE; {if get_next is T then we need to keep do_chkd for UNTIL...}        UNTIL ((do_chkd AND (get_next or get_prev)) OR (ExitDialog) OR		        (itemHit = I_Clear) OR (itemHit = I_DELETE_SPECTRUM));        do_chkd := FALSE;        get_next := FALSE;      UNTIL (ExitDialog = true);      ChangeCursor(ArrowC);      tempRect := Header_Dialog^.portRect;      DisposeDialog(Header_Dialog);      update_full;      DrawAxesFull;      UpDate_SiLi_Window(SiLiWindow);    END; {End of Spectrum_Header_Dialog}  {=================================}{$S Physics_Windows8 }  PROCEDURE D_Ref_Hdr; { reference Header }    CONST      I_Exit                        = 1;              {button}      I_EDIT                        = 2;              {check box}      Disp_Spec_Number              = 4;      Expt_Title                    = 6;      Edit_Date                     = 8;      I_Do_Chkd                     = 10;             {button}      I_Spectrum_Comments           = 11;      I_Attach                      = 12;      I_Info                        = 13;             {ref dependent static text}    VAR      message_up, ExitDialog, attach: boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : integer;      Index                         : integer;      DItem                         : Handle;      CItem				              : controlhandle;      sTemp                         : str255;      itemHit                       : integer;      temp                          : integer;      errCode                       : integer;      bytecount			             : longint;      DoTheEdit                     : boolean;      str, str1                     : str255;    BEGIN      GetSelection := GetNewDialog(131, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      OutlineButton(GetSelection, 69, 16); { outline the exit button }      {еееееее Setup initial conditions еееееееее}      ExitDialog := FALSE;      message_up := FALSE;      SecondsToDate(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time, theDateTime);      sTemp := DTRec2Str;      IF (theDateTime.hour) >= 12 THEN sTemp := CONCAT(sTemp, ' pm')      ELSE sTemp := CONCAT(sTemp, ' am');      GetDialogItem(GetSelection, Edit_Date, DType, DItem, tempRect);      SetDialogItemText(DItem, sTemp);      IF (not saved_displayed) THEN       BEGIN { grey stuff out }          GetDialogItem(GetSelection, I_EDIT, DType, DItem, tempRect);          HiliteControl(controlhandle(DItem), 255);	   end;      str1 := CONCAT('Family: ', Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Class,'. ');	  if datafilename = '' then datafilename := 'unknown';      sTemp := CONCAT('Reference obtained from ', datafilename,'.');      sTemp := CONCAT(str1, sTemp);	  If Plt_Spec[10]^^.Expt_Info.Energy_Slope <> 1.0 then	  		stemp := concat(stemp,' The energy slope is not 1.');	  If Plt_Spec[10]^^.Expt_Info.Energy_intercept <> 0.0 then	  		stemp := concat(stemp,' The energy intercept is not 0.');	  If (Plt_Spec[10]^^.Expt_Info.Energy_Slope <> 1.0) or	  	 (Plt_Spec[10]^^.Expt_Info.Energy_intercept <> 0.0) then		 	stemp := concat(stemp,' This reference may not give good fit results.');      GetDialogItem(GetSelection, I_Info, DType, DItem, tempRect);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, I_Spectrum_Comments, DType, DItem, tempRect);      SetDialogItemText(DItem, Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);      numtostring(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number, str1);      Write_Static_Text(GetSelection, Disp_Spec_Number, str1);      Write_Static_Text(GetSelection, Expt_Title, Plt_spec[10]^^.Expt_Info.Specimen_ID);      ExitDialog := FALSE;      DoTheEdit := FALSE;      attach := FALSE;      REPEAT {until (exit_dialog )...}        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = I_Attach) THEN          BEGIN            attach := true;          END;        IF (itemHit = I_Exit) THEN          BEGIN            ExitDialog := true;          END;        IF (itemHit = I_EDIT) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 1) THEN DoTheEdit := FALSE            ELSE              BEGIN                IF (message_up) THEN DoTheEdit := true                ELSE                  BEGIN                    numtostring(spectrum_counter, str);                    str := CONCAT('If "IT`S OK", the comments of ', str);                    IF answermessage(str, 'will be replaced with the information in the dialog', 'when you hit the "OK" button.',                                     '') THEN                      DoTheEdit := true                    ELSE                      BEGIN                        GetDialogItem(GetSelection, I_EDIT, DType, DItem, tempRect);                        SetControlValue(controlhandle(DItem), 0);                      END;                    message_up := true;                  END; { if (not message_up)...}              END; {if (temp = 1)...else begin...}          END;        IF (attach) or (DoTheEdit) THEN          BEGIN            GetDialogItem(GetSelection, I_Spectrum_Comments, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);			  if (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_generated) then			  begin			  	temp := Pos('Generated',sTemp);				if temp = 0 then sTemp := concat('Generated ',stemp);			  end;            IF length(sTemp) > 255 THEN              BEGIN                putmessage('The Comment field is limited to 255 characters, I will truncate what you entered', 'to this length.',                           '', '');                temp := length(sTemp);                FOR Index := temp DOWNTO 255 DO                  Delete(sTemp, Index, 1);              END;            IF length(sTemp) <> 0 THEN              BEGIN                Index := 1;                WHILE (ord(sTemp[Index]) = 32) DO                  Index := Index + 1;                IF Index > 1 THEN Delete(sTemp, 1, Index - 1);              END            ELSE sTemp := 'No comments.';            Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field := sTemp;            attach := FALSE;          END; { IF ((attach) ..}      UNTIL (ExitDialog = true);      IF (DoTheEdit) THEN        BEGIN		  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;          IF errCode <> NoErr THEN BeepBeep          ELSE            BEGIN              bytecount := SizeOf(expt_infoRec) + longint(spectrum_counter) * SizeOf(References_Rec) - SizeOf(str255);              errCode := setfpos_err(Hold_RefNum, FSFromSTART, bytecount, '');              bytecount := SizeOf(str255);              errCode := FSWrite(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);            END;          errCode := FSClose(Hold_RefNum);          errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);        END; { IF DoTheEdit THEN...}      tempRect := GetSelection^.portRect;      DisposeDialog(GetSelection);      BeginUpdate(BackPlane);      DrawAxesFull;	  update_full;	{ calls DrawSpecIDInfo in Global_Functions which should update 	  			      the info under the display to reflect new Spectrum_Comment_Field???}      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);      Mouse_Active_Window;      update_full;    END; {D_Ref_Hdr }  {=================================}END.