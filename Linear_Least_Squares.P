{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]}{**************************} UNIT Linear_Least_Squares ;{*********************************}{**********************************} INTERFACE {**********************************} USES  QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Controls, Finder, Dialogs, Script,   Packages, Printing, StandardFile, Spectrum_Structures, Retrace, SegLoad, fenv, fp, Windows, TextUtils, Events,  Declarations, INITIALIZE, Xray_Energies, Global_Functions, Utilities, sandia, CurveFit, Physics,xray ;PROCEDURE PlotMLReference;PROCEDURE DoReferences; PROCEDURE D_Ml_Dial;PROCEDURE Do_LLS_Fit;{******************************} IMPLEMENTATION {**********************************}{[f+]}{$S CurveFit} { Refs are saved with true values for beginning and end energies. So, if slope and intercept   are not 1 and 0, the ref will be displayed,etc with the peak at the true energy.   Do we want this? Probably not, so change it. 4/20/93}    {a ref rec is 3348bytes}    TYPE      exptptr                       = ^Expt_infoRec;      expthdl                       = ^exptptr;      ExptH                         = expthdl;	   	   VAR		 loEnergyLine,hiEnergyLine	    : real;		 lo_line,hi_line			    : PKARRAY;		 found					        : boolean;		 theFamily						: string[1];		 theZ,FamilyNum				: integer;      covar, wcovar                 : LinFitCovArray;      	  TYPE		myfinfo				= RECORD		  						  volname:string[27];	{ the diskette name, the 'disk' name,...}								  volnum:integer;								  thedirid:longint;		{ the file dir id }								  end;	    theFileInfo			=  Array[1..5] of myfinfo;	 	  VAR        My_File_Info            		: theFileInfo;{ ¥¥¥¥ BECAUSE the routines PlotMLReference and DoReferences are called from and call       routines in other units we use the global Ref_Stuff }(*Xray_Data_Request*)  PROCEDURE PlotMLReference;	{this is for using spectrum arrows in Sili Window}    VAR      index, index1, errCode		: integer;      bytecount                     : LongInt;	  str4,str5						: str255;    BEGIN      { the calling proc will place the mark at correct position in file }      bytecount := sizeof(References_rec);      errCode := FSRead(hold_refnum, bytecount, @Ref_Stuff^^);	  if (Ref_Stuff^^.bkg_subtd <> true) and (Ref_Stuff^^.bkg_subtd <> false) then	  begin		  if answermessage('If IT`S OK,',						   'I will assume this reference is background subtracted.','','')		  then Ref_Stuff^^.bkg_subtd := true		  else Ref_Stuff^^.bkg_subtd := false;		  bytecount := -bytecount;		  errCode := SetFPos_err(hold_refnum, fsFromMark,bytecount,'');		  bytecount := -bytecount;	      errCode := FSWrite(hold_refnum, bytecount, @Ref_Stuff^^);	  end;      For index := 1 to Maximum_Channels do Plt_Spec[10]^^.S[index] := 0.0;      index1 := 0;	  {Begin_Energy and End_Energy are calibrated values. Convert to original spectrum	   values to display as they were when saved ...this works}      FOR index := rinttol((Ref_Stuff^^.Begin_Energy * Ref_Stuff^^.slope +	  					  Ref_Stuff^^.intercept) / Ref_Stuff^^.dE) TO 	               rinttol((Ref_Stuff^^.End_Energy * Ref_Stuff^^.slope +	  					  Ref_Stuff^^.intercept) / Ref_Stuff^^.dE)       DO BEGIN          index1 := index1 + 1;          Plt_Spec[10]^^.S[index] := Ref_Stuff^^.data[index1];        END; {FOR index := Ref_Stuff^^.Begin_Energy to...}      WITH Plt_Spec[10]^^, Expt_Info, SpectrumStuff,Spectrum_Info,acq_info DO        BEGIN		  Begin_Time :=  Ref_Stuff^^.datemade;           Spectrum_Number := Spectrum_Counter;		  theoretically_generated := Ref_Stuff^^.generated;		  BkgSubtracted := Ref_Stuff^^.bkg_subtd;		  {These line energies are the true values...}		  realToString(Ref_Stuff^^.LoE_Line,5,2, str4);		  realToString(Ref_Stuff^^.HiE_Line,5,2, str5);		  {the following is for SHOW HEADER and info displayed below Work...nowhere else for it}		  Spectrum_Class := '';		  Spectrum_Class := CONCAT(A^.Sym[Ref_Stuff^^.Atomic_Number],		  						   Ref_Stuff^^.Family,								   ' ',str4,'->',str5,'ev');{25 chars max}		  Spectrum_Comment_Field := Ref_Stuff^^.comments;		  datafilename := Ref_Stuff^^.source; {name of file from which ref came}         END; { WITH...} 	(*  H_UnLock_Dispose(Handle(Ref_Stuff),'Ref_Stuff, PlotMLReference ');	*)      Auto_Scale_Display := False;      SetControlValue(AutoScale_CtrlHandle, 0); {Set AutoScale checkbox to off value}      Linear_Display := True;      Spectrum_Full[10] := True;      UpDate_Max_Min(10);      V_Scale_Top := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;      CompactMemory;    	  END; { Procedure PlotMLReference; }	PROCEDURE Get_Lo_Hi(index:integer);	{index is the window number}		 {1/14/93:For saving a reference, we need to determine the lowest energy line and the highest		  energy line for a family in the Roi and store these values with the reference. 		  Need the same info for doing a fit. These MUST be the BOOK values. So Get_energies		  returns the book values for any LLSq related fnc. The calibrated energies of the Rois must be		  used always to find the correct lines. For saving references, the slope and intercept 		  of a spectrum should be VERY close to 1 and 0. For fitting, these values may be off and		  accommodated by derivatives. BUT we must find all the lines in a window so the calibrated		  window energies are used as limits. So...Get_energies returns book values for		  LLSq functions. The Rois are swept to include lines visible in the spectrum.		  The peaks may not be at book energies so the true energy of a line swept in the Roi		  may be outside the dE energy limits of the Roi. If the spectrum is shifted but calibration has been done,		  we can  calculate the equivalent book energies of the Roi endpoints and find all the lines		  swept; if not calibrated some lines may be missed.}	   VAR 	  		 hiend,loend			:real;	  		 i						: integer;	  BEGIN	{ Get_Lo_Hi...}	   WITH Plt_spec[10]^^.Expt_Info do begin		  found := false;		  {Calibrated energies...we need to know the true energy of the roi end pts to get		  true max and min line energies		   ...the user sees a pk, makes a ROI, the pk is at an energy higher than		   true so the ROI endpts must be identified as being around a peak at the 		   lower true energy in order to get the correct lines}		  loEnergyLine := (ROI^^.PEAK[index].Hi * dE - energy_intercept)/energy_slope;		  hiEnergyLine := (ROI^^.PEAK[index].Lo * dE - energy_intercept)/energy_slope;		  hiend := loEnergyLine;		  loend := hiEnergyLine;          if not ROI^^.PEAK[index].exists then putmessage('A ROI^^.PEAK does not exist','in Get_Lo_Hi','','');		  			IF (ev_Line[1] >= loend) AND (ev_Line[1] <= hiend) THEN			 BEGIN			   IF (ev_Line[1] <= loEnergyLine) then loEnergyLine := ev_Line[1];  			   IF (ev_Line[1] >= hiEnergyLine) then hiEnergyLine := ev_Line[1];			 END;		   IF (ev_Line[3] >= loend) AND (ev_Line[3] <= hiend) THEN			 BEGIN			   IF (ev_Line[3] <= loEnergyLine) then loEnergyLine := ev_Line[3];  			   IF (ev_Line[3] >= hiEnergyLine) then hiEnergyLine := ev_Line[3];  			 END;	       if Minors then begin			 IF (ev_Line[4] >= loend) AND (			  ev_Line[4] <= hiend) AND 			  ( periodic_picks[Index] > 28) THEN			 BEGIN			   IF (ev_Line[4] <= loEnergyLine) then loEnergyLine := ev_Line[4];  			   IF (ev_Line[4] >= hiEnergyLine) then hiEnergyLine := ev_Line[4];  			 END;   			IF (ev_Line[97] >= loend) AND (			  ev_Line[97] <= hiend) THEN			 BEGIN			   IF (ev_Line[97] <= loEnergyLine) then loEnergyLine := ev_Line[97];  			   IF (ev_Line[97] >= hiEnergyLine) then hiEnergyLine := ev_Line[97];  			 END;  {¥¥¥¥This satelite needs to always be fit }		    end;	{if Minors...}	 (*  if Satellites then Load_K_Satellites (index);*)		 IF ((loEnergyLine<> hiend) and 		     (hiEnergyLine <> loend)) 		 THEN BEGIN	{found a K line in the ROI...end here}					theFamily := 'K';					found := true; 		 END		 ELSE  BEGIN	{L}		 		 For i := 8 to 52 do begin			IF (ev_Line[i] >= loend) AND (	           ev_Line[i] <= hiend) THEN	          BEGIN			    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  			    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  	          END;		 		 end;			{if Satellites then Load_L_Satelites (index);}			 IF  (loEnergyLine<> hiend) and			     (hiEnergyLine <> loend)			 THEN BEGIN						theFamily := 'L';					    found := true;			 END			 ELSE BEGIN			 For i := 72 to 74 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;			 For i := 56 to 57 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;			             i := 61;                				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		                        i := 66;                				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		             i := 69;                				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 				                  		if Minors then begin			 For i := 53 to 55 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;			 For i := 58 to 60 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;			 For i := 62 to 65 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;			 For i := 67 to 68 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;			 For i := 70 to 71 do begin				IF (ev_Line[i] >= loend) AND (		           ev_Line[i] <= hiend) THEN		          BEGIN				    IF (ev_Line[i] <= loEnergyLine) then loEnergyLine := ev_Line[i];  				    IF (ev_Line[i] >= hiEnergyLine) then hiEnergyLine := ev_Line[i];  		          END;		 			 end;	End;		{ if minors }              (* if Satellites then Load_M_Satelites (index);*)			 IF (loEnergyLine<> hiend) and 			    (hiEnergyLine <> loend)			 then Begin						theFamily := 'M';					    found := true;			 End;		{ IF (loEnergyLine..begin...for M}		  END;		{ IF (loEnergyLine...for L...ELSE BEGIN...}		END;	{ IF (loEnergyLine for K..ELSE BEGIN ...} 	   END;	{ with Plt_spec[10]^^.Expt_Info...}	  END; { Procedure Get_Lo_Hi  }  PROCEDURE DoReferences; {uses the global handle Ref_stuff}            VAR      RefName                       : fnamestr;      bytecount                     : LongInt;      errCode                       : integer;      defName                       : str255;      mytype                        : OsType;      Rexpt_stuff                   : ExptH;	  thePlane	                    : integer;      stepthru, Replace_ref, delete : boolean;	  ref_typ						: ARRAY [0..3] of OSType {SFTypeList};	  sfPtr							: ConstSFTypeListPtr;	  Inreply						: StandardFileReply;        PROCEDURE DoRefSeg;      CONST        I_ok                          = 1;            { button }        I_Keep                        = 5;            { radio button }        I_Replace                     = 6;            { radio button }        I_inst                        = 2;            { Instruction - Static Text }        I_Element                     = 3;            { Label, Family: - Static Text }        I_EleInput                    = 4;            { Space for input - Edit Text }        I_StepThru                    = 5;        I_Delete                      = 2;            VAR        ExitDialog                    : boolean;        GetSelection                  : DialogPtr;        DType                         : integer;        DItem                         : Handle;        CItem			              : controlhandle;        sTemp,str1                    : str255;        itemHit                       : integer;        temp                          : integer; 		      PROCEDURE Refresh_Dialog;                 BEGIN          SetPort(GetSelection); 			GetDialogItem(GetSelection, I_ok, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, - 4, - 4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);		          END;      BEGIN        IF (Delete_Ref) THEN GetSelection := GetNewDialog(752, NIL, Pointer( - 1))		ELSE IF (Display_ref) THEN GetSelection := GetNewDialog(751, NIL, Pointer( - 1))        ELSE  BEGIN			GetSelection := GetNewDialog(750, NIL, Pointer( - 1));            MoveWindow(GetSelection,MaxWindowRect.Left+8,MaxWindowRect.Bottom-123+7,TRUE );			END;		(*CenterDialog(GetSelection,TRUE,whre);*)        ShowWindow(GetSelection);          SelectWindow(GetSelection);          SetPort(GetSelection);          IF (NOT Delete_Ref) THEN          BEGIN            IF (append_ref) THEN sTemp := concat(A^.Sym[theZ], theFamily)            ELSE IF (Display_ref) THEN begin        		bytecount := sizeof(References_rec);		 		errCode := FSRead(hold_refnum, bytecount, @Ref_Stuff^^);			    bytecount := sizeof(Expt_infoRec);			    errCode := SetFPos_err(hold_refnum, fsFromStart,bytecount,'');				sTemp := a^.sym[Ref_Stuff^^.Atomic_Number];				if length(stemp) > 1 then					stemp := concat(a^.sym[Ref_Stuff^^.Atomic_Number],Ref_Stuff^^.Family)  				else stemp := concat(a^.sym[Ref_Stuff^^.Atomic_Number],' ',Ref_Stuff^^.Family);			end;            GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect);             SetDialogItemText(DItem, sTemp); {Set the default text string}          END;        Refresh_Dialog;        ExitDialog := False;        stepthru := False;        delete := False;        REPEAT {until ExitDialog}          ModalDialog(NIL, itemHit);           GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);           CItem := controlhandle(DItem);           IF (itemHit = I_ok) THEN ExitDialog := True;          IF ((Delete_Ref) AND (itemHit = I_Delete)) THEN            BEGIN              temp := GetControlValue(CItem);               SetControlValue(CItem, (temp + 1) MOD 2);               IF (temp = 0) THEN delete := True              ELSE delete := False;            END          ELSE IF (append_ref) THEN            BEGIN                IF (itemHit = I_Replace) THEN                   BEGIN                    GetDialogItem(GetSelection, I_Keep, DType, DItem, tempRect);                    SetControlValue(controlhandle(DItem), 0);                     Replace_ref := True;                  END                ELSE IF (itemHit = I_Keep) THEN                  BEGIN                      GetDialogItem(GetSelection, I_Replace, DType, DItem, tempRect);                      SetControlValue(controlhandle(DItem), 0);                       Replace_ref := False;                  END;                SetControlValue(CItem, 1); { turn on the selected button }            END { If (append...}          ELSE IF (Display_ref) AND (itemHit = I_StepThru) THEN            BEGIN                  temp := GetControlValue(CItem);                   SetControlValue(CItem, (temp + 1) MOD 2);                   IF (temp = 0) THEN stepthru := True            ELSE stepthru := False;           END;        UNTIL ExitDialog;          IF (NOT Delete_Ref) THEN          IF ((Display_ref) AND (NOT stepthru)) THEN            BEGIN              GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect);               GetDialogItemText(DItem, sTemp); {Get the text entered}			  if (ord(char(sTemp[3])) > 97) then sTemp[3] := chr(ord(char(sTemp[3]))-32);              theFamily := '';			  {¥¥¥ MUST use either copy or concat in next line...}              theFamily := concat(theFamily, sTemp[3]);              str1 := concat(sTemp[1], sTemp[2]);              theZ := AtSymbol_to_Znum(str1);			  str1 := concat(A^.Sym[theZ],theFamily);            END;		tempRect := GetSelection^.portRect;		DisposeDialog(GetSelection);		FillWhiteSpace(tempRect);      END; {DoRefSeg}    PROCEDURE Display_theRef(VAR plane: integer);            VAR        index, index1,nn                 : integer;		str1,str2					  :str255;      BEGIN         		For nn := 1 to Maximum_Channels do Plt_Spec[plane]^^.S[nn] := 0.0;        index1 := 0;		 {Begin_Energy and End_Energy are calibrated values...put it up where it came from}        FOR index := rinttol((Ref_Stuff^^.Begin_Energy * Ref_Stuff^^.slope +	  					  Ref_Stuff^^.intercept) / Ref_Stuff^^.dE) TO 		             rinttol((Ref_Stuff^^.End_Energy * Ref_Stuff^^.slope +	  					  Ref_Stuff^^.intercept) / Ref_Stuff^^.dE)         DO          BEGIN            index1 := index1 + 1;            Plt_Spec[plane]^^.S[index] := Ref_Stuff^^.data[index1];          END; {FOR index := Ref_Stuff^^.Begin_Energy to...}        IF (plane = 10) THEN          WITH Plt_Spec[10]^^, SpectrumStuff,Spectrum_Info,Acq_Info DO            BEGIN              Spectrum_Number := Spectrum_Counter;			  realtostring(Ref_Stuff^^.LoE_Line,5,4,str1);			  realtostring(Ref_Stuff^^.HiE_Line,5,4,str2);			  Begin_Time :=  Ref_Stuff^^.datemade; 			  theoretically_generated := Ref_Stuff^^.generated;			  BkgSubtracted := Ref_Stuff^^.bkg_subtd;			  {the following is for SHOW HEADER and info below plot}			  Spectrum_Class := '';			  Spectrum_Class := CONCAT(A^.Sym[Ref_Stuff^^.Atomic_Number],									   Ref_Stuff^^.Family,									   ' ',str1,'->',str2,'ev');{25 chars max}			  Spectrum_Comment_Field := Ref_Stuff^^.comments;		      datafilename := Ref_Stuff^^.source; {name of file from which ref came}             END; { WITH...}        Auto_Scale_Display := False;        SetControlValue(AutoScale_CtrlHandle, 0); {Set AutoScale checkbox to off value}        Linear_Display := True;        Spectrum_Full[plane] := True;        CheckItem(FullMenu, A^.C_Full[plane], Spectrum_Full[plane]);        UpDate_Max_Min(plane);        V_Scale_Top := Plt_Spec[plane]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;        IF (plane = 9) THEN          IF (Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts > 		      Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts) THEN            V_Scale_Top := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;        Update_Full;      END; { PROCEDURE Display_theRef(var plane:integer) }    PROCEDURE FindRef;            BEGIN        found := False;        bytecount := sizeof(References_rec);       { Spectrum_Counter := 0;} {now set in calling routine: # of spectrum read}		{read expt stuff in calling routine...}	   IF (thePlane = 9) then		REPEAT		  errCode := FSRead(hold_refnum, bytecount, @Ref_Stuff^^);		  Spectrum_Counter := Spectrum_Counter + 1;		UNTIL ((Ref_Stuff^^.LoE_Line = loEnergyLine) and 			   (Ref_Stuff^^.HiE_Line = hiEnergyLine))			  OR (errCode = EOFerr)	   ELSE IF (thePlane = 10) then		 REPEAT		  errCode := FSRead(hold_refnum, bytecount, @Ref_Stuff^^);		  Spectrum_Counter := Spectrum_Counter + 1;		 UNTIL ((Ref_Stuff^^.Family = theFamily) and (Ref_Stuff^^.Atomic_Number = theZ))		   OR (errCode = EOFerr);	   IF ((thePlane = 9) and (Ref_Stuff^^.LoE_Line=loEnergyLine) and (Ref_Stuff^^.HiE_Line=hiEnergyLine))		OR ((thePlane = 10) and (Ref_Stuff^^.Family = theFamily) and (Ref_Stuff^^.Atomic_Number = theZ))		THEN BEGIN			  found := True;			 if (Ref_Stuff^^.bkg_subtd <> true) and (Ref_Stuff^^.bkg_subtd <> false) then			 begin				 if answermessage('If IT`S OK,',								  'I will assume this reference is background subtracted.','','')				 then Ref_Stuff^^.bkg_subtd := true				 else Ref_Stuff^^.bkg_subtd := false;				 bytecount := -bytecount;				 errCode := SetFPos_err(hold_refnum, fsFromMark,bytecount,'');				 bytecount := -bytecount;				 errCode := FSWrite(hold_refnum, bytecount, @Ref_Stuff^^);			 end;			  Display_theRef(thePlane);{puts the ref where it was in original spectrum}			  Spec_Displayed := Spectrum_Counter;		    END;      END;    PROCEDURE SaveRefSeg;      	  VAR        nwin, index1, index           				: integer;        str1,str2,str3					      		: str255;		source_name									: fnamestr;		openErr 									: OSErr;		savename                     : fnamestr;		savevol         			 : integer;		save_dirID					 : longint;		      BEGIN {SaveRefSeg}	  if Use_Manual_ROIs then         IF (NOT ROI^^.PEAK[1].Exists) THEN          BEGIN            If NOT answerMessage('There are no Peak Rois to define spectrum segments to save. ',                       'If IT`S OK, you can check Auto Rois when you select elements, .', 					   'and I`ll make the ROIs.', 					   'If IT`S NOT OK, please make some ROIS.') then            exit(SaveRefSeg);          END; 		if Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted then			blockmove(@Plt_spec[10]^^.S,@col_1^,sizeof(Plt_spec[10]^^.s))        Else READ_SPECTRUM; { counts to col_1^. Remove escapes. · cnts in spectrum..not used.}		source_name := Plt_Spec[10]^^.Expt_Info.MCA_Filename;        IF (NOT append_ref) THEN          BEGIN		    realtostring(Plt_spec[10]^^.Expt_Info.Kv,5,2,str1);			If Plt_spec[10]^^.Expt_Info.Detector.spec = EDS then 		    	realtostring(Plt_spec[10]^^.Expt_Info.Si_resolution,5,2,str2)			Else if Plt_spec[10]^^.Expt_Info.Detector.spec = WDS then 		    	realtostring(Plt_spec[10]^^.Expt_Info.WDS_resolution,5,2,str2);					    realtostring(Plt_spec[10]^^.Expt_Info.dE,5,2,str3);			str1:=concat('The keV, detector resolution and ev/ch in the WORK header are ',str1,			             ', ',str2,', ',str3,'.');			IF answermessage(str1,			             'These values will be saved in the new reference file. If they are NOT OK,',			             'use a different spectrum or change the Experiment Header when we exit.',					     'If IT`S OK, we`ll proceed.')			Then Begin 			  defName := 'Reference.Dat'; { the user's choice replaces this }			  StandardPutFile('Make NEW Reference File:', defName, Inreply);		{¥¥New DTSA file spec¥¥}			  File_Cancel_Button := Inreply.sfGood;			  BeginUpdate(BackPlane);			  DrawAxesFull;			  Update_Full;			  EndUpdate(BackPlane);			  (*UpDate_SiLi_Window(SiLiWindow);*)			  			  if NOT Inreply.sfGood Then exit(SaveRefSeg);			  RefSpec := Inreply.sfFile;			  RefName := RefSpec.name;			  OutVol_volnum := RefSpec.vRefNum;			  OutVol_DirID := RefSpec.parID;			  			  {The volume names in the folowing calls are all StringPtr}			  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}			  errcode := HSetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}			  errcode := HGetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}			  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}			  			  errCode := FSpCreate(RefSpec, 'DTSA', 'MCAr',smSystemScript);		{¥¥New DTSA file spec¥¥}					   				 AddRef_VolNum := OutVol_volnum;				 			  openErr := FSpOpenDF(RefSpec, fsRdWrPerm, Hold_RefNum);				 				 IF openErr <> NoErr THEN exit(SaveRefSeg);				 errCode := SetEOF(hold_refnum,0);				 errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');				 bytecount := sizeof(Expt_infoRec); { 10 is the "work" spectrum }				 Plt_Spec[10]^^.Expt_Info.MCA_Filename := RefName;				 Plt_Spec[10]^^.Expt_Info.RefFile := true;				 errCode := FSWrite_err(hold_refnum, bytecount, @Plt_Spec[10]^^.Expt_Info,'');				 errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');				 bytecount := sizeof(Plt_Spec[10]^^.Expt_Info.LastSpect); { an integer }				 index := 0; {for Plt_Spec[10]^^.Expt_Info.LastSpect, incremented below when ref written}				 Rexpt_stuff^^.LastSpect := 0;				 errCode := FSWrite_err(hold_refnum, bytecount, @index,'');				 index := 1; {for Plt_Spec[10]^^.Expt_Info.FirstSpec}				 errCode := FSWrite_err(hold_refnum, bytecount, @index,'');			End	{IF answermessage...}			Else exit(SaveRefSeg);        END        ELSE IF (append_ref) THEN        BEGIN           myprompt := ' Append to File: ';		   REPEAT 	{ UNTIL found = true; }			  ref_typ[0] :=  mytype; 			  sfPtr := @ref_typ;			  StandardGetFile(NIL, 1, sfPtr, Inreply);		{¥¥New DTSA file spec¥¥}			  File_Cancel_Button := Inreply.sfGood;			  BeginUpdate(BackPlane);			  DrawAxesFull;			  Update_Full;			  EndUpdate(BackPlane);			  (*UpDate_SiLi_Window(SiLiWindow);*)			  			  if NOT Inreply.sfGood Then exit(SaveRefSeg);			  RefSpec := Inreply.sfFile;			  RefName := RefSpec.name;			  InVol_volnum := RefSpec.vRefNum;			  InVol_DirID := RefSpec.parID;			  			  {The volume names in the folowing calls are all StringPtr}			  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}			  errcode := HSetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}			  errcode := HGetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}			  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}					              AddRef_VolNum := In_VolRefNum;			  openerr := FSpOpenDF(RefSpec, fsRdWrPerm, Hold_RefNum);			  IF ((openErr <> NoErr) and (openErr <> opWrErr)) THEN exit(SaveRefSeg);			 { read Rexpt_stuff from ref file... }			 bytecount := sizeof(Expt_infoRec);			 errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');			 errCode := FSRead(hold_refnum, bytecount, @Rexpt_stuff^^);			 			{check if  ref expt_info matches Plt_Spec[10]^^.Expt_info}			 found := true;			 str1:='Uh-oh, ';			 IF (Rexpt_stuff^^.Detector.spec <> Plt_Spec[10]^^.Expt_Info.Detector.spec)			 Then Begin			 	found := false;				str1 := concat(str1,'the spectroscopy, ');			 End			 Else if (Plt_Spec[10]^^.Expt_Info.kV > Rexpt_stuff^^.kV + 0.05 * Rexpt_stuff^^.kV) 			      or (Plt_Spec[10]^^.Expt_Info.kV < Rexpt_stuff^^.kV - 0.05 * Rexpt_stuff^^.kV)			 Then Begin			 	found := false;				str1 := concat(str1,'the kV, ');			 End			 Else if ( Rexpt_stuff^^.dE <> Plt_Spec[10]^^.Expt_Info.dE)			 Then Begin			 	found := false;				str1 := concat(str1,'the ev/ch, ');			 End			 Else if ((Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS) 			      and  ((Plt_Spec[10]^^.Expt_Info.Si_Resolution >				         Rexpt_stuff^^.Si_Resolution + 0.02 * Rexpt_stuff^^.Si_Resolution)			      or    (Plt_Spec[10]^^.Expt_Info.Si_Resolution <				         Rexpt_stuff^^.Si_Resolution - 0.02 * Rexpt_stuff^^.Si_Resolution)))				  or ((Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS)				  and (Rexpt_stuff^^.WDS_Resolution = Plt_Spec[10]^^.Expt_Info.WDS_Resolution))			 Then Begin			 	found := false;				str1 := concat(str1,'the resolution ');			End;			IF found = false Then            if not answermessage(str1,'of the reference file differ(s) from the WORK spectrum.',			                         'If IT`S OK, I`ll let you pick another reference file to append.','')			then begin				errCode := FSClose(hold_refnum);				errCode := FlushVol(NIL, RefSpec.vRefNum);				exit(SaveRefSeg)			End;	(*	 {check if  ref expt_info matches Plt_Spec[10]^^.Expt_info}			 IF ((Rexpt_stuff^^.Detector.spec = Plt_Spec[10]^^.Expt_Info.Detector.spec)			 and (Plt_Spec[10]^^.Expt_Info.kV <= Rexpt_stuff^^.kV + 0.05 * Rexpt_stuff^^.kV) 			 and (Plt_Spec[10]^^.Expt_Info.kV >= Rexpt_stuff^^.kV - 0.05 * Rexpt_stuff^^.kV) 			 and ( Rexpt_stuff^^.dE = Plt_Spec[10]^^.Expt_Info.dE))			 then if (((Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS) 			       and (Plt_Spec[10]^^.Expt_Info.Si_Resolution <=				        Rexpt_stuff^^.Si_Resolution + 0.02 * Rexpt_stuff^^.Si_Resolution)			       and (Plt_Spec[10]^^.Expt_Info.Si_Resolution >=				        Rexpt_stuff^^.Si_Resolution - 0.02 * Rexpt_stuff^^.Si_Resolution)				   or ((Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS)				   and (Rexpt_stuff^^.WDS_Resolution = Plt_Spec[10]^^.Expt_Info.WDS_Resolution)))			 THEN found := true			 ELSE BEGIN				found := false;				str1:='Uh-oh, ';				IF (Rexpt_stuff^^.Detector.spec <> Plt_Spec[10]^^.Expt_Info.Detector.spec)				  then str1 := concat(str1,'the spectroscopy, ');				IF (Rexpt_stuff^^.kV <> Plt_Spec[10]^^.Expt_Info.kV) 				  then str1 := concat(str1,'the kV, ');				IF (Rexpt_stuff^^.dE <> Plt_Spec[10]^^.Expt_Info.dE)				  then str1 := concat(str1,'the ev/ch, ');				IF (((Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS) and				     (Rexpt_stuff^^.Si_Resolution <> Plt_Spec[10]^^.Expt_Info.Si_Resolution))				 	 or				    ((Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS) and				     (Rexpt_stuff^^.WDS_Resolution <> Plt_Spec[10]^^.Expt_Info.WDS_Resolution)))				  then str1 := concat(str1,'the resolution ');				if (str1 ='Uh-oh, ') then found := true                 else if not answermessage(str1,'of the reference file differ(s) from the WORK spectrum.',			                         'If IT`S OK, I`ll let you pick another reference file to append.','')					 then begin						 errCode := FSClose(hold_refnum);						 errCode := FlushVol(NIL, RefSpec.vRefNum);						 exit(SaveRefSeg)					 end				     else found := false;			  END;		*)			UNTIL found = true;	{ie we found a file to append the data}          END;	{ ELSE IF (append_ref)...}{``````}(*	  Use_Manual_ROIs := true; set this true only in SiliWin 9/20/9  *)		      AutoROI_Chooser;{``````}		  		  		  if Number_of_Elements_Simplexed < 1 then 		      Begin				errCode := FSClose(hold_refnum);				errCode := FlushVol(NIL, RefSpec.vRefNum);				exit(SaveRefSeg)		      end;         IF (NOT ROI^^.PEAK[1].Exists) THEN          BEGIN            PutMessage('At least one Peak Roi must be set to indicate the',                       'background free spectrum segment to save as a reference.', '', '');				errCode := FSClose(hold_refnum);				errCode := FlushVol(NIL, RefSpec.vRefNum);				exit(SaveRefSeg)          END;		{ Now find what refs are to be saved from each roi }		  FOR nwin := 1 TO Number_of_PeakRois - 1 DO		  BEGIN			(*	found := false;				loEnergyLine := ROI^^.PEAK[nwin].Hi * Plt_Spec[10]^^.Expt_Info.dE;				hiEnergyLine := ROI^^.PEAK[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE;			*)					index := 0;				Repeat {This loop assumes that the user has correctly set up ref saving 				  		 windows with lines for only one element in each window. The spectrum						 should be hardware-calibrated so that the slope and icpt are 1 and 0.						 Or it should be program calibrated with measured slope and icpt close						 to 1 and 0.}					index := index+1;					Xray_Data_Request := true;{to get book energy values}                		Get_energies(periodic_picks[index]);					Xray_Data_Request := false; {in general }					{the next three are really for selecting elements for fitting;					 they must be T for this routine.}					Get_Lo_Hi(nwin);	{inititalizes found to false; gets ROI endpts in										 calibrated space and determines the lines in it}				Until (found or (index =  Number_of_Elements_Simplexed));                IF (found) THEN {found:the element has a line in the ROI}                  BEGIN					theZ := periodic_picks[index];                    found := False;	{initialized for IF (append_ref)...FindRef...}                    Replace_ref := True;                    IF (append_ref) THEN                      BEGIN { not a new file, see if ref is already there }                        thePlane := 9;						spectrum_counter:=0;                        FindRef; { if found sets found true & displays the ref in Results }                        IF (found) THEN DoRefSeg; { Dialog Box=>user's value of Replace_ref }                      END;                    IF (Replace_ref) THEN { true if is a new file or if ref found in old file }              		WITH Plt_Spec[10]^^,Expt_Info,SpectrumStuff,Spectrum_Info,acq_info        			DO BEGIN                        IF (NOT found) THEN	{new file or not found so append at eof}                          BEGIN { reset the number of refs, go to EOF }                            Rexpt_stuff^^.LastSpect := Rexpt_stuff^^.LastSpect + 1;                            bytecount := 2;                            errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');                            errCode := FSWrite_err(hold_refnum, bytecount, @Rexpt_stuff^^.LastSpect,'');                            errCode := SetFPos_err(hold_refnum, fsfromLEOF, 0,'');                           (* Spec_Displayed := Rexpt_stuff^^.LastSpect;*)                          END {If (not found)...}                        ELSE                          BEGIN { backup one References_Rec and replace the ref in the file }                            bytecount := sizeof(Expt_infoRec) + (longint(Spectrum_Counter) - 1) * 							                                     sizeof(References_rec);                            errCode := SetFPos_err(hold_refnum, fsFromStart, bytecount,'');                           (* Spec_Displayed := Spectrum_Counter;*)                          END;                        { set variables to allow clicking thru ref file }                        FOR index1 := 1 TO max_fitting_chans DO Ref_Stuff^^.data[index1] := 0.0;							                          Ref_Stuff^^.area := Zero;                        index1 := 0;                        FOR index := ROI^^.PEAK[nwin].Lo TO ROI^^.PEAK[nwin].Hi DO						BEGIN                            index1 := index1 + 1;                            Ref_Stuff^^.data[index1] := Col_1^[index];{was Plt_Spec[10]^^.S[index]}                            Ref_Stuff^^.area := Ref_Stuff^^.area + Ref_Stuff^^.data[index1];                        END;			            Ref_Stuff^^.source := source_name; {MCA_Filename ref derived from}						Ref_Stuff^^.spec_num := spectrum_number;              			Ref_Stuff^^.datemade := Begin_Time;         				Ref_Stuff^^.generated := Theoretically_generated;         				Ref_Stuff^^.Bkg_subtd := BkgSubtracted;						Ref_Stuff^^.Comments := Spectrum_Comment_Field;                          Ref_Stuff^^.Atomic_Number := theZ;                        Ref_Stuff^^.Family := theFamily;                        Ref_Stuff^^.LoE_Line := loEnergyLine;	{1/14/93: true values}                        Ref_Stuff^^.HiE_Line := hiEnergyLine;                        Ref_Stuff^^.dE := Plt_Spec[10]^^.Expt_Info.dE;                        Ref_Stuff^^.Intercept := Plt_Spec[10]^^.Expt_Info.Energy_Intercept;                        Ref_Stuff^^.Slope := Plt_Spec[10]^^.Expt_Info.Energy_Slope;						if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then                          Ref_Stuff^^.FWHM_Mn := Plt_Spec[10]^^.Expt_Info.Si_Resolution;						if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then                          Ref_Stuff^^.FWHM_Mn := Plt_Spec[10]^^.Expt_Info.WDS_Resolution;						{4/20/93: the following are calibrated energy values so convert back 						 to display the ref where it was in spectrum...}                        Ref_Stuff^^.Begin_Energy :=  (ROI^^.PEAK[nwin].lo * dE - energy_intercept)/energy_slope;                        Ref_Stuff^^.End_Energy := (ROI^^.PEAK[nwin].Hi * dE - energy_intercept)/energy_slope;                        bytecount := sizeof(References_rec);                        errCode := FSWrite_err(hold_refnum, bytecount, @Ref_Stuff^^,'');                      END; {If (Replace)...}                  END { If (Found)...}                  ELSE                  BEGIN                    numtostring(nwin, str1);                    str2 := concat('None of the elements is in Window ', str1);                    PutMessage(str2, '', '', '');                  END; { If ( not Found)...}              END; {For nwin:=1 to...}		{if the file was not open for writing before calling SaveRefSeg then close it}        if (openErr <> opWrErr) then  errCode := FSClose(hold_refnum);        errCode := FlushVol(NIL, RefSpec.vRefNum);      END; { SaveRefSeg }    PROCEDURE DisplayReferences;		Var			stop		: boolean;		    openerr		: OsErr;			savename                     : fnamestr;			savevol         			 : integer;			save_dirID					 : longint;			      BEGIN        myprompt := ' Display Reference File: ';        thePlane := 10;		  ref_typ[0] :=  mytype; 		  sfPtr := @ref_typ;		  StandardGetFile(NIL, 1, sfPtr, Inreply);		{¥¥New DTSA file spec¥¥}		  File_Cancel_Button := Inreply.sfGood;		  BeginUpdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);		  UpDate_SiLi_Window(SiLiWindow);		  if NOT Inreply.sfGood Then exit(DisplayReferences);		  Read_DTSA_Spec := Inreply.sfFile;		  RdBinaryName := Read_DTSA_Spec.name;		  InVol_volnum := Read_DTSA_Spec.vRefNum;		  InVol_DirID := Read_DTSA_Spec.parID;		  		  {The volume names in the folowing calls are all StringPtr}		  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}		  errcode := HSetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}		  errcode := HGetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}		  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}		          Binary_VolNum_Read := In_VolRefNum;		openerr := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);        IF ((openerr <> NoErr) and (openerr <> opWrErr)) THEN          BEGIN            BeepBeep;            PutMessage('The file did not open', '', '', '');            exit(DisplayReferences);          END;          MCA_Spectrum_Active := FALSE; 		  found := True;		  bytecount := sizeof(Expt_infoRec);		  errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');		  errCode := FSRead(hold_refnum, bytecount, @Plt_Spec[10]^^.Expt_Info);		  if (not Plt_Spec[10]^^.Expt_info.RefFile) then		  {means its an old file, before .RefFile was made; fix it}		  begin  		     Plt_Spec[10]^^.Expt_info.RefFile := true;             errCode := SetFPos_Err(hold_refnum, fsFromStart, 0,'');             bytecount := sizeof(expt_infoRec);			 errCode := FSWrite_Err(hold_refnum, bytecount, @Plt_spec[10]^^.Expt_Info,'');			 errCode := SetFPos_err(hold_refnum, fsFromstart, 0, '');			 errCode := FSRead_err(hold_refnum, bytecount, (@Plt_spec[10]^^.Expt_Info), '');		  end;	    		Displayed_Fst := Plt_Spec[10]^^.Expt_Info.FirstSpec;		Displayed_Lst := Plt_Spec[10]^^.Expt_Info.LastSpect;		DoRefSeg; { calls dialog that returns stepthru, or element to display }		 IF (not stepthru) THEN		  BEGIN        	Spectrum_Counter := 0;{ was set in FindRef, now just incremented there }			REPEAT				FindRef; { looks thru file for selected element and if found calls Display_theRef }				if (errcode = eoferr) then begin				  stop := true;				  putmessage('No more references in the  file.','','','');				end				else begin				 Displayed_Fst := Plt_Spec[10]^^.Expt_Info.FirstSpec;				 Displayed_Lst := Plt_Spec[10]^^.Expt_Info.LastSpect;				 stop := answermessage('I found the reference displayed in WORK.',										   'If IT`S OK, I`ll stop looking.',									'If IT`S NOT OK I`ll continue looking through the file.','');				end;								UNTIL stop;	{ }          END;		if openerr<>opWrErr then errCode := FSClose(hold_refnum);        errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);        IF (stepthru) THEN D_Spectrum_Picker;		{D_Spectrum_Picker in Utilities:reads the info from the file to ref_stuff hdl		 it makes...why does it make ref_stuff?? This is a global hdl made in Initialize.p}        (* Could put in some code to start this over til (File_Cancel_Button = False) *)	  END; {DisplayReferences}    PROCEDURE DeletetheRef;      Var openerr:OsErr;      BEGIN        { the file was selected when DisplayRef was called in File Menu }		openerr := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);		RdBinaryName := Read_DTSA_Spec.name;        IF ((openerr <> NoErr) and (openerr<> opWrErr)) THEN          BEGIN            BeepBeep;            PutMessage('The file did not open', '', '', '');            exit(DeletetheRef);          END        ELSE DoRefSeg; { puts up the delete box }        IF (delete) THEN          BEGIN            bytecount := sizeof(Expt_infoRec);            errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');            errCode := FSRead(hold_refnum, bytecount, @Rexpt_stuff^^);            IF (Spec_Displayed <> Rexpt_stuff^^.LastSpect) THEN              BEGIN                { read the last ref in the file }                bytecount := sizeof(Expt_infoRec) + (Rexpt_stuff^^.LastSpect - 1) * 				                                     sizeof(References_rec);                errCode := SetFPos_err(hold_refnum, fsFromStart, bytecount,'');                bytecount := sizeof(References_rec);                errCode := FSRead(hold_refnum, bytecount, @Ref_Stuff^^);                { go to position of the ref to delete and write the last ref over it}                bytecount := sizeof(Expt_infoRec) + (Spec_Displayed - 1) * sizeof(References_rec);                errCode := SetFPos_err(hold_refnum, fsFromStart, bytecount,'');                bytecount := sizeof(References_rec);                errCode := FSWrite_err(hold_refnum, bytecount, @Ref_Stuff^^,'');              END; {If ( Spec_Displayed <> Rexpt_stuff^^.LastSpect...}            { decrement the number of references in the file and write expt_info back in}            Rexpt_stuff^^.LastSpect := Rexpt_stuff^^.LastSpect - 1;            errCode := SetFPos_err(hold_refnum, fsFromStart, 0,'');            bytecount := sizeof(Expt_infoRec);            errCode := FSWrite_err(hold_refnum, bytecount, @Rexpt_stuff^^,'');            { write EOF where last ref used to be }            bytecount := sizeof(Expt_infoRec) + (Rexpt_stuff^^.LastSpect) * sizeof(References_rec);            errCode := setEOF(hold_refnum, bytecount);            Spec_Displayed := Spec_Displayed - 1;            Displayed_Fst := Rexpt_stuff^^.FirstSpec;            Displayed_Lst := Rexpt_stuff^^.LastSpect;          END; { if (delete)...}        if openerr <> opWrErr then errCode := FSClose(hold_refnum);        errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);      END; { DeletetheRef;}    BEGIN { DoReferences }      mytype := 'MCAr';      theFamily := ' ';      theZ := 0;    (*  Ref_Stuff := RefS(NewHandle(sizeof(References_rec)));	  if Ref_Stuff = NIL then begin  	  	    putmessage('not enough room in the heap zone for Ref_Stuff','','','');			exit(DoReferences);			end;	*)		      Rexpt_stuff := expth(NewHandle(sizeof(Expt_infoRec)));	  if Rexpt_stuff = NIL then begin  	  	    putmessage('not enough room in the heap zone for Rexpt_stuff','','','');	        H_UnLock_Dispose(Handle(Ref_Stuff),'Ref_Stuff xx'); 			exit(DoReferences);			end;	(*  MoveHHi(Handle(Ref_Stuff));*)	  If MemError<>noerr then begin	  	putmessage('err in MoveHHi for Ref_Stuff','','','');	       (* H_UnLock_Dispose(Handle(Ref_Stuff),'Ref_Stuff xx'); *)	        H_UnLock_Dispose(Handle(Rexpt_stuff),'Rexpt_stuff xx'); 		exit(DoReferences);		end;	  MoveHHi(Handle(Rexpt_stuff));	  If MemError<>noerr then begin	  	putmessage('err in MoveHHi for Rexpt_stuff','','','');	       (* H_UnLock_Dispose(Handle(Ref_Stuff),'Ref_Stuff xx'); *)	        H_UnLock_Dispose(Handle(Rexpt_stuff),'Rexpt_stuff xx'); 		exit(DoReferences);		end;    (*  HLock(Handle(Ref_Stuff));*)      HLock(Handle(Rexpt_stuff));      IF (Display_ref) THEN DisplayReferences      ELSE IF (Delete_Ref) THEN DeletetheRef      ELSE SaveRefSeg;	   (* if Ref_Stuff <> NIL then  begin	 putmessage('H_UnLock_Dispose(Handle(Ref_Stuff)','all current ref info is now lost','','');	 H_UnLock_Dispose(Handle(Ref_Stuff),'Ref_Stuff, in DoReferences ');  end;*)  H_UnLock_Dispose(Handle(Rexpt_stuff),'Rexpt_stuff, in DoReferences ');       END; { DoReferences }  {=================================}{$S CurveFit1}  PROCEDURE D_Ml_Dial;        CONST      I_Get_Setup_File              = 8;      I_Select_Elements             = 7;      I_Select_Derivatives          = 3;      I_Get_References              = 4;      I_Cancel                      = 2;      I_Do_Fit                      = 1;      I_Choose_Output_Options       = 5;      I_Save_Setup                  = 6;      I_x                           = 9;	  I_Help                        = 10;	  I_FlowChart                   = 11; (* CALLS:    PROCEDURE D_DoDerivs;    PROCEDURE Sort_The_elements;    PROCEDURE D_GetRefs;    PROCEDURE SetUp_All_Refs;*)	VAR    	  totalrefs                     : integer;	  refs_sel,only_setup          : boolean;	  Use_setup_file                : boolean;	  savesetup						: boolean;      nwindows                      : integer;      RefName                       : fnamestr;      errCode, refnum               : integer;      bytecount                     : LongInt;      ExitDialog                    : boolean;	  whre						  	: point;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : integer;      index                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      itemHit                       : integer;      str,str1,str2,str3,str4,str7,str8   : str255;	    PROCEDURE LLSQ_Help;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean;     CONST      G_Accept                      = 1;	  BEGIN                                               G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString('Linear Least Squares (LLSQ) is a curve fitting procedure that determines the areas of');	  n := n+1; moveto(Left,Top + n*offset);str := 'families of characteristic lines by scaling Reference distributions to the data. These Reference ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'distributions are usually obtained from acquired spectra that have been background subtracted.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'See Help under MLLSQ References in the Main Menu selection File for making and saving references.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To use the LLSQ, first go to ROI; indicate the bundles of peaks to be fit by using Peak Wipe.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Click LLSQ to call the setup dialog. Click Select Elements. Check each element that has any line';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'in any Peak Roi you have selected. The program sorts the elements for each ROI.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You will need a Reference for each set of lines for an element in each ROI.';DrawString(str); n := n+1; moveto(Left,Top + n*offset); str := 'Next click Select References: the file selection menu appears; pick a file to search. The program';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'tells you which references were not found and again presents the file selection menu.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'If all the required References are not found in five files you will be instructed to consolidate ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'the required references into five or fewer files. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' Derivatives is next. Clear All Derivatives unless you must fit a very small peak overlapped by';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'a very large peak and the spectrum resolution (use 1st Derivative) or energy calibration';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '(use 2nd Derivative) is slightly different from the reference.  Select Save Setup to save the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'input data for future use. Select Output Options to name the binary results file that is always';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'saved, to write a text file or make spreadsheet of results. Once you "OK" the setup information';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'it remains active for all LLSQ fitting. You may return to the LLSQ dialog at any time ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'to change the derivative information or output options even if you used a setup file.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'If you change the elements to fit, a new setup is required. "Cancel" simply exits the dialog.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Select "DO FIT" to fit only the WORK spectrum. To batch fit a whole file,';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'use Main Menu ANALYSIS: FIT FILE OF SPECTRA.  The information in results ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'files is obtained from the experiment and spectrum headers of the file';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'to be fit. HEADERS in the Main Menu gives you access to these headers.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '¥¥ADVANTAGES¥¥  Very fast. Gives error estimate for each area found.  ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '¥¥DISADVANTAGES¥¥ Needs References. Only finds amplitudes.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'NOTE: AutoROI may now be used from the "Select Elements" window to pick the ROIs.';DrawString(str); n := n+2; moveto(Left,Top + n*offset); REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		            DisposeDialog(G_Help);			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;END;                                              {End of LLSQ_Help procedure}  PROCEDURE Sort_The_elements;  { This is done only once; it sorts the families of the elements choosen into the windows;    it determines how many references are needed and the index of the first and last reference,    ie family, in each window so that D_GetRefs knows what    to read from the reference files. It is not called if a set_up file is used.}    VAR      index, wcntr,nfam,Numfams          : integer;      go_on                         	 : boolean;       { sort which element lines are in each window}    BEGIN { procedure Sort_The_elements: makes sure there are no more than Max_Num_Terms of elements }	       { in any window (since LLS Fit proc can only use Max_Num_Terms distributions) and no }		   { more than Max_num_refs required }      numtostring(Max_Num_References, str2);      str2 := concat('A maximum of ', str2, ' are allowed.');      Numfams := getHandleSize(Handle(SkipFam)) div sizeof(aFamily);       WITH ML_Setup^^ DO        BEGIN          number_of_refs := 0;          go_on := True;          FOR wcntr := 1 TO number_of_MLwindows DO            BEGIN			IF (number_of_refs < Max_Num_References) AND (go_on) THEN			  BEGIN				First_Ref[wcntr] := number_of_refs + 1;				Number_of_refs_in_Window[wcntr] := 0;				FOR index := 1 TO Number_of_Elements_Simplexed DO				  BEGIN					IF (go_on) AND (number_of_refs < Max_Num_References) THEN					  BEGIN					    IF (Number_of_refs_in_Window[wcntr]) = Max_Num_Terms THEN						BEGIN						  str1 := concat(A^.Sym[periodic_picks[index]],theFamily);						  str1 := concat('You have too many elements in the cluster which includes ', str1);						  go_on := answermessage(str1, str2,							 'You could reorganize this cluster, but if you prefer',							 'I will continue and fit only the maximum for this window.');						END					    ELSE BEGIN						  Xray_Data_Request := true; {gets book E values...}						  Get_energies(periodic_picks[index]);						  Xray_Data_Request := false;						  Get_Lo_Hi(wcntr);	{initializes found to false}						  {the assumption throughout LLSQ is that lines from only one						   family for each element can be in a ROI...}						  if (found) then begin							Number_of_refs_in_Window[wcntr] := Number_of_refs_in_Window[wcntr] + 1;							number_of_refs := number_of_refs + 1;							window_element[number_of_refs] := periodic_picks[index];							WEfamily[number_of_refs] := theFamily;							{these are book value energies...}							lo_line[number_of_refs] := loEnergyline;							hi_line[number_of_refs] := hiEnergyline;						    refindex[number_of_refs] := 0;	{...til ref found in D_GetRefs							                                 or set to -1 for skipping}							if Skip_some then							begin						      if (theFamily = 'K') then FamilyNum := 1							  else if (theFamily = 'L') then FamilyNum := 2							  else if (theFamily = 'M') then FamilyNum := 3;								 nfam := 0;								 Repeat									   nfam := nfam + 1;								   if ((SkipFam^^[nfam].Z = periodic_picks[Index]) and									   ((SkipFam^^[nfam].Roi  = wcntr) or (SkipFam^^[nfam].Roi = 1000))) then								   begin									 if (SkipFam^^[nfam].skip_fam = FamilyNum) then									 refindex[number_of_refs] := -1; 								   end;								 Until (nfam = numfams) or (refindex[number_of_refs] = -1);							end;	{if Skip_some ...}						  end;	{if (found)...}						END;						END;	 { IF (go_on) AND...}			  			    IF (number_of_refs = Max_Num_References) THEN				BEGIN				  go_on := False;				  IF (wcntr < number_of_MLwindows) THEN					PutMessage( 'I am sorting families for the Rois and I`ve reached',								'the max allowed for fitting, but there are more windows to do.',								' No elements will be fit for them.',								' You could EXIT and reconsider the setup.');				END; { If ( number_of_refs =...}			END; { For index := 1 to Number_of_Elements_Simplexed...WITH ML_Setup^^... }			IF (Number_of_refs_in_Window[wcntr] <1) THEN			BEGIN			  numtostring(wcntr, str1);			  str1:=concat('None of the chosen elements in Roi ',str1);			  First_Ref[wcntr] := 0;			  Last_Ref[wcntr] := 0;			  PutMessage( str1, '', '','')			END			ELSE Last_Ref[wcntr] := number_of_refs;			END; { if number_of_refs<...}		END; { for window_counter }          IF (number_of_refs <1) THEN            PutMessage(' NO chosen element is in any Peak ROI!', ' Please check your ROI setup.', '', '');        END; {WITH ML_Setup ...}    END; { Sort_The_elements }  PROCEDURE D_GetRefs;   { Reads files for reference distributions; finds the fitting range for each bundle of families;   it is called even with a setup file. Derivatives are added when the main dialog is closed in   Setup_all_refs.}    VAR	  {WDPBRec = record and WDPBPtr = ^WDPBRec are defined on IV-117}      index, Index2, Ch1, Ch2, Chn, nn, 	  Window_Counter, RoiChLo, RoiChHi,	  NumChs_in_Window, NumChs_in_Ref, Volume_Ref_Num: integer;      gotfilename, use_refile, refok: boolean;      errCode, cntr, rindex, refs_found, pathnum: integer;      myexpt_stuff                    : ExptH;      myRef_Stuff                     : RefS;	{there is a global variable with this name}      exptsize, refsize             : size;      L_window_counter              : integer;	  thename       				: fnamestr;      match                         : ARRAY [1..MaxNumPks] OF boolean;	  myblock						: HParamBlockRec;	  (*thevariant					: paramblkType;*)	  myWDblock						: WDPBRec;      SavedVolNum                   : integer;	  theEvent				        : EventRecord;	  	      BEGIN { procedure D_GetRefs}      exptsize := sizeof(Expt_infoRec);	 { Test_a_Handle(Handle(myexpt_stuff),'myexpt_stuff, D_GetRefs ');}      myexpt_stuff := ExptH(NewHandle(exptsize));	  if myexpt_stuff = NIL then begin  	  	    putmessage('not enough room in the heap zone for myexpt_stuff','in D_GetRefs','','');			exit(D_GetRefs);			end;      refsize := sizeof(References_rec);	 { Test_a_Handle(Handle(myRef_Stuff),'myexpt_stuff, myRef_Stuff ');}      myRef_Stuff := RefS(NewHandle(refsize));	  if myRef_Stuff = NIL then begin  	  	    putmessage('not enough room in the heap zone for myRef_Stuff','','','');	        H_UnLock_Dispose(Handle(myexpt_stuff),'myexpt_stuff xx'); 			exit(D_GetRefs);	  end;	  MoveHHi(Handle(myexpt_stuff));	  If MemError<>noerr then begin	  	putmessage('err in MoveHHi','myexpt_stuff','','');	        H_UnLock_Dispose(Handle(myRef_Stuff),'myRef_Stuff xx'); 	        H_UnLock_Dispose(Handle(myexpt_stuff),'myexpt_stuff xx'); 		exit(D_GetRefs);		end;	  MoveHHi(Handle(myRef_Stuff));	  If MemError<>noerr then begin	  	putmessage('err in MoveHHi','myRef_Stuff','','');	        H_UnLock_Dispose(Handle(myRef_Stuff),'myRef_Stuff xx'); 	        H_UnLock_Dispose(Handle(myexpt_stuff),'myexpt_stuff xx'); 		exit(D_GetRefs);		end;      HLock(Handle(myexpt_stuff));      HLock(Handle(myRef_Stuff));	   	  IF (NOT Use_setup_file) THEN	  BEGIN 			 if (ML_Setup^^.number_of_MLwindows <> Number_of_PeakRois - 1) then			   begin				 putmessage('in D_GetRefs, I lost number_of_MLwindows','set to Number_of_PeakRois - 1','','');				 ML_Setup^^.number_of_MLwindows:=Number_of_PeakRois - 1;			   end;		      FOR L_window_counter := 1 TO ML_Setup^^.number_of_MLwindows do			  with Plt_Spec[10]^^,Expt_Info		      DO BEGIN {FOR L_window_counter...calibrated energies}				  ML_Setup^^.ML_LoeV[L_window_counter] :=				  		(ROI^^.PEAK[L_window_counter].Lo * dE - energy_intercept)/energy_slope;				  ML_Setup^^.ML_HieV[L_window_counter] :=				  		(ROI^^.PEAK[L_window_counter].Hi * dE - energy_intercept)/energy_slope;		        END;	  END;	{ IF (NOT Use_setup_file)...}        refs_found := 0;      rindex := 0;      use_refile := true;            FOR index := 1 TO MaxNumPks DO match[index] := False;	  	  IF (NOT Use_setup_file) THEN	  begin	   	ML_Setup^^.number_of_files := 5;		for index:=1 to 5 do ML_Setup^^.The_File_Name[index] := '';        {FOR index := 1 TO MaxNumPks DO ML_Setup^^.refindex[index] := 0;		 ...refindex is inited in Sort_The_elements}	  end;        myprompt := 'Look in reference file:';				(*async:=false;*)      REPEAT {UNTIL ((File_Cancel_Button = False) OR 	  		         (refs_found = ML_Setup^^.number_of_refs));}		errcode := fnferr; { file not found }	  	if (use_refile) then rindex := rindex + 1;		use_refile := false; {set true when a needed ref is found in a file}        gotfilename := False;        mytype := 'MCAr';		   { when (rindex = ML_Setup^^.number_of_files +1) have searched the files		     listed in the setup and something was not found...why? }        IF (NOT Use_setup_file) or		   ((Use_setup_file) and (rindex = ML_Setup^^.number_of_files +1)) THEN		BEGIN		 gotfilename := (GetFileName(thename, mytype, mytype, myprompt));		 { IV-73: On exiting from SFGetFile by any means, OpenWD is called.		  If hierarchical file system:		     SFGetFile calls GetCatInfo; 		     the working directory is set to that of the chosen file;		     In_VolRefNum is then the Working Dir RefNum (not same as dirID which			    is unique on its volume) NOT a volume reference;		        on a flat system it's the vol refnum.           File_Cancel_Button and gotfilename are false if the Cancel button is pushed. }	     IF (gotfilename) then BEGIN		     ML_Setup^^.The_File_Name[rindex] := thename;{both are fnamestr}			 myWDblock.ioCompletion := NIL; {always NIL}		     myWDblock.ioVRefNum := In_VolRefNum; {working directory number}		     myWDblock.ioWDindex := 0;{0 because we are spcifying the dir by the WD ref num} 			 myWDblock.ioWDVRefNum := 0; 			 myWDblock.ioWDProcID := 0;	         myWDblock.ioNamePtr := StringPtr(NewPtr(sizeof(str255)));				   if myWDblock.ioNamePtr = NIL then				     begin					   SysBeep(1);				       putmessage('Not enough memory available for this operation',					   'Quit the program, then  do a "get info" and assign more memory to DTSA.','',''); 					   exit(D_GetRefs);					 end;			 			 errcode := PBGetWDInfoSync(@myWDblock);			 			 if errcode<>noerr then begin			 	str7:='uh-oh, err in PBGetWDInfo';				if errcode=bdnamerr then str7:=concat(str7,' bad filename');				if errcode=nsverr then str7:=concat(str7,' no such volume');				if errcode=paramerr then str7:=concat(str7,' no default volume');				if errcode=fnferr then str7:=concat(str7,' file not found');				    putmessage(str7,'','','');			 end	{if errcode<>noerr...}			 else if errcode = noerr then begin				My_File_Info[rindex].volname := myWDblock.ioNamePtr^;			 	My_File_Info[rindex].theDirID := myWDBlock.ioWDDirid; {dir id}				My_File_Info[rindex].volnum := myWDBlock.ioWDVRefNum;{always volume ref number}			    (*				   str6:=concat('open  ref volume name :',myWDblock.ioNamePtr^,'.');				   numtostring(myWDblock.ioVRefNum,str5);				   str5:=concat('is this the same? ',My_File_Info[rindex].volname,'.');				 				   numtostring(My_File_Info[rindex].theDirID,str7);				   str7:=concat('the ref volume dir ID is:',str7,',');				   numtostring(myWDblock.ioWDVRefNum,str8);				   str8:=concat('the ioWDVRefNum is:',str8,',');		debugstr(str7);*)			 end;	{else if errcode = noerr then begin...}		    DisposePtr(Ptr(myWDblock.ioNamePtr));			 myWDblock.ioNamePtr := NIL;			Err:= SetVol(nil,SavedVolNum);		   errcode := FSOPEN(thename,In_VolRefNum,pathnum);	{pathnum is returned}		   if errcode <> noerr then putmessage('uh-oh! NOT from setup, error in opening the file',thename,'','')		   else if errcode = noerr then			 if debugeron then putmessage('no error in FSOPEN',str2,'','');  		  End;	{ IF (gotfilename) then BEGIN...}		END		{ if not use setupfile...or...}				ELSE BEGIN	{ using setup file...}			 thename := ML_Setup^^.The_File_Name[rindex]; {used below! don't delete}			 Volume_Ref_Num := My_File_Info[rindex].volnum;			 (*thevariant := fileparam;*)			 myblock.ioCompletion := Nil;			 myblock.ioNamePtr:= @ML_Setup^^.The_File_Name[rindex]; {the file name};			 myblock.ioVRefNum := Volume_Ref_Num; {the vol num};			 myblock.iopermssn:= FSRdPerm;				{IV-120:fsCurPerm,fsRdPerm,fsWrPerm,fsRdWrPerm,fsRdWrShPerm};			 myblock.iomisc:=NIL; {see IV-121 and IV-135};			 myblock.ioDirID := My_File_Info[rindex].theDirID; {the DirID };	(*	numtostring(myblock.ioDirID,str6);		str6:=concat('myblock.ioDirID ',str6);		debugstr(str6); *)			 errcode:=PBHOpenSync(@myblock);			 str7:=concat('uh-oh, from setup, err in PBHOpen file ',myblock.ioNamePtr^);			 IF errcode = noerr THEN			 BEGIN				 pathNum:=myblock.ioRefNum;				{ putmessage('the file ',thename,'opened on volume',str2);}			 END			 ELSE IF errcode = nsverr THEN			 BEGIN			    theEvent.what := 0;				repeat				    numtostring(rindex,str8);					str8:=concat('Uh-oh! Ref ',str8,' is on the volume named ',My_File_Info[rindex].volname);					refok:= (answermessage(str8,'I couldn`t find it. I`ll assume it is a removable disk.',									'If so, insert the disk and  click IT`S OK. ',									'If it`s NOT OK, we`ll get any other refs then try something else.'));					if refok then gotfilename := GetNextEvent(diskMask, theEvent);				until ((gotfilename) or (not refok));								if ((theEvent.what = 7) and					(HiWord(theEvent.message) = noErr)) 				then begin					  {  putmessage('the GetNextEvent worked;','','','');}						errcode:=PBHOpenSync(@myblock);						if errcode = noerr then begin							  pathNum:=myblock.ioRefNum;							(*  numtostring(pathNum,str6);							  str6:=concat('the path num returned is ',str6);						      str5:=concat(str2,':',thename);							  putmessage('success from PBHOpen reffile',str5,str6,'');*)						end						else if errcode=nsverr then str8:='no such vol'						else if errcode=bdnamerr then str8:='bad filename' 						else if errcode=opwrerr then str8:='file already open' 						else if errcode=bdnamerr then str8:='bad filename' 						else if errcode=dirnferr then str8:='dir not found'						else str8:='none of the expected errors';						if errcode <> noerr then						    putmessage('After you inserted the disk,',							           'the file failed to open:',str8,'');				end				else if refok then begin				     numtostring(HiWord(theEvent.message),str8);					 str8:=concat('Sorry,that failed. Error was ',str8,'.');					 putmessage(str8,'',								'When the file selection menu comes up,',								'pick another file of references.');				     end;			 END	{ else if errcode = nsverr...}			 ELSE BEGIN				if errcode = bdnamerr then str8:=' bad filename'				else if errcode=dirNFErr then str8:=' dir not found/inc pathname'				else if errcode=extfsErr then str8:=' ext file sys'				else if errcode=fnferr then str8:=' file not found '				else if errcode=ioerr then str8:=' I/O err '				else if errcode=opwrerr then str8:=' file already open'				else str8:='none of the standard error codes applies';				putmessage(str7,str8,'','');			 END;	{else begin...}		END;	{ if using setup file }		IF errCode = NoErr THEN {set to fnerr at each main repeat so if cancel getfilename...}        BEGIN	{the file opened, now search for refs}		  If Use_setup_file	then use_refile := true;		  {if not Use_setup_file set true when a needed ref is found in the file}		  errCode := SetFPos_err(pathnum, fsFromStart, 0,'');		  errCode := FSRead(pathnum, exptsize, (@myexpt_stuff^^));		  refok := True;		  IF (myexpt_stuff^^.dE <> Plt_Spec[10]^^.Expt_Info.dE)		  THEN refok := answermessage(' The reference file eV per channel differs from the data.',									  ' You may proceed but the fitting results may not be very good.',									  ' If IT`S OK, I`ll go on.','');		  IF refok THEN		  IF (myexpt_stuff^^.kV > Plt_Spec[10]^^.Expt_Info.kV + 0.05 * Plt_Spec[10]^^.Expt_Info.kV) OR 			 (myexpt_stuff^^.kV < Plt_Spec[10]^^.Expt_Info.kV - 0.05 * Plt_Spec[10]^^.Expt_Info.kV)		  THEN refok := answermessage(' The KV of the reference file differs from the data by more than 5%.',									 ' You may proceed but the fitting results may not be optimal,',									 '  especially at lower voltages.', 'If IT`S OK, I`ll go on.');                        		  IF refok THEN		  begin		   if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then			IF (myexpt_stuff^^.Si_Resolution > Plt_Spec[10]^^.Expt_Info.Si_Resolution + 0.02 * Plt_Spec[10]^^.			   Expt_Info.Si_Resolution) OR (myexpt_stuff^^.Si_Resolution < Plt_Spec[10]^^.Expt_Info.Si_Resolution -			   0.02 * Plt_Spec[10]^^.Expt_Info.kV) THEN			  refok := answermessage(				 ' The resolution of the reference spectra differs from the data by more than 5%.'				  , ' You may proceed but the fitting results, EVEN WITH DERIVATIVES,',				  ' may not be optimal.', 'If IT`S OK, I`ll go on.'); 		   if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then			IF (myexpt_stuff^^.WDS_Resolution > Plt_Spec[10]^^.Expt_Info.WDS_Resolution + 0.02 * Plt_Spec[10]^^.			   Expt_Info.WDS_Resolution) OR (myexpt_stuff^^.WDS_Resolution < Plt_Spec[10]^^.Expt_Info.WDS_Resolution -			   0.02 * Plt_Spec[10]^^.Expt_Info.kV) THEN			  refok := answermessage(				 ' The resolution of the reference spectra differs from the data by more than 5%.'				  , ' You may proceed but the fitting results, EVEN WITH DERIVATIVES,',				  ' may not be optimal.', 'If IT`S OK, I`ll go on.');			end;		  IF (refok) THEN WITH ML_Setup^^ DO		  BEGIN			FOR L_window_counter := 1 TO ML_Setup^^.number_of_MLwindows DO			 BEGIN			  FOR cntr := First_Ref[L_window_counter] TO Last_Ref[L_window_counter] DO			   BEGIN {go through file looking for match to each unmatched ref in each window}				errCode := SetFPos_err(pathnum, fsFromStart, exptsize,''); { at start of ref segs}				index := 0; { counts number of refs compared from file }				IF (refindex[cntr] = -1)  and ( NOT match[cntr] ) THEN				BEGIN					refs_found := refs_found + 1;					match[cntr] := true;				END				ELSE IF ( NOT match[cntr] )(* and (refindex[cntr] <> -1)*)THEN				REPEAT { read ref segs until a match is found or out of segs }				  index := index + 1;				  errCode := FSRead(pathnum, refsize, (@myRef_Stuff^^));				  IF (myRef_Stuff^^.Atomic_Number = window_element[cntr]) AND					 (myRef_Stuff^^.Family = WEfamily[cntr]) and					 { book values...}					 (myRef_Stuff^^.loE_line <= lo_line[cntr]) and					 (myRef_Stuff^^.hiE_line >= hi_line[cntr]) then					BEGIN	{ the actual chs of the ref to use are determined below }					  use_refile := True;					  refs_found := refs_found + 1;					  FOR nn := 1 TO max_fitting_chans DO 							  reference[cntr]^^.data[nn] := Zero;					  reference[cntr]^^ := myRef_Stuff^^;					  match[cntr] := True;					  RefIndex[cntr] := rindex;					END; { If (myRef_Stuff^^.Atomic_number...Then Begin...}				UNTIL (match[cntr]) OR (index = myexpt_stuff^^.LastSpect);				IF (NOT match[cntr]) and (refindex[cntr] = 0 ) THEN				Begin				  numtostring(L_window_counter,str4);				  str3 := concat(A^.Sym[window_element[cntr]], WEfamily[cntr]); 				  str4 := concat('ROI ',str4,' requires a reference for ',str3,' that includes all the lines from ');				  realtostring(lo_line[cntr],5,2,str7);				  realtostring(hi_line[cntr],5,2,str8);				  if use_setup_file then begin					 str7:=concat('the one at ',str7,' ev to that at ',str8,' ev.');					 str3:= ' You skipped it when you made this setup. If IT`S OK, I`ll skip it too.';				     str1 := 'If IT`S NOT OK, I`ll look for the reference.';				  end else				  begin					 str7:=concat('the one at ',str7,' ev to that at ',str8,' ev. I couldn`t find one.');					 str3:= 'You may pick another file to search or quit this setup via file menu CANCEL,),';				     str1 := 'but if you`re SURE IT`S OK, we could skip those lines.';				  end;				  if AnswerMessage(str4,str7,str3,str1) then					begin					  match[cntr] := True;	{this keeps us from looking in another file}					  RefIndex[cntr] := 0;	{this means skip these lines in the fit}					  ML_Setup^^.DoFirst[cntr] := false;					  ML_Setup^^.DoSecond[cntr] := false;					  refs_found := refs_found + 1;					end;				End;	{ IF (NOT match[cntr]) and (refindex[cntr] = 0 )...}			   END; {For cntr:=First_Ref...}			 END; {FOR L_window_counter...}			 END; { IF (refok) THEN WITH ML_Setup^^...there is no ELSE}			 			 errCode := FSClose(pathnum); { close file in either case }			 errCode := FlushVol(NIL, In_VolRefNum);			{ We have finished searching one ref file for required distributions. }						IF ((refs_found < ML_Setup^^.number_of_refs) AND (NOT Use_setup_file))			THEN IF (rindex >= 5) THEN			  PutMessage(' You may access only 5 reference files, but you need more references.',						 ' Please make a file with all the references you need for the analysis.',						 ' ', '');		END {IF errCode = NoErr...on opening the ref file}		ELSE if (Use_setup_file) THEN BEGIN {if there was an error opening the file}	   {The rindex file in the setup set failed to open so increment and try next one.		When rindex > ML_Setup^^.number_of_files, the file menu will come up.}		  rindex := rindex + 1;	{ userefile is still false so it won't index above }		 { putmessage('a ref file listed in the setup failed to open','','','');}		END;	  UNTIL ((File_Cancel_Button = False) OR 	         (refs_found = ML_Setup^^.number_of_refs));	      	  IF (refs_found = ML_Setup^^.number_of_refs) THEN	  BEGIN	   refs_sel := True;	   WITH ML_Setup^^ DO BEGIN		IF (NOT Use_setup_file) THEN		BEGIN		    number_of_files := rindex;			if (ML_Setup^^.number_of_MLwindows <> Number_of_PeakRois - 1) then			  begin				putmessage('later in D_GetRefs, i lost number_of_MLwindows again','set to Number_of_PeakRois - 1','','');				ML_Setup^^.number_of_MLwindows:=Number_of_PeakRois - 1;			  end;	    END;		FOR Window_Counter := 1 TO ML_Setup^^.number_of_MLwindows DO		BEGIN {FOR Window_Counter...}		 {The the refs chns to use are defined by the rois. If the spectrum to fit is calibrated, 		  ML_LoeV and ML_Hiev are calibrated energies. We can't re-bin the ref distribution...}		  		  {The first and last ch in the Roi in spectrum with cal off (or on, too)...}		   RoiChLo := rinttol((ML_LoeV[Window_Counter] * Plt_Spec[10]^^.Expt_Info.energy_slope +									   Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE);		   RoiChHi := rinttol((ML_HieV[Window_Counter] * Plt_Spec[10]^^.Expt_Info.energy_slope +									   Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE);		   NumChs_in_Window := RoiChHi - RoiChLo + 1;		   FOR index := First_Ref[Window_Counter] TO Last_Ref[Window_Counter] DO		   IF RefIndex[index] > 0 THEN		   BEGIN {for index := First_Ref...}		{ Each saved distribution is written from Chn1 to ChnN in Reference[index]^^.data[Chn]		  where Chn1 corresponds to uncalibrated Begin_Energy in the source spectrum. We can't		  rebin the ref but we can place it at about the correct energy in the Roi.		  Move it to chn that corresponds to its correct position in the spectrum Roi... }		  {both calibrated energies...}		   NumChs_in_Ref := rinttol((reference[index]^^.End_Energy * reference[index]^^.slope +							       reference[index]^^.intercept)/reference[index]^^.dE) - 							rinttol((reference[index]^^.Begin_Energy * reference[index]^^.slope +							       reference[index]^^.intercept)/reference[index]^^.dE) + 1;		     If reference[index]^^.Begin_Energy < ML_LoeV[Window_Counter] then			 begin {determine the chn less 1 IN THE REF that equals ML_LoeV[Window_Counter]...}				 Chn := rinttol((ML_LoeV[Window_Counter] * reference[index]^^.slope +							   reference[index]^^.intercept)/ reference[index]^^.dE) -  						rinttol((reference[index]^^.Begin_Energy * reference[index]^^.slope +							   reference[index]^^.intercept)/ reference[index]^^.dE);				 Ch1 := 1;	{the ref starting at channel Chn + 1 goes here in Col_1				             and back here in ref}				{If the # of chs in the ref from Chn to end of ref > number in the ROi then				 copy NumChs_in_Window # of chs from the ref to col_1..}				 if (NumChs_in_Ref - Chn) >= NumChs_in_Window 					 then Ch2 := NumChs_in_Window				 else Ch2 := NumChs_in_Ref - Chn;			 end			 Else {find the ch1 in the user roi to which the 1st ref ch cnts should go}			 Begin	{Begin_Energy is calibrated true energy}				 Chn := 0; {...so 1 is the first ch from the ref to write to ch1 }				 {Where does it go in Col_1?...}				 Ch1 := rinttol((reference[index]^^.Begin_Energy * Plt_Spec[10]^^.Expt_Info.energy_slope +							   Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE) -		                RoiChLo + 1;			    {if # of values in ref > # of chs of roi to write in then write the number from Ch1				 to end of roi, else write the number of ref chs...} 				if (NumChs_in_Ref >= (NumChs_in_Window - Ch1 + 1)) then										Ch2 := (NumChs_in_Window) (*	¥¥¥¥¥							    Ch2 := (NumChs_in_Window - Ch1 + 1) *)				else  Ch2 :=  Ch1 + NumChs_in_Ref - 1;			 End;(*numtostring(chn,str1);str := concat('1st ch from ref to write to col_1 ',str1);numtostring(ch1,str2);			  numtostring(ch2,str3);str1 := concat('1st and last ch to write in Col_1 ',str2,',',str3);putmessage(str,str1,'','');*)			  			   For nn := 1 to Maximum_Channels do Col_1^[nn] := zero;			   reference[index]^^.area := zero;			  { copy reference data from value # Chn into spectrum space col_1^ data value			     Ch1 to Ch2...}			   FOR Index2 := Ch1 TO Ch2 DO				 BEGIN				   Chn := Chn + 1;{the 1st data value in the ref to write}				   Col_1^[Index2] := reference[index]^^.data[Chn];				   reference[index]^^.area := reference[index]^^.area + reference[index]^^.data[Chn];				 END;				 			   FOR Index2 := 1 TO Max_Fitting_Chans DO { move reference data to new chs }				 BEGIN				   reference[index]^^.data[Index2] := zero;				   reference[index]^^.data[Index2] := Col_1^[Index2];				 (*  Plt_Spec[8]^^.S[RoiChLo-1+Index2] := Col_1^[Index2]; *)				 END;			END {for index := First_Ref...IF RefIndex[index] > 0...}			ELSE FOR Index2 := 1 TO Max_Fitting_Chans DO					  reference[index]^^.data[Index2] := zero;		END; {FOR Window_Counter...}	   END;	{WITH ML_Setup^^...}	  END;	{ IF (refs_found =...}   	  H_UnLock_Dispose(Handle(myexpt_stuff),'myexpt_stuff in D_GetRefs ');		  H_UnLock_Dispose(Handle(myRef_Stuff),'myRef_Stuff in D_GetRefs ');	    END; { procedure D_GetRefs}  {=================================}  PROCEDURE SetUp_All_Refs;  { This is called with or without a setup file; the derivative references are made now    because these are allowed to be changed even with a setupfile. }    VAR      index, Index2, 	   Window_Counter,NumChs_in_Window,FirstCh,LastCh: integer;	      BEGIN { PROCEDURE SetUp_All_Refs; }		WITH ML_Setup^^, Analysis_Result^^.Fit_Params DO BEGIN		  FOR index := 1 TO 5 DO Ref_filename[index] := ML_Setup^^.The_File_Name[index];		  Number_of_Peaks := 0;		  totalrefs := ML_Setup^^.number_of_refs; { total number of families to be fit }          Number_of_derivs := 0;	  			if (not Use_setup_file) and (ML_Setup^^.number_of_MLwindows <> Number_of_PeakRois - 1) then			begin			  putmessage('in SetUp_All_Refs, i lost number_of_MLwindows ','set to Number_of_PeakRois - 1','','');			  ML_Setup^^.number_of_MLwindows := Number_of_PeakRois - 1;			end;                   FOR Window_Counter := 1 TO ML_Setup^^.number_of_MLwindows DO          BEGIN {FOR Window_Counter...}			ML_Setup^^.First_Deriv[Window_Counter] := totalrefs;			ML_Setup^^.Last_deriv[Window_Counter] := 0;			if (not Use_setup_file) then NumChs_in_Window := ROI^^.PEAK[Window_Counter].Hi -								                             ROI^^.PEAK[Window_Counter].Lo + 1	        else begin				  FirstCh := rinttol((ML_LoeV[Window_Counter] * Plt_Spec[10]^^.Expt_Info.energy_slope +											  Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE);				  LastCh := rinttol((ML_HieV[Window_Counter] * Plt_Spec[10]^^.Expt_Info.energy_slope +											 Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE);				  NumChs_in_Window := LastCh - FirstCh + 1;	        end;            first_in_roi[Window_Counter] := Number_of_Peaks + 1;   			  FOR index := ML_Setup^^.First_Ref[Window_Counter] TO 			               ML_Setup^^.Last_Ref[Window_Counter] DO                BEGIN {for index := First_Ref...}				  {get even lines that aren't to be fit but were in the rois so we can 				   have a skip notice printed for them}				  Number_of_Peaks := Number_of_Peaks + 1;				  Atomic_Number[Number_of_Peaks] := ML_Setup^^.window_element[index];				  Siegbahn[Number_of_Peaks] :=concat(ML_Setup^^.WEfamily[index],'    ');				  ev_LoLine[Number_of_Peaks] := lo_line[index]; 				  ev_HiLine[Number_of_Peaks] := hi_line[index]; 				  Ref_Index[Number_of_Peaks] := ML_Setup^^.refindex[index];{the # of the file with ref}(*		 str1 := concat('in SetUp_All_Refs the file for this ref ',ML_Setup^^.The_File_Name[ML_Setup^^.refindex[index]]);		debugstr(str1);	*)				  {if we didn't have a ref for a line that sorting found, Ref_Index = 0;				   if we chose to skip a line Ref_Index = -1;				   the derivative booleans were set false.}				  IF (DoFirst[index]) THEN                    BEGIN                      totalrefs := totalrefs + 1;	{starts at number_of_refs}                       reference[totalrefs]^^ := reference[index]^^;                      FOR Index2 := 1 TO Max_Fitting_Chans DO					  				 reference[totalrefs]^^.data[Index2] := zero;					  CFirst_Derivative(NumChs_in_Window, 					                    reference[index]^^.data, 										reference[totalrefs]^^.data);                      reference[totalrefs]^^.area := 0;                      FOR Index2 := 1 TO NumChs_in_Window DO                        reference[totalrefs]^^.area := 						            reference[totalrefs]^^.area + reference[totalrefs]^^.data[Index2];				      Number_of_Peaks := Number_of_Peaks + 1;					  Siegbahn[Number_of_Peaks] := concat(Siegbahn[Number_of_Peaks - 1][1], '  D1');					  Atomic_Number[Number_of_Peaks] := ML_Setup^^.window_element[index];				      Ref_Index[Number_of_Peaks] := refindex[index];					  ev_LoLine[Number_of_Peaks] := lo_line[index]; 					  ev_HiLine[Number_of_Peaks] := hi_line[index];                     END; { If (DoFirst[index])...}                  IF (DoSecond[index]) THEN                    BEGIN                      totalrefs := totalrefs + 1;                      reference[totalrefs]^^ := reference[index]^^;                      FOR Index2 := 1 TO Max_Fitting_Chans DO					  				 reference[totalrefs]^^.data[index2] := zero;                      CSecond_Derivative(NumChs_in_Window, 					                     reference[index]^^.data, 										 reference[totalrefs]^^.data);                      reference[totalrefs]^^.area := 0;                      FOR Index2 := 1 TO NumChs_in_Window DO                        reference[totalrefs]^^.area := reference[totalrefs]^^.area +												       reference[totalrefs]^^.data[Index2];                                                       					  Number_of_Peaks := Number_of_Peaks + 1;			          Siegbahn[Number_of_Peaks] := concat(Siegbahn[Number_of_Peaks - 1][1], '  D2');					  Atomic_Number[Number_of_Peaks] := ML_Setup^^.window_element[index];				      Ref_Index[Number_of_Peaks] := refindex[index];					  ev_LoLine[Number_of_Peaks] := lo_line[index]; 					  ev_HiLine[Number_of_Peaks] := hi_line[index];                     END; {If (DoSecond[index]...)}				END; {for index := First_Ref...}              IF (totalrefs > First_Deriv[Window_Counter]) THEN                BEGIN      			  number_of_derivs_Window[Window_Counter] :=				  			totalrefs -  First_Deriv[Window_Counter];                  First_Deriv[Window_Counter] := First_Deriv[Window_Counter] + 1;                  Last_deriv[Window_Counter] := totalrefs;                END              ELSE First_Deriv[Window_Counter] := 0;            END; {FOR Window_Counter...}        END; { WITH ML_Setup^^...}		ML_Setup^^.number_of_derivs := totalrefs - ML_Setup^^.number_of_refs ;    END; {Procedure SetUp_All_Refs}  {=================================}  PROCEDURE D_DoDerivs; { This dialog allows user to choose the derivatives to use. These may be changed from the   setup file but the changes will only be saved if a setup file is saved. }    CONST                             {These are the item numbers for controls in the Dialog}      I_Done                        = 1;              {button}      I_Accept                      = 2;              {button}      I_2ND_DERIVATIVE              = 3;              {checkbox}      I_1ST_DERIVATIVE              = 4;              {checkbox}      I_inst                        = 5;              { Instruction - Static Text }      I_Element                     = 6;              { Label, Element: - Static Text }      I_EleInput                    = 7;              { Space for input - Edit Text }      I_Clear_Derivatives           = 8;              { button }	  I_Lines						=12;			  { Static text: lines for ROI n }        VAR      numinwin                      : NPKARRAY;      nw                            : integer;      ExitDialog		            : boolean;              accept, found, setup_derivs   : boolean;      GetSelection                  : DialogPtr;            DType                         : integer;              index,done,nn                 : integer;              DItem,DTempItem               : Handle;               CItem			                : controlhandle;        sTemp                         : str255;      ssTemp						: STRING[1];               itemHit                       : integer;               temp, temp1                   : integer;             str,str1,str2,str4,str5,str7,Zinput,histr,lostr   : str255;	  whre							: point;	     PROCEDURE Refresh_Dialog;             BEGIN        SetPort(GetSelection); {Point to our dialog window}			GetDialogItem(GetSelection, I_Done, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, - 4, - 4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);		      END;    BEGIN {Start of dialog handler D_DoDerivs}      GetSelection := GetNewDialog(7001, NIL, Pointer( - 1)); 	  CenterDialog(GetSelection,TRUE,whre);      ShowWindow(GetSelection); {Open a dialog box}      SelectWindow(GetSelection); {Lets see it}      SetPort(GetSelection); {Prepare to add conditional text}	{These MUST be defined each time...we come to this dialog}      totalrefs := ML_Setup^^.number_of_refs;  if (not Use_setup_file) and (ML_Setup^^.number_of_MLwindows <> Number_of_PeakRois - 1) then	begin	  putmessage('in D_DoDerivs, i lost number_of_MLwindows ','set to Number_of_PeakRois - 1','','');	  ML_Setup^^.number_of_MLwindows := Number_of_PeakRois - 1;	end;      for nw := 1 to ML_Setup^^.number_of_MLWindows do numinwin[nw] := 0;	        numtostring(Max_Num_Terms, str);      numtostring(Max_Num_References, str4);      str := concat('You may use only ', str, ' fitting distributions in a window.');      str1 := ' This 1st derivative will be the last accepted. Sorry.';      str2 := ' This 2nd derivative will be the last accepted. Sorry.';      str4 := concat('You may use only ', str4, ' fitting distributions in an ML fit.');	        ExitDialog := False;  	  index := 0;	  done:=0;	  found := true;	 	 REPEAT {until I_Done} {Start of dialog handle loop}	   accept := False;	   IF (ML_Setup^^.number_of_derivs >0) and {number_of_derivs counts 1st and 2nd}	      (done < ML_Setup^^.number_of_refs) THEN	   BEGIN		  {In order check each ref for a derivative. If found put the info up. It		   can be changed.  Then go to the inner repeat til accept or clear all.		   Index must increment only here til all refs checked.}		 GetDialogItem(GetSelection, I_Done, DType, DItem, tempRect); 		 HiliteControl(controlhandle(DItem), 255); {comes on after all derivatives in setup checked}	     	     found := true; {keeps us out of the search in next main repeat}		 setup_derivs := false;		  REPEAT	{until find a ref with derivatives or out of refs}		  index := index + 1;		  done := done + 1; 		 { Need done because index will change when we finish with setup derivatives.		   once done = ML_Setup^^.number_of_refs, we can't get here.}		  IF (ML_Setup^^.DoFirst[index] or ML_Setup^^.DoSecond[index]) THEN		  BEGIN			 setup_derivs := true;			 str := concat(A^.Sym[ML_Setup^^.window_element[index]], ML_Setup^^.WEfamily[index]);             GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect); 			 SetDialogItemText(DItem, str);			 			 nw := 0;			 Repeat	{which window is this index in?}			   nw := nw + 1;			 Until ((index <= ML_Setup^^.Last_Ref[nw]) AND 					(index >= ML_Setup^^.First_Ref[nw]));						 realtostring(lo_line[index],5,2,lostr);			 realtostring(hi_line[index],5,2,histr);			 numtostring(nw,str7);			 str :=concat('Reference for lines from ',lostr,'ev to ',histr,'ev in ROI',str7);			 GetDialogItem(GetSelection, I_Lines, DType, DItem, tempRect); 			 SetDialogItemText(DItem, str); {set the text entered}			 			 IF (ML_Setup^^.DoFirst[index]) THEN			   BEGIN				 GetDialogItem(GetSelection, I_1ST_DERIVATIVE, DType, DItem, tempRect); 				 CItem := controlhandle(DItem); 				 HiliteControl(CItem, 0);				 SetControlValue(CItem, 1);			   END;			 IF (ML_Setup^^.DoSecond[index]) THEN			   BEGIN				 GetDialogItem(GetSelection, I_2ND_DERIVATIVE, DType, DItem, tempRect); 				 CItem := controlhandle(DItem); 				 HiliteControl(CItem, 0);				 SetControlValue(CItem, 1);			   END;			END;	{ IF (ML_Setup^^.DoFirst[index] or ...}		UNTIL setup_derivs or (index = ML_Setup^^.number_of_refs);		{note that index will remain at the current value so that when we accept for		 the current value it continues to increment}		 {if done >= ML_Setup^^.number_of_refs but do_first and do_second are false,		  no text appears in ele_input or lines and we drop down to inputting els}	    IF (done = ML_Setup^^.number_of_refs) THEN	    BEGIN		  GetDialogItem(GetSelection, I_Done, DType, DItem, tempRect); 		  HiliteControl(controlhandle(DItem), 0); {turn it back on}		  done:= MaxNumPks + 1;{so we can't get back into this loop}		 { index:=0;} {cannot set it zero here: accept won't get info; ele_input=>zero}		  found := true;	    END;	  END;	{ IF (ML_Setup^^.number_of_derivs >0) and done<...} 	  Refresh_Dialog;			  REPEAT {until Accept}		   IF (not found) then { set false if z/family defined in I_ele_input		   					     or if accept; index=>0 only in I_ele_input}		   BEGIN			 IF (index < ML_Setup^^.number_of_refs) THEN 			 BEGIN				REPEAT	{ UNTIL (index = ML_Setup^^.number_of_refs) OR (found); }				 index := index + 1; {index => 0 only in I_ele_input}				 ssTemp := sTemp[3];				 IF (ML_Setup^^.window_element[index] = AtSymbol_to_Znum(Zinput)) AND 					(ML_Setup^^.WEfamily[index] = ssTemp) THEN				   BEGIN {if (ML_Setup^^....}					 found := True; { so we can't get back in here until set false after accept}					 GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect); 					 SetDialogItemText(DItem, stemp);					 nw := 0;					 REPEAT	{which window is this index in?}					   nw := nw + 1;					 UNTIL ((index <= ML_Setup^^.Last_Ref[nw]) AND 							(index >= ML_Setup^^.First_Ref[nw]));					 realtostring(lo_line[index],5,2,lostr);					 realtostring(hi_line[index],5,2,histr);					 numtostring(nw,str7);					 str :=concat('Reference for lines from ',lostr,'ev to ',histr,'ev in ROI',str7);					 GetDialogItem(GetSelection, I_Lines, DType, DItem, tempRect); 					 SetDialogItemText(DItem, sTr); {set the text entered}					 IF (ML_Setup^^.DoFirst[index]) THEN					   BEGIN						 GetDialogItem(GetSelection, I_1ST_DERIVATIVE, DType, DItem, tempRect); 						 SetControlValue(controlhandle(DItem), 1);					   END;					 IF (ML_Setup^^.DoSecond[index]) THEN					   BEGIN						 GetDialogItem(GetSelection, I_2ND_DERIVATIVE, DType, DItem, tempRect); 						 SetControlValue(controlhandle(DItem), 1);					   END;					END;	{ IF (ML_Setup^^.window_element[index] =...}				UNTIL found or (index = ML_Setup^^.number_of_refs);			  END;	{ IF (index < ML_Setup^^.number_of_refs...}			  IF (not found) and (index = ML_Setup^^.number_of_refs) then			  BEGIN				(* str5 := concat('No more ROIs with lines from ',stemp,' family.');				 PutMessage(str5, '', '', 'Supply the next element and family.');                *)				{ str :=concat('No more ROIs with that family. Next?');}				 str :=concat('                               No more ROIs with that family.   Next?');			     GetDialogItem(GetSelection, I_Lines, DType, DItem, tempRect); 				 SetDialogItemText(DItem, str); {set the text entered}						 GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect); 				 HiliteControl(controlhandle(DItem), 255);{comes on when ele input}			  END;	{ ELSE BEGIN	IF (index >...}		  END;	{ IF (not found) then...}          ModalDialog(NIL, itemHit);           GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);           CItem := controlhandle(DItem);                      IF (itemHit = I_Done) THEN            BEGIN              accept := True;              ExitDialog := True;             END;          IF (itemHit = I_Accept) THEN accept := True;          IF (itemHit = I_Clear_Derivatives) THEN            BEGIN {this must all be done here because if next itemHit = I_Exit			        nothing else is done except closing the dialog}			  			  str3:=concat('');			  GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect); 			  SetDialogItemText(DItem, '');			  GetDialogItem(GetSelection, I_Lines, DType, DItem, tempRect); 			  SetDialogItemText(DItem, ''); {set the text entered}			  			  GetDialogItem(GetSelection, I_1ST_DERIVATIVE, DType, DItem, tempRect); 			  CItem := controlhandle(DItem); 			  HiliteControl(CItem, 0);			  SetControlValue(CItem, 0);			  GetDialogItem(GetSelection, I_2ND_DERIVATIVE, DType, DItem, tempRect); 			  CItem := controlhandle(DItem); 			  HiliteControl(CItem, 0);			  SetControlValue(CItem, 0);			  			  GetDialogItem(GetSelection, I_Done, DType, DItem, tempRect);               CItem := controlhandle(DItem);               HiliteControl(CItem, 0);			  GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);               HiliteControl(controlhandle(DItem), 255);			 			  ML_Setup^^.number_of_derivs := 0;			  for nn:= 1 to MaxNumPks do with ML_Setup^^ do begin            	number_of_derivs_Window[nn] := 0;			    	First_Deriv[nn] := 0;				Last_deriv[nn] := 0;				DoFirst[nn] := false;;				DoSecond[nn] := false;			  end;              found := true; { until new z/family supplied; in case we put in some info and then cleared}		      done := ML_Setup^^.number_of_refs + 1;{ so we can't get into the old d loop}		  END;	{ IF (itemHit = I_Clear_Derivatives)...}          IF (itemHit = I_EleInput) THEN            BEGIN			  			  found := true; {don't get to the line info text stuff til the input complete}			  GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect); 			  GetDialogItemText(DItem, sTemp); {Get the text entered}			  {if the 1st char is not a letter delete it}				if ((ord(sTemp[1]) < 65) or					((ord(sTemp[1]) >90) and (ord(sTemp[1]) < 97)) or					 (ord(sTemp[1]) >122)) then Delete(sTemp, 1, 1);				if length(sTemp) = 2 then				  {delete the 2nd char if not a letter or space:}					   if (((ord(sTemp[2]) < 65)  and (ord(sTemp[2]) <>32)) or					   ((ord(sTemp[2]) >90) and (ord(sTemp[2]) < 97)) or						(ord(sTemp[2]) >122)) then Delete(sTemp, 1, 2); 				if length(sTemp) = 3 then begin				  {delete the 3rd char if not a letter...maybe they'll type another char}					   if ((ord(sTemp[3]) < 65) or					   ((ord(sTemp[3]) >90) and (ord(sTemp[3]) < 97)) or					   (ord(sTemp[3]) >122)) then Delete(sTemp, 1, 3)				   else begin					 IF ((ord(sTemp[3]) > 96) AND (ord(sTemp[3]) < 122))  THEN				         sTemp[3] := char(ord(sTemp[3]) - 32);	{ make it upper case }					 IF ((sTemp[3] = 'K') or (sTemp[3] = 'L') or (sTemp[3] = 'M'))                     then begin					 	Zinput := concat(sTemp[1], sTemp[2]);{hopefully str8 is now an atomic symbol}						GetDialogItem(GetSelection, I_Accept, DType, DTempItem, tempRect); 						HiliteControl(controlhandle(DTempItem), 0);	{turn it on}					    found := False;{ so we match the z/family to elements requested }					    index := 0;	                    str5 := concat(sTemp, ' is not one of the families you selected.');					 end;			       end;	{if ((ord(sTemp[3])...else begin...}				end;	{if length(sTemp) = 3...}				SetDialogItemText(DItem, sTemp);            END;	{ IF (itemHit = I_EleInput)...}				          IF (itemHit = I_2ND_DERIVATIVE) THEN            BEGIN              temp1 := GetControlValue(CItem);               SetControlValue(CItem, (temp1 + 1) MOD 2);               END; {End for this item selected}          IF (itemHit = I_1ST_DERIVATIVE) THEN              BEGIN              temp := GetControlValue(CItem);               SetControlValue(CItem, (temp + 1) MOD 2);              END; {End for this item selected}        UNTIL (accept); {Handle dialog items until accept or exit selected}        {Get results after each accept and reset booleans}        IF (itemHit = I_Accept) THEN         BEGIN		 GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect); 		 GetDialogItemText(DItem, sTemp); {Get the text entered}		 IF (length(sTemp) = 3) Then		 Begin		 { for new derivatives or ones from ML_setup}		 {index is either defined because we are going thru the elements with		  derivative info in ML_Setup or because we found a ref for the family input}		  found := false; {this MUST be here to look for OTHER refs for a z/family}		  			 GetDialogItem(GetSelection, I_1ST_DERIVATIVE, DType, DItem, tempRect); 			 CItem := controlhandle(DItem); 			 temp := GetControlValue(CItem); 			 SetControlValue(CItem, 0); {reset to 0}			 IF (temp = 0) THEN ML_Setup^^.DoFirst[index] := False			 ELSE			 IF ((numinwin[nw] < Max_Num_Terms) AND 				 (totalrefs < Max_Num_References)) THEN			 BEGIN			   numinwin[nw] := numinwin[nw] + 1;	{this is a local variable}			   ML_Setup^^.DoFirst[index] := True;			   totalrefs := totalrefs + 1;			 END;			 GetDialogItem(GetSelection, I_2nd_DERIVATIVE, DType, DItem, tempRect); 			 CItem := controlhandle(DItem); 			 temp1 := GetControlValue(CItem); 			 SetControlValue(CItem, 0); {reset to 0}			 IF (temp1 = 0) THEN ML_Setup^^.DoSecond[index] := False			 ELSE			 IF ((numinwin[nw] < Max_Num_Terms) AND 				 (totalrefs < Max_Num_References)) THEN			 BEGIN			   numinwin[nw] := numinwin[nw] + 1;			   ML_Setup^^.DoSecond[index] := True;			   totalrefs := totalrefs + 1;			 END; {if... (totalrefs <Max_Num_terms)...}				 			 str3 :=concat('');			 GetDialogItem(GetSelection, I_Lines, DType, DItem, tempRect); 			 SetDialogItemText(DItem, ''); {set the text entered}			 			 GetDialogItem(GetSelection, I_EleInput, DType, DItem, tempRect); 			 SetDialogItemText(DItem,''); {set the text entered}		   		     IF (totalrefs = Max_Num_References) THEN	{disable derivative stuff}			 BEGIN			   GetDialogItem(GetSelection, I_1ST_DERIVATIVE, DType, DItem, tempRect); 			   HiliteControl(controlhandle(DItem), 255);			   GetDialogItem(GetSelection, I_2ND_DERIVATIVE, DType, DItem, tempRect); 			   HiliteControl(controlhandle(DItem), 255);			 END;		  End 	{ If (length(sTemp) = 3)...}		  Else Putmessage('The last entry was incomplete so','no derivative info was saved',		  				  '','');		 END; { if (ItemHit =I_accept) ...}      UNTIL ExitDialog;		tempRect := GetSelection^.portRect;		DisposeDialog(GetSelection);		FillWhiteSpace(tempRect);    END; {End of procedure D_DoDerivs}  {=================================}         PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Do_Fit, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN {procedure D_ML_Dial}      GetSelection := GetNewDialog(2828, NIL, Pointer( - 1));	  CenterDialog(GetSelection,TRUE,whre);      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);            Refresh_Dialog;      ExitDialog := False;	  savesetup := false;      refs_sel := true;	  only_setup := true; {remains true if only Output_Options and/or Save_setup were hit}      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);		        IF (itemHit = I_Do_Fit) THEN	{accept button}          BEGIN		    IF only_setup then ExitDialog := True			    {true if ONLY Output_Options and/or Save_setup were hit}		    ELSE IF (not refs_sel) then			     PutMessage('You forgot to pick references', 'Please do that now.', '', '')            ELSE BEGIN                ExitDialog := True;                SetUp_All_Refs; { derivatives taken and some analysis_result stuff set here }               (* Fit_Invisibly := False;                Results_Added := False;		...these are set in Do_a_fit and Auto_Run *)				WITH Analysis_result^^, Fit_params, Fit_Result,Plt_spec[10]^^.Expt_Info DO				BEGIN				    Fit_Procedure := 'ML';					Number_of_Windows := ML_Setup^^.number_of_MLwindows;	 				For nwindows := 1 TO Number_of_Windows do begin					 {calibrated energies...}					   Fitting_Roi_Lo[nwindows] := ML_Setup^^.ML_LoeV[nwindows]/1000;					   Fitting_Roi_Hi[nwindows] := ML_Setup^^.ML_HieV[nwindows]/1000;					end;					 {calibrated energies...}				   ROI^^.Quant.Lo := rinttol((ML_Setup^^.BkgLo * energy_slope + energy_intercept) / dE);				   ROI^^.Quant.Hi := rinttol((ML_Setup^^.BkgHi * energy_slope + energy_intercept) / dE);			   END; { WITH Analysis_Result^^... }			   if Hall_active then ROI^^.Quant.Exists := True;		  	  Simplex_active := False;              LLSQ_active := True;			                {Hall_Active := False; ...set if elements selected}			END;	{ ELSE BEGIN }          END;        IF (itemHit = I_Get_Setup_File) THEN          BEGIN	        only_setup := False;            Use_setup_file := True;            Elements_Chosen := False;            refs_sel := False;            mytype := 'MCAl';            myprompt := 'Get ML Setup File';     { The setup saves the derivative info but you may want to change this       even tho everything else stays the same, so we leave derivative input       highlighted.}            IF (GetFileName(RefName, mytype, mytype, myprompt)) THEN              BEGIN                errCode := FSOpen_err(RefName, In_VolRefNum, refnum, 'in ItemHit =I_Get_Setup_File');                IF (errCode = NoErr) THEN                  BEGIN                    errCode := SetFPos_err(refnum, fsFromStart, 0,'');                    bytecount := sizeof(ML_Stuff);                    errCode := FSRead(refnum, bytecount, @ML_Setup^^);                    bytecount := sizeof(thefileinfo);                    errCode := FSRead(refnum, bytecount, @My_File_Info);                    bytecount := sizeof(PKARRAY);                    errCode := FSRead(refnum, bytecount, @lo_line);                    errCode := FSRead(refnum, bytecount, @hi_line);                    IF (errCode = NoErr) THEN with Plt_spec[10]^^.Expt_Info DO                      BEGIN                      (*  ROI^^.PEAK[1].Exists := True;*)                        GetDialogItem(GetSelection, I_Select_Elements, DType, DItem, tempRect);                         HiliteControl(controlhandle(DItem), 255);        (*GetDialogItem(GetSelection,I_Select_Derivatives,DType,DItem,tempRect);         CItem := Pointer(DItem);          HiliteControl(CItem, 255);*)                        GetDialogItem(GetSelection, I_Get_References, DType, DItem, tempRect);                         HiliteControl(controlhandle(DItem), 255);                        ROI^^.Quant.Lo := rinttol((ML_Setup^^.BkgLo * energy_slope + energy_intercept) / dE);                        ROI^^.Quant.Hi := rinttol((ML_Setup^^.BkgHi * energy_slope + energy_intercept) / dE);						if Hall_active then ROI^^.Quant.Exists := True;                        Elements_Chosen := True;                        D_GetRefs; { this sets refs_sel to true if all are found, defines window						             hi and lo ev energies }                      END; { IF (errcode = noerr)...}					  errCode := FSClose(refnum);					  errCode := FlushVol(NIL, In_VolRefNum);                  END {IF (errcode = NoErr)...}				  ELSE putmessage('Sorry, the setup file did not open.','','','');              END; { IF (GetFileName...}            Refresh_Dialog;			Refresh_ROIs;          END; { if (ItemHit ...I_Get_Setup_File}        IF (itemHit = I_Get_References) THEN          BEGIN	        only_setup := False;            refs_sel := False;		    IF (ML_Setup^^.number_of_refs <1) THEN              PutMessage('You have not chosen any elements to fit.', 'Please do that first.', '', '')            ELSE  begin				D_GetRefs; {this sets refs_sel to true if all are found}				end;            Refresh_Dialog;          END;        IF (itemHit = I_Select_Derivatives) THEN          BEGIN	        only_setup := False;		    IF (ML_Setup^^.number_of_refs <1) THEN			   putmessage('Please select the elements first.','','','')            ELSE IF (ML_Setup^^.number_of_refs < Max_Num_References) THEN              BEGIN                D_DoDerivs;              END;            Refresh_Dialog;          END;          IF (itemHit = I_Select_Elements) THEN { making new ML_Setup^^ }          BEGIN	        only_setup := False;            refs_sel := False;{``````}			             IF ROI^^.PEAK[1].Exists = False THEN {give option to use auto roi or exit}             BEGIN                BeepBeep;                if (AnswerMessage('There are no PEAK ROIS to indicate peak bundles to be fit!',								 'If IT`S OK I`ll go to AUTO ROI; if not, set up ROIS in the ROI window.',						   		 '   {Use QUANT ROI to select your background for ratios of peak areas',								 '     to a chosen background. The default is 1.35 to 1.45 keV.}'))				then begin					Use_Manual_ROIs := false;					AutoROI_Chooser;				end				else  begin				  tempRect := GetSelection^.portRect;				  DisposeDialog(GetSelection);				  FillWhiteSpace(tempRect);				  exit(D_ML_Dial);				end;             END	{ Exists = False...}		     ELSE{``````}	 BEGIN	{rois are setup: Use_Manual_ROIs set in routine used }		                beepbeep;beepbeep;{9/20/95}	(*Use_Manual_ROIs := true;	{this is a boolean for AutoROI_Chooser so right			  							 instruction appears in the periodic table...}			  set this true only in SiLiWin if manual used *)			  AutoROI_Chooser;		     END; {else} 			  Kill_Quants;			  Refresh_ROIs;			{``````}						              Use_setup_file := False;            ML_Setup^^.number_of_MLwindows := Number_of_PeakRois - 1;				if ((ROI^^.Quant.Exists) and			   ((ROI^^.Quant.Hi > 80) and (ROI^^.Quant.Hi < 1024)) and			   (ROI^^.Quant.Lo < ROI^^.Quant.Hi))			then with Plt_Spec[10]^^,Expt_Info do begin			   ML_Setup^^.BkgLo := (ROI^^.Quant.Lo * dE - energy_intercept)/energy_slope;			   ML_Setup^^.BkgHi := (ROI^^.Quant.Hi * dE - energy_intercept)/energy_slope;			end			else with Plt_Spec[10]^^,Expt_Info do begin			   ML_Setup^^.BkgLo := 1450.0;			   ML_Setup^^.BkgHi := 1540.0;			   ROI^^.Quant.Lo := rinttol((1450 * energy_slope + energy_intercept) / dE);			   ROI^^.Quant.Hi := rinttol((1540 * energy_slope + energy_intercept) / dE);			   if Hall_active then ROI^^.Quant.Exists := True;			end;{``````} (*!  if Use_Manual_ROIs then D_Simplex_Elements;  {gets set of z chosen}*)             Sort_The_elements;						Hall_active := false;            IF (ML_Setup^^.number_of_refs < 1) THEN ExitDialog := True;            IF (ML_Setup^^.number_of_refs = Max_Num_References) THEN              BEGIN                GetDialogItem(GetSelection, I_Select_Derivatives, DType, DItem, tempRect);                 HiliteControl(controlhandle(DItem), 255);                PutMessage(' The elements you have selected require all', 				           ' the allowed fitting distributions.',                           ' Sorry, you will have to skip derivatives.', '');              END;			  {clear out current derivative info}		      ML_Setup^^.number_of_derivs := 0;			  for index:= 1 to MaxNumPks do with ML_Setup^^ do begin            	number_of_derivs_Window[index] := 0;			    	First_Deriv[index] := 0;				Last_deriv[index] := 0;				DoFirst[index] := false;;				DoSecond[index] := false;			  end;			Refresh_Dialog;          END;		{ I_Select_elements }        IF (itemHit = I_Cancel) THEN          BEGIN            ExitDialog := True;          END;        IF (itemHit = I_FlowChart) THEN          BEGIN            Flow_Chart(435);			Refresh_Dialog;		   END;        IF (itemHit = I_Help) THEN          BEGIN            LLSQ_Help;			Refresh_Dialog;		   END;        IF (itemHit = I_Choose_Output_Options) THEN          BEGIN		  	binary_choice := true;            D_Results_Options;            Refresh_Dialog;          END;        IF (itemHit = I_Save_Setup) THEN          BEGIN		    {If this were the first button hit in the dialog, refs_sel is true!}            IF (NOT refs_sel) THEN              PutMessage('Have you chosen elements, references and derivatives?', 			             'Please do that first.', '', '')            ELSE              BEGIN                RefName := 'ML_Setup.Sav'; { the user's choice replaces this }                if (CreateFile(RefName, 'Make ML_Setup File:') = True) OR 				      (File_Cancel_Button = False) then;                IF (File_Cancel_Button) THEN                  BEGIN                    errCode := Create(RefName, Out_VolRefNum, 'DTSA', 'MCAl');					IF  errCode = dupFNErr then					 BEGIN {¥¥¥ If we dont delete a previously named file we get into big trouble }					  errCode := FSDelete(RefName, Out_VolRefNum);					 END;	  					errCode := Create(RefName, Out_VolRefNum, 'DTSA', 'MCAl');					savesetup:=true;                  END; {IF (File_Cancel_Button)...}			   {  tempRect := GetSelection^.portRect;				  DisposeDialog(GetSelection);				  FillWhiteSpace(tempRect); }                Refresh_Dialog;              END; {ELSE...}          END; {if (ItemHit...}      UNTIL ExitDialog;	  		tempRect := GetSelection^.portRect;		DisposeDialog(GetSelection);		FillWhiteSpace(tempRect);		if ((itemhit<>I_Cancel) and (savesetup)) then begin                    errCode := FSOpen_err(RefName, Out_VolRefNum, refnum,										 'in ItemHit = I_Save_Setup ');                    IF errCode = NoErr THEN                      BEGIN                        errCode := SetFPos_err(refnum, fsFromStart, 0,'');                        bytecount := sizeof(ML_Stuff);                        errCode := FSWrite_err(refnum, bytecount, @ML_Setup^^,'');						bytecount := sizeof(theFileInfo);						errcode := FSWrite_err(refnum,bytecount,@My_File_Info,'');						bytecount := sizeof(PKARRAY);						errCode := FSWrite(refnum, bytecount, @lo_line);						errCode := FSWrite(refnum, bytecount, @hi_line);                        errCode := FSClose(refnum);                        errCode := FlushVol(NIL, Out_VolRefNum);                      END                    ELSE PutMessage('The setup file to save did not open.', '', '', '');		end;      Refresh_ROIs;      Update_Full;	       END;  PROCEDURE Do_LLS_Fit;	{ this procedure is called in SiLi_window,Menus and Quant routines }    VAR      alist                         : LinFitIntArray;      (*covar, wcovar                 : LinFitCovArray;*)      keV_per_Channel,                                { energy per channelin kev }       fwhmw, ediff, energy, Local_Bkg: Real;      Window_Counter, n, index, Ch1, Chn{, ncvm}, nrd, index1, 	  Index2, index3, ele, np,First_Ref_Channel,Last_Ref_Channel,       First_Fit_Channel, Filter_Width, Window_plus_filter, 	   NumChs_in_Window						: integer;	   totalrefs, chans_to_do, order		: longint;      std, see, wstd                :  real {double_t};      solution, wsolution           : LinFitExtArray;      hold                          : ARRAY [1..5] OF real {double_t};	 	      BEGIN { Do_LLS_Fit }		IF (WDS_Active) and 	   (Plt_Spec[10]^^.Expt_Info.Detector.Spec = EDS ) THEN  	BEGIN	 putmessage('The program is configured for WDS but the spectrum is EDS. Please',				'check out the conflict and start over.',				'Be sure the eV/Channel and the detector resolution are sensible for your spectrum.',				'');	 exit(Do_LLS_Fit);		  	END	ELSE	IF (Si_Active) and	   (Plt_Spec[10]^^.Expt_Info.Detector.Spec = WDS ) THEN  	BEGIN	 putmessage('The program is configured for EDS but the spectrum is WDS. Please',				'check out the conflict and start over.',				'Be sure the eV/Channel and the detector resolution are sensible for your spectrum.',				'');	 exit(Do_LLS_Fit);		  	END;	 { Test_a_Handle(Handle(Weight),'Weight, in Do_LLS_Fit');}      Weight := WindowArrayHdl(NewHandle(sizeof(WindowArray)));	  if Weight = NIL then begin	  		putmessage('not enough room in the heap zone for Weight','','','');			exit(Do_LLS_Fit);			end;	 { Test_a_Handle(Handle(YData),'YData, in Do_LLS_Fit');	}	      YData := WindowArrayHdl(NewHandle(sizeof(WindowArray)));	  if YData = NIL then begin	  	    putmessage('not enough room in the heap zone for YData','','','');	        H_UnLock_Dispose(Handle(Weight),'Weight xx'); 			exit(Do_LLS_Fit);			end;	 { Test_a_Handle(Handle(Win[1]),'Win[1], in Do_LLS_Fit');}	      Win[1] := WindowArrayHdl(NewHandle(sizeof(WindowArray)));	  if Win[1] = NIL then begin  	  	    putmessage('not enough room in the heap zone for Win[1]','','','');	        H_UnLock_Dispose(Handle(Weight),'Weight xx'); 	        H_UnLock_Dispose(Handle(YData),'YData xx'); 			exit(Do_LLS_Fit);			end;	  MoveHHi(Handle(Weight));	  MoveHHi(Handle(YData));	  MoveHHi(Handle(Win[1]));	  If MemError<>noerr then begin	  	putmessage('err in MoveHHi','','','');	        H_UnLock_Dispose(Handle(Weight),'Weight xx'); 	        H_UnLock_Dispose(Handle(YData),'YData xx'); 	        H_UnLock_Dispose(Handle(Win[1]),'Win[1] xx'); 		exit(Do_LLS_Fit);		end;      HLock(Handle(Weight));      HLock(Handle(YData));      HLock(Handle(Win[1]));      GetDateTime(Start_Time);      The_Time := Start_Time;	  	        abort_x := False; { For the cntrl-c exit  test logic }      tocnts := Zero;	  	         For index := 1 to Maximum_Channels do Col_1^[index] := 0.0;	   		if Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted then			blockmove(@Plt_spec[10]^^.S,@col_1^,sizeof(Plt_spec[10]^^.s))        Else READ_SPECTRUM; { counts to col_1^. Remove escapes. · cnts in spectrum..not used.}       	  BlockMove(@col_1^, @col_5^, Sizeof(col_5^));	  ROI^^.Quant.Value := 0.0;	{ to get value with no escape peak contribution }	  For index := ROI^^.Quant.Lo to ROI^^.Quant.Hi do	               ROI^^.Quant.Value := ROI^^.Quant.Value + col_5^[index];      keV_per_Channel := Plt_Spec[10]^^.Expt_Info.dE * 0.001;         { ch calibration in kev/ch}      { these need to be here if using DO FIT }	  Analysis_result^^.ExptStuff := Plt_Spec[10]^^.Expt_Info;        { Initialize and/or assign any }      Analysis_result^^.SpectrumStuff := Plt_Spec[10]^^.SpectrumStuff;{ required fields }	  WITH Analysis_result^^, ExptStuff, Fit_params, Fit_Result DO		BEGIN		  Fit_Procedure := 'ML';		{ if there is no roi quant when LLS is set up the default ch135 to 145 is defined		  and therefore when each spectrum is read in ROI^^.Quant.Value is calculated above.		  These are calibrated energies...}          		  Chosen_ROI_Lo := (ROI^^.Quant.Lo * dE - energy_intercept)/energy_slope;		  Chosen_ROI_Hi := (ROI^^.Quant.Hi * dE - energy_intercept)/energy_slope;		  Chosen_Norm_Bkg := ROI^^.Quant.Value / (ROI^^.Quant.Hi - ROI^^.Quant.Lo + 1);	  END; { WITH...}	  BlockMove(@Plt_spec[10]^^,@Plt_spec[9]^^,SizeOf(Plt_spec[10]^^));	{¥¥¥2/7/96¥¥¥} 	  	  BlockMove(@col_5^, @Plt_Spec[1]^^.S, Sizeof(col_5^)); {data}      BlockMove(@col_5^, @Plt_Spec[9]^^.S, Sizeof(col_5^)); {data}	        WITH ML_setup^^ do BEGIN FOR Window_Counter := 1 TO analysis_result^^.fit_params.number_of_windows DO BEGIN {FOR Window_Counter...}      ediff := (ML_HieV[Window_Counter] + ML_LoeV[Window_Counter]) / 2 - 5895.0;	  IF Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then	  BEGIN 		 analysis_result^^.fit_result.FWHM_Mn[Window_Counter] :=						  Plt_Spec[10]^^.Expt_Info.Si_Resolution;  	     fwhmw := Plt_Spec[10]^^.Expt_Info.Si_Resolution;		 IF Ge_Active THEN  		   fwhmw := SQRT(ediff * 2.5 + fwhmw * fwhmw){this formula will change}  		 ELSE  		   fwhmw := SQRT(ediff * 2.5 + fwhmw * fwhmw);  	  END	  ELSE IF Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then	  BEGIN 		  analysis_result^^.fit_result.FWHM_Mn[Window_Counter] := 						  Plt_Spec[10]^^.Expt_Info.WDS_Resolution;	      fwhmw := Two_Coeff * Plt_Spec[10]^^.Expt_Info.WDS_Resolution;  	  END;			 					 	 analysis_result^^.fit_result.iterations[Window_Counter] := 1;	 For index := 1 to Maximum_Channels do col_6^[index] := zero;			   FOR index := 1 TO Max_Num_Terms DO	BEGIN	  solution[index] := 0.0; { double_t variables }	  alist[index] := 0;	END; {for index := 1...}	{ define the two unit local variables...these are in spectrum space cause that's where	  we have to fit... }	  First_Ref_Channel := rinttol((ML_LoeV[Window_Counter] * Plt_Spec[10]^^.Expt_Info.energy_slope +								  Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE);	  Last_Ref_Channel := rinttol((ML_HieV[Window_Counter] * Plt_Spec[10]^^.Expt_Info.energy_slope +								 Plt_Spec[10]^^.Expt_Info.energy_intercept)/ Plt_Spec[10]^^.Expt_Info.dE);	  NumChs_in_Window := Last_Ref_Channel - First_Ref_Channel + 1;			  nrd := 2 * rinttol(fwhmw /           (Plt_Spec[10]^^.Expt_Info.dE * 2)); { (even) # chs in cntr lobe for window }  Filter_Width := 2 * nrd; { # chs in filter for the window }  Window_plus_filter := NumChs_in_Window + Filter_Width;  First_Fit_Channel := First_Ref_Channel + nrd;  std := 0.0; {double_t }  index1 := 0; { this increments to # of refs + # of Derivs in window, ie number				  of distributions for LLSQ to fit}  FOR index := ML_Setup^^.First_Ref[Window_Counter] TO ML_Setup^^.Last_Ref[Window_Counter] DOIF ML_Setup^^. RefIndex[index] > 0 THENBEGIN {for index := First_Ref...# in set of sorted family distributions, no D's}	  index1 := index1 + 1;	 solution[index1] := 0.0; { Max_Num_Terms, double_t }	 alist[index1] := index1;	{ Test_a_Handle(Handle(Xdata[index1]),'Xdata[index1], in Do_LLS_Fit');}	 Xdata[index1] := WindowArrayHdl(NewHandle(sizeof(WindowArray)));	 if Xdata[index1] = NIL then begin 		   putmessage('not enough room in the heap zone for Xdata[index1]','','','');	        H_UnLock_Dispose(Handle(Weight),'Weight xx'); 	        H_UnLock_Dispose(Handle(YData),'YData xx'); 	        H_UnLock_Dispose(Handle(Win[1]),'Win[1] xx');			for index1 := 1 to index - 1 do						   H_UnLock_Dispose(Handle(XData[index1]),'XData xx');		   exit(Do_LLS_Fit);		   end;	  FOR n := 1 TO max_fitting_chans DO Xdata[index1]^^[n] := 0.0;	  FOR n := 1 TO NumChs_in_Window DO Xdata[index1]^^[n] := reference[index]^^.data[n];		  	  MoveHHi(Handle(Xdata[index1]));	  HLock(Handle(Xdata[index1]));END; {for index := First_Ref[Window_Counter]...IF ML_Setup^^. RefIndex[index] > 0...}  {The derivative booleans were set false for any ref skipped ie RefIndex[index] <= 0 }IF (ML_Setup^^.First_Deriv[Window_Counter] > 0) THENFOR index := ML_Setup^^.First_Deriv[Window_Counter] TO ML_Setup^^.Last_deriv[Window_Counter] DO	 {index = number_of_refs + 1 for Window 1, for Last window last index = Number_of_peaks}  	   BEGIN		 index1 := index1 + 1;		{ Test_a_Handle(Handle(Xdata[index1]),'Xdata[index1], in Do_LLS_Fit');} 	   Xdata[index1] := WindowArrayHdl(NewHandle(sizeof(WindowArray)));	   if Xdata[index1] = NIL then begin 			 putmessage('not enough room in the heap zone for Xdata[index1]','','','');	        H_UnLock_Dispose(Handle(Weight),'Weight xx'); 	        H_UnLock_Dispose(Handle(YData),'YData xx'); 	        H_UnLock_Dispose(Handle(Win[1]),'Win[1] xx');			chn := index1 - 1;			for index1 := 1 to chn do						   H_UnLock_Dispose(Handle(XData[index1]),'XData xx');			 exit(Do_LLS_Fit);			 end;	 	  FOR Chn := 1 TO max_fitting_chans DO Xdata[index1]^^[Chn] := 0.0;	  FOR Chn := 1 TO NumChs_in_Window DO  Xdata[index1]^^[Chn] := reference[index]^^.data[Chn];	   MoveHHi(Handle(Xdata[index1]));	   HLock(Handle(Xdata[index1]));		 		 solution[index1] := 0.0; { Max_Num_Terms}		 alist[index1] := index1;END; {IF (ML_Setup^^.First_Deriv...FOR index := First_Deriv[Window_Counter] ... }totalrefs := index1;{Now set up for LLS_Fit }		 FOR Chn := 1 TO max_fitting_chans DO		   BEGIN			 YData^^[Chn] := 0.0;  { double_t }			 Win[1]^^[Chn] := 0.0; { double_t }			 Weight^^[Chn] := 0.0; { double_t }		   END;		 		 Ch1 := First_Ref_Channel - 1;	{1st ch less 1 to get spectrum data from}		 FOR Chn := 1 TO NumChs_in_Window  DO 		   Win[1]^^[Chn] := col_5^[Ch1 + Chn];	{copy original data for filtering }			{ See p 550 in Numerical Recipes. Uncertainty in each filtered value is sqrt·(uncertainty**2)  from all chs contributing to it, ie the uncertainty for each ch is the sqrt of the counts.  XiSq should be weighted by the uncertainty at each pt. These should be normally distributed;  ours are Poisson. This is ok for large number of counts but not otherwise.  The result is that our ChiSq values often will be << 1. The  diagonal elements of the covariance matrix are the sqrd uncertainties of the  fitted parameters. The method of LstSqs is subject to roundoff error.    BUT the first ch of Win[1]^^ that is actually fit is nrd + 1. SOOO...it is probably  safer to calculate weight in a separate loop using Win[1].  There is a fundamental problem here: the method assumes that the uncertainties  in the values being fit and the values are independent; our uncertainties are not and  values are not because of the TopHat. The error at each ch in the filtered data is   sqrt(cnts in the ch) so that we get from propagation of errors, the error or stdev  of each ch in the filtered data being fit = sqrt(· (cnts in the ch))  where the sum is over chs in tophat filter). Win[1]^^[1]...Win[1]^^[?] is original data}         For Chn := 1 to NumChs_in_Window - Filter_Width do begin		   for n := chn to chn + Filter_Width do {...over one ch more than Filter_Width}		          weight^^[chn] := weight^^[chn] + abs(Win[1]^^[n]);{sum of sqs of uncertainty}	(*  	weight^^[chn] := weight^^[chn] - abs(Win[1]^^[Chn + nrd]);	{???subtract the filter ch value}						    weight^^[chn] := sqrt(weight^^[chn]/Filter_Width);{...Lfit wants sig not variance}      { ¥¥¥¥¥???  why divide by Filter_Width???  No div in propagation of errors¥¥¥¥¥}    *)			weight^^[chn] := sqrt(weight^^[chn]);{Lfit wants sig not variance}			if weight^^[chn] < 1 then weight^^[chn] := 1e12;			if weight^^[chn] < 1 then beepbeep;			{...LFIT goes apeshit if weight gets near or < 0.0...it never should! } 		   end;		                                                   { the first (NumChs_in_Window - Filter_Width) in YData^^ get digitally filtered data  for the window }		atophat(Win[1]^^, YData^^, NumChs_in_Window, Filter_Width);			 { the first (NumChs_in_Window - Filter_Width) in Xdata[index]^^ 	   get digitally filtered refs for the window } 	  FOR index := 1 TO totalrefs DO begin        FOR Chn := 1 TO max_fitting_chans DO Win[1]^^[chn] := 0.0;        FOR Chn := 1 TO NumChs_in_Window DO Win[1]^^[Chn] := xdata[index]^^[Chn];          atophat(Win[1]^^,  Xdata[index]^^, NumChs_in_Window, Filter_Width);		 	  end;		chans_to_do := NumChs_in_Window-Filter_Width;	 		  Lfit(YData, 			       Weight, 				   Xdata, 				   chans_to_do, 				   totalrefs, 				  { alist, }				   covar,	 				   solution, 				   std);		{  Lfit:		    sig2i := 1.0 / sqr(Weight^^[i]);			wt := Xdata[lista[j]] * sig2i;			covar[j, k] := wt * Xdata[lista[k]];			sum := solution[j] * XData[j]^^[i];			The following are calculated in Linfit...			chisq := chisq + sqr((YData^^[i] - sum)/sig^^[i]);			chisq := chisq / (NumChs_in_Window - totalrefs);				The Cii of the covariance matrix can only be interpreted			as the sqd uncertainties of the fitting parameters if measurement			errors are normally distributed. For LARGE number of counts, Poisson is			close enough. }              	  	  	   { if needed make more handles for WTFIT on residuals }              IF (totalrefs < 5)  THEN                BEGIN                  FOR index1 := totalrefs + 1 TO 5 DO                    BEGIN					  {  Test_a_Handle(Handle(Xdata[index1]),'Xdata[index1], in Do_LLS_Fit');}						Xdata[index1] := WindowArrayHdl(NewHandle(sizeof(WindowArray)));						if Xdata[index1] = NIL then begin 							  putmessage('not enough room in the heap zone for Xdata[index1]',							             '','','');							  H_UnLock_Dispose(Handle(Weight),'Weight xx'); 							  H_UnLock_Dispose(Handle(YData),'YData xx'); 							  H_UnLock_Dispose(Handle(Win[1]),'Win[1] xx');							  chn := index1 - 1;							  for index := 1 to chn do											 H_UnLock_Dispose(Handle(XData[index]),'XData xx');							  exit(Do_LLS_Fit);							  end;						MoveHHi(Handle(Xdata[index1]));						HLock(Handle(Xdata[index1]));					    FOR Chn := 1 TO max_fitting_chans DO Xdata[index1]^^[Chn] := 0.0;                    END; {for index1 :=...}                  totalrefs := 5;		{so we dispose of all the Xdata handles}                END; {if (totalrefs < 5 )...}{Remember that we are fitting and weighting using escape pk subtracted values not the spectrum.} 			                 { Put Residuals in RESULTS }			  blockmove(@col_5^,@Plt_Spec[2]^^.S,sizeof(Plt_Spec[2]^^.S));              Chn := First_Ref_Channel - 1;              energy := ML_LoeV[Window_Counter] / 1000.0 - keV_per_Channel;			   { col_6^[Chn] is zeroed after copying data from it }              FOR index := 1 TO NumChs_in_Window DO                BEGIN {for index}                  Chn := Chn + 1;                  index1 := 0; { counts over the fitting distributions for LLSQ }                  FOR Index2 := ML_Setup^^.First_Ref[Window_Counter] TO 				                ML_Setup^^.Last_Ref[Window_Counter] DO					IF ML_Setup^^. RefIndex[Index2] > 0 THEN					BEGIN {get the distribution for each family from the 					        number_of_peaks distributions}                       index1 := index1 + 1;				(*    Plt_Spec[2]^^.S[chn] := Plt_Spec[2]^^.S[chn] - solution[index1] *reference[Index2]^^.data[index];                *)    col_6^[Chn] := col_6^[Chn] + (solution[index1] * 					                                       reference[Index2]^^.data[index]);					END;{ remember, if we decided to skip a ref the derivative booleans are false and First_Deriv[Window_Counter] = 0 }			     IF (ML_Setup^^.First_Deriv[Window_Counter] > 0) THEN				 FOR Index2 := ML_Setup^^.First_Deriv[Window_Counter] TO 				               ML_Setup^^.Last_deriv[Window_Counter] DO					BEGIN	{ get the distribution for each derivative from the 					          number_of_peaks distributions} 					  index1 := index1 + 1;					  col_6^[Chn] := col_6^[Chn] + (solution[index1] * 														   reference[Index2]^^.data[index]);					(*  Plt_Spec[2]^^.S[chn] := Plt_Spec[2]^^.S[chn] - solution[index1] *reference[Index2]^^.data[index];				*)  END;                  Plt_Spec[9]^^.S[Chn] := col_5^[Chn] - col_6^[Chn];				  YData^^[index] := Plt_Spec[9]^^.S[Chn];		{residuals to fit}				  XData[1]^^[index] := 1; { energy**0 }				  energy := energy + keV_per_channel;(*!!*)			  FOR order := 2 TO 5 DO  						XData[order]^^[index] := XData[order-1]^^[index] * energy;				  if col_5^[Chn] >= 1 then									 Weight^^[index] := SQRT(col_5^[Chn])				  else Weight^^[index] := 1e12 { has to be BIG for big spectra } 				  { LFIT bombs if Weight goes to zero or negative }               END; {for index := 1 TO NumChs_in_Window...}			  UpDate_Max_Min(9);              see := 1e12; { double_t, has to be BIG for big spectra }              wstd := 0.0; {double_t }              FOR order := 2 TO 5 DO                 BEGIN  {FOR order...}                  FOR index := 1 TO order Do alist[index] := index;					chans_to_do := NumChs_in_Window;				  Lfit(YData,					   Weight,					   XData,					   chans_to_do, 					   order, 					   {alist,} 					   wcovar, 					   wsolution, 					   wstd);                  IF wstd < see { if this xisq better than previous best }                  THEN                      BEGIN                        see := wstd;                        				   index3 := order;                        FOR index := 1 TO index3 DO Hold[index] := wsolution[index];                      END;                            { if wstd }             END;      { for order...wsolution has fitting constants }			Chn := First_Ref_Channel-1;			energy := ML_LoeV[Window_Counter]/1000.0 - keV_per_channel;              FOR index := 1 TO NumChs_in_Window DO              BEGIN                                 {for index}				  Chn := Chn + 1;				  energy := energy + keV_per_channel;                  Plt_Spec[1]^^.S[Chn] := (Hold[1]);                  FOR index1 := 2 TO index3 DO                    Plt_Spec[1]^^.S[Chn] := (Hold[index1] * XData[index1]^^[index]) +											Plt_Spec[1]^^.S[Chn] ;              END;   {for index}              UpDate_Max_Min(1);			  	    FOR index := 1 TO totalrefs DO H_UnLock_Dispose(Handle(Xdata[index]),'Xdata[index] xx');                  	{ This eqn may be used with MA1_2 or LA1 substituted for KA1 in the Handle to get	  the ev:  Peak_Energy[index] := KA1_Handle^^.Data[atm_num].Lamda); }   WITH Analysis_result^^, SpectrumStuff, Spectrum_Info, Fit_Result, Fit_params DO  BEGIN		response[Window_Counter] := (std);	{(std = chisq)}			 { np counts for at#,siegbahn,area etc over whole fit}		np := analysis_result^^.fit_params.first_in_roi[Window_Counter] - 1;		index1 := 0; { increments within a window }		{ index2 gives the # of the distribution for the First_Deriv[Window_Counter]		  to the last; derivative distribtions number from the last peak distribution		  in the whole fit}		Index2 := ML_Setup^^.First_Deriv[Window_Counter] - 1;		index3 := ML_Setup^^.Number_of_refs_in_Window[Window_Counter];		FOR index := ML_Setup^^.First_Ref[Window_Counter] TO 		             ML_Setup^^.Last_Ref[Window_Counter] DO	   { remember that if a ref was not found Ref_Index = 0;	     if we skipped the line, Ref_Index = -1	     but the ref has an index so np MUST increment, but ONLY np.}		BEGIN            np := np + 1;	{counts over all refs and derivatives in whole fit that require			                 something for results files; no d's for skipped lines}			   IF Ref_Index[np] <= 0 THEN			   BEGIN			   {it was not included in the fit so index1 for solution does not increment}				 area[np] := zero;				 Err_or_Energy[np] := zero;				 Peak_to_Local_Bkg[np] := zero;				 Peak_to_Chosen_Bkg[np] := zero;;				 conc[np] := zero;				   END			   ELSE BEGIN                 index1 := index1 + 1;			        { Calculate the average background per ch in the ref region.}  				 Local_Bkg := zero;				 For Chn := First_Ref_Channel to Last_Ref_Channel do	(* 11/20/95			   Local_Bkg := Local_Bkg + Plt_Spec[1]^^.S[Chn]; { wtd fit to residuals }	*)           Local_Bkg := Local_Bkg + Plt_Spec[9]^^.S[Chn]; { residuals }				 Local_Bkg := Local_Bkg/NumChs_in_Window;				 				 area[np] := (reference[index]^^.area * solution[index1]);				 Err_or_Energy[np] := (SQRT(covar[index1, index1]) * reference[index]^^.area);				 Peak_to_Local_Bkg[np] := area[np] / Local_Bkg;{An error estimate for the local bkg could be obtained from the sum of the errors in each fitted term ie from the covar matrix. Not any more. The error in the P/LB could then obtained from the RMS error of errors in P and B.  These values could be stored in FWHM_Mn[np] since this has no other use in LLSQ fitting.} 			    Peak_to_Chosen_Bkg[np] := area[np] / Chosen_Norm_Bkg;(*8/28/96	    IF (This_is_a_Standard) THEN				BEGIN  *)				  ele := 0;				  REPEAT					ele := ele + 1;				  UNTIL (element_info[ele].Atomic_Number = Atomic_Number[np]) OR (ele =						number_of_elements);				  IF (element_info[ele].Atomic_Number = Atomic_Number[np]) THEN					conc[np] := element_info[ele].weight_fraction				  ELSE	conc[np] := zero;	(*				END				ELSE	conc[np] := zero;*)					  				IF (DoFirst[index]) THEN { false if skipped }				BEGIN				  np := np + 1;	{ number of distribution, ref or derivative,in whole fit}				  index3 := index3 + 1;	{counting distributions in LLSQ for window }				  Index2 := Index2 + 1; {# of derivative distribution in whole set of distributions}				  {MUST use num2real or the adjacent memory is trashed }				  area[np] := (reference[Index2]^^.area * solution[index3]);				  Err_or_Energy[np] :=				  	(SQRT(covar[index3, index3]) * reference[index]^^.area);				   Peak_to_Local_Bkg[np] := Zero;				   Peak_to_Chosen_Bkg[np] := Zero;				END; { If (DoFirst[index])...}				IF (DoSecond[index]) THEN { false if skipped }				BEGIN				  np := np + 1;				  index3 := index3 + 1;				  Index2 := Index2 + 1;				 {MUST use num2real or the adjacent memory is trashed }			      area[np] := (reference[Index2]^^.area * solution[index3]);				  Err_or_Energy[np] := (SQRT(covar[index3, index3]) *				  					   reference[Index2]^^.area);				  Peak_to_Local_Bkg[np] := Zero;				  Peak_to_Chosen_Bkg[np] := Zero;				END; { If (DoSecond[index])...}			  			  END;	{IF Ref_Index[index] <= 0...ELSE BEGIN ...}		  END; {for index := First_Ref[Window_Counter]...}		END; { WITH Analysis_Result^^...}	END; {for Window_Counter}END; { WITH ML_Setup^^ DO...}      { np increases through all the windows; it counts refs plus all derivatives} 	  H_UnLock_Dispose(Handle(YData),'YData in Do_LLS_Fit');  	  H_UnLock_Dispose(Handle(Weight),'Weight in Do_LLS_Fit');  	  H_UnLock_Dispose(Handle(Win[1]),'Win[1] in Do_LLS_Fit'); 	        Spectrum_Full[9] := True;      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);      Spectrum_Full[10] := True;      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);      Spectrum_Full[1] := True;      CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);             Linear_Display := True;	         UpDate_Max_Min(10);	  Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;	  Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts;	  Plt_Spec[1]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;	  Plt_Spec[1]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts; 	        Refresh_ROIs;      Update_Full;    END; {Do_LLS_Fit}  {=================================}END. {End of unit}