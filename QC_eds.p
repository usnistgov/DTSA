{*********************************} UNIT QC_eds;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Files, Memory, TextEdit,   Packages, StandardFile, Resources, PasLibIntf, fenv, fp, SegLoad, Retrace, Dialogs, Windows, Script, TextUtils, Finder, Controls, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Utilities,  SANDIA, Xray_Energies, BG_Correct, CurveFit, Simplexer, Linear_Least_Squares, SiLiWin, Calibrate, Tools, xray; PROCEDURE Setup_the_QC;PROCEDURE Run_the_QC;   {******************************} IMPLEMENTATION {**********************************}{$S QC1}(*TYPE	Q_Calib_Rec		=	  RECORD	  	Q_AtNum				: ARRAY [1..2] OF INTEGER;	  	Q_Line				: ARRAY [1..2] OF STRING[5];	  	Q_MeasE				: ARRAY [1..2] OF REAL;	  	Q_BookE				: ARRAY [1..2] OF REAL;	  	Q_Slope				: REAL;	  	Q_Intercept			: REAL;	  END;		Q_EBeam_Rec		=	  RECORD	  	Q_ApproxE			: REAL;	  	Q_FinalE			: REAL;	  	Q_Error				: REAL;	  END;	  	Q_Simplx_Rec	=	  RECORD	  	Q_NumROIs			: INTEGER;	  	Q_NumPeaks			: INTEGER;	  	Q_NumElements		: INTEGER;	  	Q_Z_Peak			: ARRAY [1..50] OF INTEGER;	  	Q_Li_Peak			: ARRAY [1..50] OF STRING[5];	  	Q_Area				: ARRAY [1..50] OF REAL;	  	Q_FWHM				: ARRAY [1..50] OF REAL;	  	Q_Mn_FWHM			: ARRAY [1..50] OF REAL;	  	Q_Energy			: ARRAY [1..50] OF REAL;	  	Q_ROI				: ARRAY [1..10] OF ROI_Data_Structure;	  	Q_First_in_ROI		: ARRAY [1..10] OF INTEGER;	  	Q_WtngInfo			: ARRAY [1..50] OF WtngInfo;	  	Q_Tolerance			: REAL;	  	Q_Stop				: INTEGER;	  END;	  	QC_Record			=	  RECORD	  	Q_Comments			: Str255;	  	Q_Date				: STRING[16];	  	Q_Current			: REAL;	  	Q_Time				: REAL;	  	Q_SprdSht_Spec		: FSSpec;	  	Q_Cal_Info			: Q_Calib_Rec;	  	Q_EBm_Info			: Q_EBeam_Rec;	  	Q_Simpx_Info		: Q_Simplx_Rec;	  END;	     QC_Ptr			= ^QC_Record;   QC_Hdl			= ^QC_Ptr;VAR   QC_Rec			: QC_Hdl;*)   VAR      QCSpec			: FSSpec;   bytecount		: Longint;     PROCEDURE Setup_the_QC;	{dialog ID = 138}    CONST      I_OK                          = 1;      I_Cancel                      = 2;      I_Setup_Calib                 = 5;      I_Select_Peaks                = 6;      I_Save_Setup                  = 7;      I_Beam_E						= 11;      I_Current						= 12;      I_Time						= 13;      I_SEM							= 14;      I_AEM							= 15;            VAR      ExitDialog, save_setup        : boolean;      tempRect                      : Rect;      DType                         : integer;      index, index1, indx           : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : Str255;      itemHit, num_pk               : integer;      temp, temp1, temp2            : integer;      str, str1						: Str255;      RQC							: DialogPtr;	  QC_reply						: StandardFileReply;	  ref_typ						: ARRAY [0..3] of OSType;	  sfPtr                       	: ConstSFTypeListPtr;	  temp_Z, refnum, errCode		: Integer;	  temp_label					: string[5];	  temp_E						: real;	  nxtROI						: integer;	  keepROI						: boolean;      Start                         : Point;            {This is an update routine for non-controls in the dialog}      {This is executed after the dialog is uncovered by an alert}        PROCEDURE Refresh_Dialog;            BEGIN        SetPort(RQC);        GetDialogItem(RQC, I_OK, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;  	BEGIN          RQC := GetNewDialog(138, NIL, Pointer( - 1));          CenterDialog(RQC, TRUE, Start);          ShowWindow(RQC);          SelectWindow(RQC);          SetPort(RQC);          	      GetDialogItem(RQC, I_AEM, DType, DItem, tempRect);	      SetControlValue(ControlHandle(DItem), 0);		  	      GetDialogItem(RQC, I_SEM, DType, DItem, tempRect);	      SetControlValue(ControlHandle(DItem), 1);          	      GetDialogItem(RQC, I_Beam_E, DType, DItem, tempRect);	      RealToString(Plt_spec[10]^^.Expt_Info.kV, 5, 2, str);	      SetDialogItemText(DItem, str);	      GetDialogItem(RQC, I_Current, DType, DItem, tempRect);	      RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday, 5, 2, str);	      SetDialogItemText(DItem, str);	      GetDialogItem(RQC, I_Time, DType, DItem, tempRect);	      RealToString(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time, 5, 2, str);	      SetDialogItemText(DItem, str);          Refresh_Dialog;          ExitDialog := False;          IF QC_Rec = NIL THEN BEGIN            Test_a_Handle(Handle(QC_Rec), 'QC_Rec');            QC_Rec := QC_Hdl(NewHandle(SizeOf(QC_Record)));            MoveHHi(Handle(QC_Rec));            HLock(Handle(QC_Rec));          END;                  QC_Enabled := true;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(RQC, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);                IF (itemHit = I_OK) THEN          BEGIN            ExitDialog := true;            save_setup := true;          END;                IF (itemHit = I_Cancel) THEN          BEGIN            ExitDialog := true;            save_setup := false;            QC_Enabled := false;          END;        IF (itemHit >= I_SEM) AND (itemHit <= I_AEM) THEN          BEGIN          	if(itemHit = I_SEM) then QC_SEM := true          	else QC_SEM := false;            FOR index := I_SEM TO I_AEM DO              BEGIN                GetDialogItem(RQC, index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;  	        IF (itemHit = I_Setup_Calib) THEN          BEGIN            {set up a calibration for the spectrum}            	Use_Manual_ROIs := false;				AutoROI_Chooser;				Refresh_ROIs;				Update_Full;				{Refresh_Dialog;}				Xray_Data_Request := true;				get_Energies(periodic_picks[1]);				if x_label[1] = 'MA1' then Low_Peak_Book := eV_Line[72]				else if x_label[1] = 'LA1  ' then Low_Peak_Book := (eV_Line[42] * Wt_Line[42] + eV_Line[43] * Wt_Line[43])/(Wt_Line[42] + Wt_Line[43])				else if x_label[1] = 'KA1  ' then Low_Peak_Book := (2.0 * eV_Line[1] + eV_Line[2])/3.0;				get_Energies(periodic_picks[2]);				if x_label[2] = 'KA1  ' then High_Peak_Book := (2.0 * eV_Line[1] + eV_Line[2])/3.0				else if x_label[2] = 'LA1  ' then High_Peak_Book := (eV_Line[42] * Wt_Line[42] + eV_Line[43] * Wt_Line[43])/(Wt_Line[42] + Wt_Line[43])				else if x_label[2] = 'MA1  ' then High_Peak_Book := eV_Line[72];				Number_of_PeakRois := 3;				Number_of_Elements_Simplexed := 2;				if Low_Peak_Book > High_Peak_Book then				  begin					temp_E := Low_Peak_Book;					Low_Peak_Book := High_Peak_Book;					High_Peak_Book := temp_E;					temp_Z := periodic_picks[1];					periodic_picks[1] := periodic_picks[2];					periodic_picks[2] := temp_Z;					temp_label := x_label[1];					x_label[1] := x_label[2];					x_label[2] := temp_label;				  end;			for indx := 1 to 2 do begin				QC_Rec^^.Q_Cal_Info.Q_AtNum[indx] := periodic_picks[indx];				QC_Rec^^.Q_Cal_Info.Q_Line[indx] := x_label[indx];			end;			QC_Rec^^.Q_Cal_Info.Q_BookE[1] := Low_Peak_Book;			QC_Rec^^.Q_Cal_Info.Q_BookE[2] := High_Peak_Book;			Xray_Data_Request := false;            Refresh_Dialog;          END;(*  TYPE    ROI_Data_Structure            =      RECORD        Lo                            : Integer;        Hi                            : Integer;        ROI                           : Integer;        value                         : real;        Exists                        : Boolean      END;*)        IF (itemHit = I_Select_Peaks) THEN          BEGIN            {select peaks for fitting}            QC_Enabled := false;            D_Simplex;            Simplex_Start;            temp2 := Number_of_PeakRois - 1;                        For index := temp2 downto 1 do begin            	If temp2 = index then nxtROI := Analysis_Result^^.Fit_params.Number_of_Peaks            	else nxtROI := Analysis_result^^.fit_Params.First_in_Roi[index + 1] - 1;            	keepROI := false;            	For indx := Analysis_result^^.fit_Params.First_in_Roi[index] to nxtROI do begin            		If (Analysis_Result^^.Fit_params.Siegbahn[indx] = 'KA1  ') OR            		   (Analysis_Result^^.Fit_params.Siegbahn[indx] = 'LA1  ') OR            		   (Analysis_Result^^.Fit_params.Siegbahn[indx] = 'MA1  ') then keepROI := true;            	end;            	If keepROI = false then begin            		If index = temp2 then begin            			Analysis_Result^^.Fit_params.Number_of_Peaks := nxtROI;            			temp2 := temp2 - 1;            			for indx := Analysis_result^^.fit_Params.First_in_Roi[index] to nxtROI do begin		                    PkAmpInfo[indx].wt := 0.0; { is 2.0 in data base }		                    PkAmpInfo[indx].master := 0;							PkAmpInfo[indx].sign := 0;            			end;            			ROI^^.Peak[index].Exists := false;						ROI^^.Peak[index].Lo := 1;						ROI^^.Peak[index].Hi := 1;						ROI^^.Peak[index].Value := zero;						ROI^^.Peak[index].ROI := index;						Number_of_PeakRois := Number_of_PeakRois - 1;            		end;            	end;            end;                        IF Analysis_Result^^.Fit_params.Number_of_Peaks > 50 then num_pk := 50            ELSE num_pk := Analysis_Result^^.Fit_params.Number_of_Peaks;            QC_Rec^^.Q_Simpx_Info.Q_NumPeaks := Analysis_Result^^.Fit_params.Number_of_Peaks;            QC_Rec^^.Q_Simpx_Info.Q_NumElements := Number_of_Elements_Simplexed;            IF temp2 > 10 then temp2 := 10;            For indx := 1 to temp2 DO Begin            	QC_Rec^^.Q_Simpx_Info.Q_ROI[indx] := ROI^^.PEAK[indx];            	QC_Rec^^.Q_Simpx_Info.Q_First_in_ROI[indx] := Analysis_result^^.fit_Params.First_in_Roi[indx];            End;            For indx := 1 to num_pk DO Begin                QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[indx] := Analysis_Result^^.Fit_params.Atomic_Number[indx];            	QC_Rec^^.Q_Simpx_Info.Q_Li_Peak[indx] := Analysis_Result^^.Fit_params.Siegbahn[indx];            	QC_Rec^^.Q_Simpx_Info.Q_WtngInfo[indx] := PkAmpInfo[indx];            	QC_Rec^^.Q_Simpx_Info.Q_Energy[indx] := Peak_Energy[indx];			End;            QC_Rec^^.Q_Simpx_Info.Q_Tolerance := Analysis_Result^^.Fit_params.Toler;            QC_Rec^^.Q_Simpx_Info.Q_NumROIs := temp2;            QC_Rec^^.Q_Simpx_Info.Q_Stop := Maximum_Iterations;            QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[1] := analysis_result^^.fit_params.FWStart;            QC_Enabled := true;            Refresh_Dialog;          END;        IF (itemHit = I_Save_Setup) THEN          BEGIN            {open a file to save the QC setup}            		  str := 'Save a QC Set-up';            		  str1 := 'QC Set-up';					  StandardPutFile(str, str1, QC_reply);		{¥¥New DTSA file spec¥¥}					  {if QC_reply.sfGood Then 					    QC_Rec^^.Q_SprdSht_Spec := QC_reply.sfFile;}					 Refresh_Dialog;          END;      UNTIL ExitDialog;            IF save_setup then BEGIN	      GetDialogItem(RQC, I_Beam_E, DType, DItem, tempRect);	      GetDialogItemText(DItem, sTemp);	      Plt_spec[10]^^.Expt_Info.kV := MyStr2Num(sTemp);	      QC_Rec^^.Q_EBm_Info.Q_ApproxE := Plt_spec[10]^^.Expt_Info.kV;	      GetDialogItem(RQC, I_Current, DType, DItem, tempRect);	      GetDialogItemText(DItem, sTemp);	      Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday := MyStr2Num(sTemp);	      Plt_spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday := MyStr2Num(sTemp);	      QC_Rec^^.Q_Current := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday;	      GetDialogItem(RQC, I_Time, DType, DItem, tempRect);	      GetDialogItemText(DItem, sTemp);	      Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time := MyStr2Num(sTemp);	      QC_Rec^^.Q_Time := Plt_spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;	      	      if QC_reply.sfGood Then begin	      	QCSpec := QC_reply.sfFile;	      	errCode := FSpCreate(QCSpec, 'DTSA', 'MCAq',smSystemScript);	      	errCode := FSpOpenDF(QCSpec, fsRdWrPerm, refNum);	      	bytecount := sizeof(QC_Record);	      	errCode := FSWrite_err(refNum, bytecount, @QC_Rec^^, 'QC_eds');	      	errCode := FSClose(refnum);	      	errCode := FlushVol(NIL, QCSpec.vRefnum);	      end;            END;	{IF save_setup}      tempRect := RQC^.portRect;      DisposeDialog(RQC);      FillWhiteSpace(tempRect);            H_UnLock_Dispose(Handle(QC_Rec), 'QC_Rec');      {QC_Rec := NIL;}  	  QC_Enabled := false;  	  Simplex_active := false;  	END;	{Setup_the_QC}  	  PROCEDURE Run_the_QC;	{dialog ID = 137}    CONST      I_OK                          = 1;      I_Cancel                      = 2;      I_Get_Setup                   = 6;      I_Old_File              		= 7;      I_New_File                  	= 8;      VAR      ExitDialog, save_setup, keepROI : boolean;      tempRect                      : Rect;      DType, RefsNum                : integer;      index, index1, indx, jj       : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : Str255;      itemHit, num_pk, nxtROI       : integer;      temp, temp1, temp2            : integer;      str, str1, str2, str3, str4, str5	: Str255;      RQC							: DialogPtr;	  QC_reply						: StandardFileReply;	  ref_typ						: ARRAY [0..3] of OSType;	  sfPtr                       	: ConstSFTypeListPtr;      errcode,refnum, ncvm			: integer;      SIG_SQ, Low_delta_e, High_delta_e	: real;      delta_e						: array [1..2] of real;      temp_E, temp_max, e_max		: real;	  solution                    	: LinFitExtArray; { [1..Max_Num_Terms] of double_t}	  Energy						: real {double_t};            lista                       	: LinFitIntArray;      covar                       	: LinFitCovArray;      Index2, order, len, theLint   : Longint;      std	                		: real {double_t};      Spr_Creat						: OsType;      Start                         : Point;      QC_Energy, QC_FWHM, QC_FWHMMn, QC_Area, QC_PkBG	: array [1..50] of real;      QC_Z							: array [1..50] of integer;      QC_Sieg						: array [1..50] of string[2];      {This is an update routine for non-controls in the dialog}      {This is executed after the dialog is uncovered by an alert}        PROCEDURE Refresh_Dialog;            BEGIN        SetPort(RQC);        GetDialogItem(RQC, I_OK, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;  	BEGIN          RQC := GetNewDialog(137, NIL, Pointer( - 1));          CenterDialog(RQC, TRUE, Start);          ShowWindow(RQC);          SelectWindow(RQC);          SetPort(RQC);                    Refresh_Dialog;          ExitDialog := False;          IF QC_Rec = NIL THEN BEGIN            Test_a_Handle(Handle(QC_Rec), 'QC_Rec');            QC_Rec := QC_Hdl(NewHandle(SizeOf(QC_Record)));            MoveHHi(Handle(QC_Rec));            HLock(Handle(QC_Rec));          END;		Spr_Creat := 'XCEL';		      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(RQC, itemHit, DType, DItem, tempRect);                IF (itemHit = I_OK) THEN          BEGIN            ExitDialog := true;            QC_running := true;          END;                IF (itemHit = I_Cancel) THEN          BEGIN            ExitDialog := true;            save_setup := false;            QC_running := false;          END;  	        IF (itemHit = I_Get_Setup) THEN          BEGIN            {open an old setup file for running}					  ref_typ[0] :=  'MCAq'; 					  sfPtr := @ref_typ;					  StandardGetFile(NIL, 1, sfPtr, QC_reply);						  if NOT QC_reply.sfGood Then exit(Run_the_QC);					    QCSpec := QC_reply.sfFile;					  errCode := FSpOpenDF(QCSpec, fsRdWrPerm, refnum);					  bytecount := sizeof(QC_Record);					  errCode := FSRead(refnum, bytecount, @QC_Rec^^);					  errCode := FSClose(refnum);					  Refresh_Dialog;          END;        IF (itemHit = I_Old_File) THEN          BEGIN            {open an old spreadsheet file for appending}			  ref_typ[0] :=  'TEXT'; 			  sfPtr := @ref_typ;			  StandardGetFile(NIL, 1, sfPtr, QC_reply);			  if QC_reply.sfGood Then 			  	QC_Rec^^.Q_SprdSht_Spec := QC_reply.sfFile;			  Refresh_Dialog;			  save_setup := true;          END;        IF (itemHit = I_New_File) THEN          BEGIN            {open a new spreadsheet file}    		  str := 'Select a Spreadsheet';    		  str1 := 'QC Results';			  StandardPutFile(str, str1, QC_reply);			  if QC_reply.sfGood Then 			    QC_Rec^^.Q_SprdSht_Spec := QC_reply.sfFile;			  Refresh_Dialog;	      	  errCode := FSpCreate(QC_Rec^^.Q_SprdSht_Spec, Spr_Creat, 'TEXT',smSystemScript);              save_setup := true;          END;      UNTIL ExitDialog;      IF save_setup then begin          Kill_Quants;          Clear_the_Rois;          LLSQ_active := False;	      Number_of_PeakRois := 3;	      Low_Peak_Book := QC_Rec^^.Q_Cal_Info.Q_BookE[1];	      High_Peak_Book := QC_Rec^^.Q_Cal_Info.Q_BookE[2];	  	  SIG_SQ := theSigConst * (Low_Peak_Book - 5895.0) + 4050.0;		  Low_delta_e := Sqrt(SIG_SQ) * 4;	  	  SIG_SQ := theSigConst * (High_Peak_Book - 5895.0) + 4050.0;		  High_delta_e := Sqrt(SIG_SQ) * 4;	      ROI^^.PEAK[1].Lo := rinttol((Low_Peak_Book-Low_delta_e)/Plt_Spec[10]^^.Expt_Info.dE);	      ROI^^.PEAK[1].Hi := rinttol((Low_Peak_Book+Low_delta_e)/Plt_Spec[10]^^.Expt_Info.dE);	      ROI^^.PEAK[2].Lo := rinttol((High_Peak_Book-High_delta_e)/Plt_Spec[10]^^.Expt_Info.dE);	      ROI^^.PEAK[2].Hi := rinttol((High_Peak_Book+High_delta_e)/Plt_Spec[10]^^.Expt_Info.dE);	      ROI^^.PEAK[1].Exists := true;	      ROI^^.PEAK[2].Exists := true;		  ROI^^.PEAK[1].ROI := Number_of_PeakRois;		  ROI^^.PEAK[2].ROI := Number_of_PeakRois;		  delta_e[1] := Low_delta_e/4.0;		  delta_e[2] := High_delta_e/4.0;			FOR index1 := 1 to 2 do begin				temp_max := 0.0;				FOR index := ROI^^.PEAK[index1].Lo to ROI^^.PEAK[index1].Hi do begin					IF Plt_spec[10]^^.s[index] > temp_max then begin						temp_max := Plt_spec[10]^^.s[index];						e_max := index * Plt_Spec[10]^^.Expt_Info.dE;					end;					ROI^^.PEAK[index1].Lo := rinttol((e_max-delta_e[index1])/Plt_Spec[10]^^.Expt_Info.dE);					ROI^^.PEAK[index1].Hi := rinttol((e_max+delta_e[index1])/Plt_Spec[10]^^.Expt_Info.dE);				end;		{FOR index := ROI^^.PEAK[index1].Lo to ROI^^.PEAK[index1].Hi}			end;		{FOR index1 := 1 to 2}		  Refresh_ROIs;	      Update_Full;	      tempRect := RQC^.portRect;	      DisposeDialog(RQC);	      FillWhiteSpace(tempRect);            FOR Index := 1 TO 3 DO              BEGIN                Test_a_Handle(Handle(Xdata[Index]), 'Xdata[Index], wtfit in Simplex');                Xdata[Index] := WindowArrayHdl(NewHandle(sizeof(WindowArray))); { double_t }                moveHHi(Handle(Xdata[Index]));                HLock(Handle(Xdata[Index]));              END;            Test_a_Handle(Handle(Ydata), 'Ydata in wtfit');            Ydata := WindowArrayHdl(NewHandle(sizeof(WindowArray))); { double_t }            moveHHi(Handle(Ydata));            HLock(Handle(Ydata));            Test_a_Handle(Handle(Weight), 'Weight in wtfit');            Weight := WindowArrayHdl(NewHandle(sizeof(WindowArray))); { double_t }            moveHHi(Handle(Weight));            HLock(Handle(Weight));            FOR Index := 1 TO Max_Num_Terms DO solution[Index] := 0.0;              FOR Index := 1 TO Max_Fitting_Chans DO			  begin			    Weight^^[index] :=  100000.0;				Ydata^^[index] := 0.0; { double_t }			    FOR index1 := 1 TO 3 DO Xdata[index1]^^[index] := 0.0; { double_t } 			  end;			order := 3;			FOR Index := 1 TO order DO lista[Index] := Index;          FOR jj := 1 to 2 do begin		    Index2 := 0;            Energy := ROI^^.PEAK[jj].Lo * Plt_Spec[10]^^.Expt_Info.dE;            FOR Index := ROI^^.PEAK[jj].Lo TO ROI^^.PEAK[jj].Hi DO              BEGIN {for index}                Index2 := Index2 + 1;				                Ydata^^[Index2] := Ln(Plt_spec[10]^^.s[index]); {data to fit, log of spectrum is real, Ydata is double_t}                Xdata[1]^^[Index2] := 1.0; { double_t - constant}                Xdata[2]^^[Index2] := Energy; { Xdata, Energy are double_t - linear coef}				Xdata[3]^^[Index2] := Energy * Energy; { Xdata, Energy are double_t - quad coef}					           { IF Col_1^[Index] < 1 THEN Weight^^[index1] := 1e12  has to be big for big spectra                 ELSE}				Weight^^[Index2] := SQRT(Plt_spec[10]^^.s[Index]);				                Energy := Energy + Plt_Spec[10]^^.Expt_Info.dE;              END; {for index}			GLfit(Ydata, Weight, Xdata, Index2, solution, order, lista, order, covar, ncvm, std);			(*Lfit(Ydata, Weight, Xdata, index1, order, covar, solution, std);*)  		 	IF jj = 1 then 				Low_Peak_Meas := - solution[2]/(2.0*solution[3])			ELSE IF jj = 2 then 				High_Peak_Meas := - solution[2]/(2.0*solution[3]);		 end;	{FOR jj := 1 to 2}		 	QC_Rec^^.Q_Cal_Info.Q_Slope := (High_Peak_Meas - Low_Peak_Meas) / (High_Peak_Book - Low_Peak_Book);		 	Plt_Spec[10]^^.Expt_Info.Energy_Slope := QC_Rec^^.Q_Cal_Info.Q_Slope;		 	{Analysis_Result^^.ExptStuff.energy_slope := QC_Rec^^.Q_Cal_Info.Q_Slope;}			QC_Rec^^.Q_Cal_Info.Q_Intercept := High_Peak_Meas - QC_Rec^^.Q_Cal_Info.Q_Slope * High_Peak_Book;			Plt_Spec[10]^^.Expt_Info.Energy_Intercept := QC_Rec^^.Q_Cal_Info.Q_Intercept;			{Analysis_Result^^.ExptStuff.energy_intercept := QC_Rec^^.Q_Cal_Info.Q_Intercept;}      H_UnLock_Dispose(Handle(Ydata), 'Ydata');      H_UnLock_Dispose(Handle(Weight), 'Weight');      FOR Index := 1 TO 3 DO      H_UnLock_Dispose(Handle(Xdata[Index]), 'Xdata[Index]');				{End of calibration section}	if(QC_SEM = true) then begin	{Measure the Beam Voltage}		Energy_Estimate := QC_Rec^^.Q_EBm_Info.Q_ApproxE;		D_H_Limit;		QC_Rec^^.Q_EBm_Info.Q_FinalE := Plt_spec[10]^^.Expt_Info.kV;	end	else		QC_Rec^^.Q_EBm_Info.Q_FinalE := QC_Rec^^.Q_EBm_Info.Q_ApproxE;	{Simplex fit the selected peaks}	 Majors       := True;	 Minors       := False;	 Satellites   := False;	 Clear_the_Rois;	 Use_Manual_ROIs := true;	constraint_switch := false;	Elements_Chosen := true;	Analysis_Result^^.Fit_params.Fit_Procedure := 'Sm';	Simplex_active := True;	Analysis_Result^^.Fit_params.Toler := QC_Rec^^.Q_Simpx_Info.Q_Tolerance;	Maximum_Iterations := QC_Rec^^.Q_Simpx_Info.Q_Stop;	analysis_result^^.fit_params.FWStart := QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[1];	Analysis_result^^.fit_Params.Number_of_Windows := QC_Rec^^.Q_Simpx_Info.Q_NumROIs;	Number_of_Elements_Simplexed := QC_Rec^^.Q_Simpx_Info.Q_NumElements;	Analysis_Result^^.Fit_params.Number_of_Peaks := QC_Rec^^.Q_Simpx_Info.Q_NumPeaks;	Number_of_PeakRois := QC_Rec^^.Q_Simpx_Info.Q_NumROIs + 1;	temp2 := Number_of_PeakRois - 1;	For indx := 1 to temp2 DO Begin		ROI^^.PEAK[indx] := QC_Rec^^.Q_Simpx_Info.Q_ROI[indx];		(*periodic_picks[indx] := QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[indx];		x_label[indx] := QC_Rec^^.Q_Simpx_Info.Q_Li_Peak[indx];*)		Analysis_result^^.fit_Params.Fitting_ROI_Hi[indx] := ROI^^.PEAK[indx].Hi * Plt_spec[10]^^.Expt_Info.dE;		Analysis_result^^.fit_Params.Fitting_ROI_Lo[indx] := ROI^^.PEAK[indx].Lo * Plt_spec[10]^^.Expt_Info.dE;		Analysis_result^^.fit_Params.First_in_Roi[indx] := QC_Rec^^.Q_Simpx_Info.Q_First_in_ROI[indx];	end;	IF Analysis_Result^^.Fit_params.Number_of_Peaks > 50 then num_pk := 50	else num_pk := Analysis_Result^^.Fit_params.Number_of_Peaks;    For indx := 1 to Analysis_Result^^.Fit_params.Number_of_Peaks DO Begin        Analysis_Result^^.Fit_params.Atomic_Number[indx] := QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[indx];    	Analysis_Result^^.Fit_params.Siegbahn[indx] := QC_Rec^^.Q_Simpx_Info.Q_Li_Peak[indx];    	Peak_Energy[indx] := QC_Rec^^.Q_Simpx_Info.Q_Energy[indx];    	PkAmpInfo[indx] := QC_Rec^^.Q_Simpx_Info.Q_WtngInfo[indx];    	Analysis_Result^^.Fit_params.ref_index[indx] := 0;	End;	Fit_Invisibly := false;	Do_A_Fit;	index := 0;	For indx := 1 to num_pk DO Begin		if (indx = Analysis_result^^.fit_Params.First_in_Roi[index+1]) then index := index + 1;    	QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[indx] := Analysis_Result^^.Fit_Result.FWHM_Mn[index];	{this per window}		QC_Rec^^.Q_Simpx_Info.Q_Area[indx] := Analysis_Result^^.Fit_Result.Area[indx];		QC_Rec^^.Q_Simpx_Info.Q_PktoBG[indx] := Analysis_Result^^.Fit_Result.Peak_to_Local_Bkg[indx];		QC_Rec^^.Q_Simpx_Info.Q_FWHM[indx] := 2354.825 * Sigma_Compute(QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[indx]/2354.825,										  Analysis_Result^^.Fit_Result.Err_or_Energy[indx] - 5.895);		QC_Rec^^.Q_Simpx_Info.Q_Energy[indx] := Analysis_Result^^.Fit_Result.Err_or_Energy[indx];	end;		{Sum the peak areas and select the data for output}	index1 := 0;    For indx := 1 to 50 do QC_Area[indx] := 0.0;    For indx := 1 to 50 do QC_PkBG[indx] := 0.0;	For index := 1 to temp2 do begin    	If temp2 = index then nxtROI := Analysis_Result^^.Fit_params.Number_of_Peaks    	else nxtROI := Analysis_result^^.fit_Params.First_in_Roi[index + 1] - 1;    	keepROI := false;    	For indx := Analysis_result^^.fit_Params.First_in_Roi[index] to nxtROI do begin    		If (Analysis_Result^^.Fit_params.Siegbahn[indx] = 'KA1  ') then begin    			index1 := index1 + 1;    			QC_Energy[index1] := QC_Rec^^.Q_Simpx_Info.Q_Energy[indx];    			QC_FWHM[index1] := QC_Rec^^.Q_Simpx_Info.Q_FWHM[indx];    			QC_FWHMMn[index1] := QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[indx];    			QC_Z[index1] := QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[indx];    			QC_Sieg[index1] := 'Ka';    			For temp := Analysis_result^^.fit_Params.First_in_Roi[index] to nxtROI do begin    				If (QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[temp] = QC_Z[index1]) AND    				   (QC_Rec^^.Q_Simpx_Info.Q_Li_Peak[temp][1] = 'K') then begin    				   QC_Area[index1] := QC_Area[index1] + QC_Rec^^.Q_Simpx_Info.Q_Area[temp];    				   QC_PkBG[index1] := QC_PkBG[index1] + QC_Rec^^.Q_Simpx_Info.Q_PktoBG[temp];    				 end;    			end;    		end;    		If (Analysis_Result^^.Fit_params.Siegbahn[indx] = 'LA1  ') then begin    			index1 := index1 + 1;    			QC_Energy[index1] := QC_Rec^^.Q_Simpx_Info.Q_Energy[indx];    			QC_FWHM[index1] := QC_Rec^^.Q_Simpx_Info.Q_FWHM[indx];    			QC_FWHMMn[index1] := QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[indx];    			QC_Z[index1] := QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[indx];    			QC_Sieg[index1] := 'La';    			For temp := Analysis_result^^.fit_Params.First_in_Roi[index] to nxtROI do begin    				If (QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[temp] = QC_Z[index1]) AND    				   (QC_Rec^^.Q_Simpx_Info.Q_Li_Peak[temp][1] = 'L') then begin    				   QC_Area[index1] := QC_Area[index1] + QC_Rec^^.Q_Simpx_Info.Q_Area[temp];    				   QC_PkBG[index1] := QC_PkBG[index1] + QC_Rec^^.Q_Simpx_Info.Q_PktoBG[temp];    				 end;    			end;    		end;       		If (Analysis_Result^^.Fit_params.Siegbahn[indx] = 'MA1  ') then begin    			index1 := index1 + 1;    			QC_Energy[index1] := QC_Rec^^.Q_Simpx_Info.Q_Energy[indx];    			QC_FWHM[index1] := QC_Rec^^.Q_Simpx_Info.Q_FWHM[indx];    			QC_FWHMMn[index1] := QC_Rec^^.Q_Simpx_Info.Q_Mn_FWHM[indx];    			QC_Z[index1] := QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[indx];    			QC_PkBG[index1] := QC_Rec^^.Q_Simpx_Info.Q_PktoBG[indx];    			QC_Sieg[index1] := 'Ma';    			For temp := Analysis_result^^.fit_Params.First_in_Roi[index] to nxtROI do begin    				If (QC_Rec^^.Q_Simpx_Info.Q_Z_Peak[temp] = QC_Z[index1]) AND    				   (QC_Rec^^.Q_Simpx_Info.Q_Li_Peak[temp][1] = 'M') then begin    				   QC_Area[index1] := QC_Area[index1] + QC_Rec^^.Q_Simpx_Info.Q_Area[temp];    				   QC_PkBG[index1] := QC_PkBG[index1] + QC_Rec^^.Q_Simpx_Info.Q_PktoBG[temp];    				 end;    			end;    		end;    	end;			end;	{For index := 1 to temp2}	{index1 contains the final number of reported peaks}	{Begin the spreadsheet output}		WITH QC_Rec^^, Q_Simpx_Info DO BEGIN		 errcode := FSPOpenDF(QC_Rec^^.Q_SprdSht_Spec,fsRdWrPerm,RefsNum);		 if errcode = opWrErr then begin		 	putmessage('This spreadsheet file is already open in ','another application. ',		 				'You must close it before using it here.','');		 	exit(Run_the_QC);		 end;		 errcode := GetEOF(RefsNum, len);		 IF len > 0 then		 	errcode := SetFPos(RefsNum, fsFromLEOF, 0)		 ELSE begin		 	str := concat('Spectrum', chr(9),'Date', chr(9),'Time', chr(9),'Current', chr(9),'Calib. Slope', chr(9),		 		'Calib. Offset', chr(9),'Beam E', chr(9));			len := length(str);	        errCode := FSwrite(RefsNum, len, @str[1]);		 					FOR indx := 1 to index1 DO BEGIN				str1 := CONCAT(A^.Sym[QC_Z[indx]], QC_Sieg[indx], ' Energy', chr(9));				str2 := CONCAT(A^.Sym[QC_Z[indx]], QC_Sieg[indx], ' Area', chr(9));				str5 := CONCAT(A^.Sym[QC_Z[indx]], QC_Sieg[indx], ' Pk to BG', chr(9));				str3 := CONCAT(A^.Sym[QC_Z[indx]], QC_Sieg[indx], ' FWHM', chr(9));				str4 := CONCAT(A^.Sym[QC_Z[indx]], QC_Sieg[indx], ' FWHM MnKa', chr(9));	 						str := concat(str1,str2,str5,str3,str4);				len := length(str);		        errCode := FSwrite(RefsNum, len, @str[1]);	        END;		 				 end;		END;	{WITH}        WITH Plt_spec[10]^^, SpectrumStuff, Acq_Info, Spectrum_Info DO        BEGIN        	theLint := Begin_Time;        	SecondsToDate(theLint, theDateTime);		      numtostring(theDateTime.day, str1);		      numtostring(theDateTime.month, str2);		      numtostring(theDateTime.year, str3);		      str1 := CONCAT(str1, '/', str2, '/', str3);			str := '';	        IF Spectrum_Comment_Field = '' THEN str := 'No Comments'	        ELSE if Length(Spectrum_Comment_Field) > 25 then str := copy(Spectrum_Comment_Field,1,25)			ELSE str := Spectrum_Comment_Field;			str2 := StringOf(Live_Time);			str3 := StringOf(Begin_Faraday);			str := concat(chr(13), str, chr(9), str1, chr(9), str2, chr(9), str3);			str1 := StringOf(QC_Rec^^.Q_Cal_Info.Q_Slope);			str2 := StringOf(QC_Rec^^.Q_Cal_Info.Q_Intercept);			str3 := StringOf(QC_Rec^^.Q_EBm_Info.Q_FinalE);			str := concat(str, chr(9), str1, chr(9), str2, chr(9), str3, chr(9));			len := length(str);	        errCode := FSwrite(RefsNum, len, @str[1]);	        	        FOR  indx := 1 to index1 DO BEGIN	        	str1 := StringOf(QC_Energy[indx], chr(9));	        	str2 := StringOf(QC_Area[indx], chr(9), QC_PkBG[indx], chr(9));	        	str3 := StringOf(QC_FWHM[indx], chr(9));	        	str4 := StringOf(QC_FWHMMn[indx], chr(9));				str := concat(str1,str2,str3,str4);				len := length(str);		        errCode := FSwrite(RefsNum, len, @str[1]);	        		        END;	        	        errCode := FSClose(RefsNum);	        errCode := FlushVol(NIL, QC_Rec^^.Q_SprdSht_Spec.vRefnum);		END;	{with}      end;      H_UnLock_Dispose(Handle(QC_Rec), 'QC_Rec');      {QC_Rec := NIL;}   	IF QC_running = false then begin        tempRect := RQC^.portRect;      DisposeDialog(RQC);      FillWhiteSpace(tempRect);    end;	  QC_running := false;  	END;	{Run_the_QC}END.