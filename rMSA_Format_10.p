UNIT MSA_Format_1_Plug;INTERFACEUSES	Types, QuickDraw, Memory, {OSUtils,} fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE MSA_Format_1(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:MSA_Format_1(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Read MSA 1.0';		{Debugstr('Inside of MSA_Format_R - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE MSA_Format_1(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);          CONST      tBufferSize            = 80000; {Never more than a single spectrum, 8192 chans ┼ 80K}										{Maximum size for this type is 4096 chans}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      Refnum                     	: integer;      tipBufPtr                     : tBufPtr;      indexL, posit                 : longint;      strLength, lenth              : TByte;      bytecount, opts               : longint;      str, str1, str2               : str255;	  num_channels					: real;	  err	                        : OSErr;	  IValue						: longint;	  Version, Rvalue, columns      : real;Function search_str(len : TByte; VAR strx : str255):longint;	VAR		strr	 : str255;		spec_str : STRING[5];	BEGIN        strLength[1] := len[1];        BlockMove(@strLength, @strr[0], 1);        spec_str := '#SPEC';        REPEAT          BlockMove(@tipBufPtr^[indexL], @strr[1], strLength[1]);          indexL := indexL + 1;        UNTIL ((strr = strx) OR (indexL >= FileSize) OR (strr = spec_str));        if (strr = spec_str) then begin			search_str := 0;			exit(search_str);        	        end;		if (indexL >= FileSize) then begin			search_str := indexL;			exit(search_str);		end;        indexL := indexL + strLength[1] -1;		{search_str := indexL;}		REPEAT			indexL := indexL + 1;		UNTIL (tipBufPtr^[indexL] = $3A);	{read until :}		indexL := indexL + 1;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces, CRs }        strr := '';        WHILE NOT (tipBufPtr^[indexL] = $0D) DO          BEGIN            {IF (tipBufPtr^[indexL] <> $20) then}            strr := CONCAT(strr, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		  strx := strr;		  search_str := indexL;	END;    	BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of MSA_Format');}					InPtr^.Specimen_Comment_Field := '';		nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;		lenth[1] := 7;        indexL := 0; { indexL will be the "file" pointer }		str := '#FORMAT';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;        lenth[1] := 8;		str := '#VERSION';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF str <> '1.0' THEN begin			theResult := badFileFormat;			exit(MSA_Format_1);				end;				InPtr^.Title_Comment_Field := '';        lenth[1] := 6;		str := '#TITLE';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF ((LENGTH(str) > 0) AND (posit > 0)) THEN InPtr^.Title_Comment_Field := 					CONCAT(InPtr^.Title_Comment_Field, str);					        lenth[1] := 5;		str := '#DATE';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;        lenth[1] := 5;		str := '#TIME';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;				InPtr^.Owner := '';			        lenth[1] := 6;		str := '#OWNER';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF ((LENGTH(str) > 0) AND (posit > 0)) THEN InPtr^.Owner := 					CONCAT(InPtr^.Owner, str);        lenth[1] := 8;		str := '#NPOINTS';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF ((LENGTH(str) > 0) AND (posit > 0)) THEN num_channels := str2num(str);        lenth[1] := 9;		str := '#NCOLUMNS';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;        lenth[1] := 7;		str := '#XUNITS';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF ((LENGTH(str) > 0) AND (posit > 0)) THEN begin		{Search for eV, then look for a k before the eV}			kk := Pos('eV',str);			if (kk > 0) then jj := 1;	{units are in eV}						kk := Pos('keV',str);			if (kk > 0) then jj := 1000;	{units are in keV}		end;        lenth[1] := 7;		str := '#YUNITS';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;        lenth[1] := 9;		str := '#DATATYPE';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;        lenth[1] := 9;		str := '#XPERCHAN';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF ((LENGTH(str) > 0) AND (posit > 0)) THEN InPtr^.dE := str2num(str) * jj;        lenth[1] := 7;		str := '#OFFSET';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		IF ((LENGTH(str) > 0) AND (posit > 0)) THEN			Rvalue := str2num(str) * jj;			InPtr^.NDoffset := - rinttol(Rvalue/InPtr^.dE);	{in eV}	{End of required keywords - rest are optional}			opts := posit;        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 7;		str := '#BEAMKV';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.kV := str2num(str);        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 11;		str := '#SIGNALTYPE';	{EDS, etc.}		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.Spectrum_Type := str;        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 10;		str := '#ELEVANGLE';	{detector}		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.D_Elevation := str2num(str);        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 10;		str := '#AZIMANGLE';	{detector}		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.D_Azimuth := str2num(str);        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 9;		str := '#LIVETIME';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.Live_Time := str2num(str);        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 9;		str := '#REALTIME';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.Real_Time := str2num(str);        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#PROBCUR';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN				InPtr^.Begin_Faraday := str2num(str);	{nA}				InPtr^.End_Faraday := InPtr^.Begin_Faraday;        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 10;		str := '#XTILTSTGE';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.X_Tilt := str2num(str)		ELSE begin	       indexL := opts; { indexL will be the "file" pointer }        	lenth[1] := 11;			str := '##STAGETILT';			posit := search_str(lenth, str);			IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.X_Tilt := str2num(str);		end;	{else}		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 10;		str := '#YTILTSTGE';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.Y_Tilt := str2num(str);		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 10;		str := '#THICKNESS';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.S_Thickness := str2num(str)/1.0E7;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TAUWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Au_Wind := str2num(str)*1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 10;		str := '#TDEADLAYR';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Dead_Layr := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TACTLYR';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Act_Layr := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TBEWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Be_Wind := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TALWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Al_Wind := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TPYWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Py_Wind := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TBNWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_BN_Wind := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#TDIWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_Di_Wind := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '#THCWIND';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.T_HC_Wind := str2num(str)/1.0E4;		        indexL := opts; { indexL will be the "file" pointer }        lenth[1] := 8;		str := '##MNFWHM';		posit := search_str(lenth, str);		IF ((LENGTH(str) > 0) AND (posit > 0) AND (indexL < FileSize)) THEN InPtr^.Mn_FWHM := str2num(str) * jj;				lenth[1] := 9;	    indexL := opts; { indexL will be the "file" pointer }		str := '#SPECTRUM';        BlockMove(@lenth, @str1[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str1[1], lenth[1]);          indexL := indexL + 1;        UNTIL ((str1 = str) OR (indexL >= FileSize));		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_1);		end;		        indexL := indexL + lenth[1] -1;		(*REPEAT			indexL := indexL + 1;		UNTIL (tipBufPtr^[indexL] = $0D);	{read until CR}		indexL := indexL + 1;*)		        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT (tipBufPtr^[indexL] = $0D) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		{InPtr^.Specimen_Comment_Field := 					CONCAT(InPtr^.Specimen_Comment_Field, str);}{ееееееееееееееее}          jj := 0; { jj will be the channel number }                    InPtr^.Number_of_Channels := rinttol(num_channels);          InPtr^.LastChannel := InPtr^.Number_of_Channels;          indexL := indexL + 1;          REPEAT {еееее This part reads in the spectrum еееее}            WHILE ((tipBufPtr^[indexL] = $20) OR             		(tipBufPtr^[indexL] = $09) OR             		(tipBufPtr^[indexL] = $0D) OR            		(tipBufPtr^[indexL] = $2D) OR            		(tipBufPtr^[indexL] = $0A)) DO begin              indexL := indexL + 1; { jump over a run of spaces, etc. }			end;            str := '';            REPEAT	            WHILE ((tipBufPtr^[indexL] >= $30) AND	            		(tipBufPtr^[indexL] <= $39) OR	            		(tipBufPtr^[indexL] = $2E)) DO	              BEGIN	                str := CONCAT(str, chr(tipBufPtr^[indexL]));	                indexL := indexL + 1;	              END; { While }	        UNTIL  ((tipBufPtr^[indexL] = $2C) OR (tipBufPtr^[indexL] = $0D) OR (tipBufPtr^[indexL] = $20)); {, or CR}			{sysbeep(2);}	            IF (LENGTH(str) > 0) THEN	              BEGIN	                jj := jj + 1;	                InPtr^.Spec_cts[jj] := str2num(str);	              END;            indexL := indexL + 1;          UNTIL ((jj >= InPtr^.Number_of_Channels) OR          		 (tipBufPtr^[indexL] = $23) OR          		 (indexL >= FileSize)); {еееее This part read in the spectrum еееее}		theResult := Noerr;        DisposePtr(Ptr(tipBufPtr));      END; { MSA Format }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.