{[j=30/55,:+,u+,r+,o=220,k+,n+,#+,v+,q+,b+]}{[f-]} {*********************************} UNIT ZAF;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory,TextUtils, Finder, Dialogs, Controls,   Packages, Printing, StandardFile, Resources, Retrace, SegLoad, fenv, fp, PasLibIntf, TextEdit, Windows, Events, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Utilities, xray, Xray_Energies, physics, Simplexer,Linear_Least_Squares ;     PROCEDURE D_DialZAF;  	PROCEDURE D_Select_Standard;    PROCEDURE FRAM;    PROCEDURE start_stdless;    PROCEDURE D_Add_standard;	PROCEDURE Read_KFJH_File;	PROCEDURE Review_standard;	Procedure See_the_Standard;	PROCEDURE find_peak_in_ROI( index, index1 : integer; VAR peak_int : real {double_t});{[f+]} (*    TYPE      ZAF_Stuff                     = RECORDSimplex_run                  : boolean; { all spectra - one of these two must be 1 }ML_run                       : boolean; { all spectra }standard                     : boolean; { if spectrum is a standard this is 1 }Stoic_Diff                   : boolean; { 0 for element by difference or 1 if by stoic. }Num_elements                 : integer; { number of elements in specimen }Atomic_Number                : ARRAY [1..15] OF integer; { for each element in specimen }Atom_Wt                      : ARRAY [1..15] OF real; { for each element in specimen }Valence                      : ARRAY [1..15] OF real; { for each element in specimen }Siegbahn                     : ARRAY [1..15] OF Str_5; { x-ray line for quant. of each element }Std_Name                     : ARRAY [1..15] OF STRING[64]; { for specimen - name of standard                                                               used to quant. each element }Pure_Standard_Intensity      : ARRAY [1..15] OF real; { for standard - peak area }Concentration                : ARRAY [1..15] OF real; { if std then wt.fr. of element.                                                        if unknown then quant. results }K_kRatio                     : ARRAY [1..15] OF real; { k ratio for a K line - unknown.                                                         if std then this is std factor }L_kRatio                     : ARRAY [1..15] OF real; { k ratio for a L line - unknown.                                                         if std then this is std factor }M_kRatio                     : ARRAY [1..15] OF real; { k ratio for a M line - unknown.                                                         if std then this is std factor }Peak_to_Bkg                  : ARRAY [1..15] OF real; { peak to background ratio - used for                                                          particles }ChiSqr                       : ARRAY [1..15] OF real; { chi squared from fitting }Err_Energy                   : ARRAY [1..15] OF real; { LS - fitting error. Simplex - peak energy }Spare1                       : ARRAY [1..15] OF integer;Spare2                       : ARRAY [1..15] OF real;Unanal_Z_On                  : boolean;Fixed_Conc         : array [1..15] of Boolean;Normalize_On                 : boolean;bspare3                      : boolean;bspare4                      : boolean;                                      END;      ZAFPtr                        = ^ZAF_Stuff;      ZAFHdl                        = ^ZAFPtr;  ZAF_full    = RECORD      Standard_Name                : Str255; { if a standard then this is std name }      SpectrumType                 : STRING[4]; { EDS, WDS, EELS, etc. }      E0                           : real; { beam voltage in kV }      Take_Off_Angle               : real; { take off angle }      Instrument                   : real; { instrument - probably detectorID }      Faraday_current              : real; { beam current nA }      Live_Time                    : real; { counting time for spectrum }      Num_Fit_Peaks                : integer; { Num_Peaks_Fitted }      Spare2                       : real;      Spare3                       : real;      bspare1                      : boolean;      bspare2                      : boolean;      bspare3                      : boolean;      bspare4                      : boolean;      ZAF_data                     : ZAF_Stuff;    END;  ZAF_fullPtr                   = ^ZAF_full;  ZAF_fullHdl                   = ^ZAF_fullPtr;*)   {******************************} IMPLEMENTATION {**********************************}{$S ZAF}{  TYPE  	TheDRec						  = DialogRecord;    TheDRecPtr					  = ^TheDRec;}  VAR    MyPt                          : Point;    List_I_List1                  : ListHandle;   (* Rect_I_List1                  : Rect;*)    Do_select                     : boolean;    total_stds                    : integer;    standard_ok                   : boolean;    (*num_std_structures            : integer;*)		{본볈ake global 5/21/95본볗    good_data                     : boolean;    fixed_bool                    : boolean;    Num_Anal_Peaks                : integer;    Stds_VolRefNum                : integer;    fndrInfo                      : FInfo;    refnum_Z                      : text;    ZAF_vol                       : integer;    save_ZAF                      : boolean;    ZAF_File_Name                 : fnamestr;	Fit_File_Name                 : fnamestr;    Review_std_file               : boolean;    Get_Unanal		              : DialogPtr;    Get_Sel_Ele	                  : DialogPtr;    Get_Sel_Std                   : DialogPtr;    Get_Dial_ZAF                  : DialogPtr;    Get_Add_std                   : DialogPtr;    Get_Sel_Line                  : DialogPtr;   { DRecPtr						  : TheDRecPtr;}	PROCEDURE find_peak_in_ROI {(index, index1 : integer; VAR peak_int : double_t)};		{ index is the subscript for the element analyzed in ZAF_Record }		{ index1 is the peak number in analysis_result }			VAR		nn						: integer;   		index3, first, last     : integer;		pk_ener					: real;		BEGIN	peak_int := 0.0;	nn := 0;	REPEAT      nn := nn + 1;	UNTIL (nn >= analysis_result^^.Fit_params.Number_of_Windows) OR ((index1 >= analysis_result^^.		  Fit_params.First_in_Roi[nn]) AND (index1 < analysis_result^^.Fit_params.First_in_Roi[nn +		  1]));		{ nn is the ROI number }	first := analysis_result^^.Fit_params.First_in_Roi[nn]; { number of 1st pk in window }	IF (nn = analysis_result^^.Fit_params.Number_of_Windows) THEN { in the last ROI }	  last := analysis_result^^.Fit_params.Number_of_Peaks	ELSE { before the last ROI }	  last := analysis_result^^.Fit_params.First_in_Roi[nn + 1] - 1;	  	 Xray_Data_Request := TRUE;	Get_Energies(ZAF_Record^^.ZAF_data.Atomic_Number[index]);	  Xray_Data_Request := FALSE;	  	if (ZAF_Record^^.ZAF_data.Siegbahn[index][1] = 'K') then 	  begin	    pk_ener := eV_Line[1];		ZAF_Record^^.ZAF_data.Siegbahn[index] := 'KA  ';	  end	else if (ZAF_Record^^.ZAF_data.Siegbahn[index][1] = 'L') then	  begin	    pk_ener := eV_Line[42];		ZAF_Record^^.ZAF_data.Siegbahn[index] := 'LA  ';	  end	else if (ZAF_Record^^.ZAF_data.Siegbahn[index][1] = 'M') then	  begin	    pk_ener := (eV_Line[72] + eV_Line[73])/2;		ZAF_Record^^.ZAF_data.Siegbahn[index] := 'MA  ';	  end;		ZAF_Record^^.ZAF_data.Spare1[index] := 0;		{본ROI structure is not defined when data is from a file본볗	{ROI^^.Peak[nn].Lo := analysis_result^^.Fit_params.Fitting_ROI_Lo[nn]}	{ROI^^.Peak[nn].Hi := analysis_result^^.Fit_params.Fitting_ROI_Hi[nn]}	{analysis_result^^.ExptStuff.dE}		FOR index3 := first TO last DO	  BEGIN		IF (analysis_result^^.Fit_params.Atomic_Number[index3] = ZAF_Record^^.ZAF_data.Atomic_Number[index]) AND			(pk_ener > ROI^^.Peak[nn].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND			(pk_ener < ROI^^.Peak[nn].Hi * Plt_Spec[10]^^.Expt_Info.dE) AND			(analysis_result^^.Fit_params.Siegbahn[index3][4] <> 'D') THEN		  BEGIN			peak_int := analysis_result^^.Fit_Result.Area[index3];			ZAF_Record^^.ZAF_data.Peak_to_Bkg[index] := analysis_result^^.Fit_Result.Peak_to_Local_Bkg[index3];			ZAF_Record^^.ZAF_data.Spare1[index] := ZAF_Record^^.ZAF_data.Spare1[index] + 1;			ZAF_Record^^.ZAF_data.L_kRatio[index] := ROI^^.Peak[nn].Lo * Plt_Spec[10]^^.Expt_Info.dE;			ZAF_Record^^.ZAF_data.M_kRatio[index] := ROI^^.Peak[nn].Hi * Plt_Spec[10]^^.Expt_Info.dE;			 		  END;	  END;	  	(*peak_int := peak_int / analysis_result^^.SpectrumStuff.						Acq_Info.Live_Time / ZAF_Record^^.Faraday_current;*)				END;		{ PROCEDURE find_peak_in_ROI }{$S ZAF1A}  PROCEDURE Get_ZAFInfo;    VAR      nn, index, index1, index2		: integer;      index3, first, last           : integer;      peak_label                    : ARRAY [0..3] OF Str_5;      num_peaks                     : integer;      flag                          : boolean;	  peak_int						: real {double_t};      str, str1, str2, str3			: Str255; (*  Needed variables are as follows:    analysis_result^^.ExptStuff.detectorID         :real              .kV                 :real     .SpectrumStuff  .Spectrum_Info  .Spectrum_Type          :String[4]             .Spectrum_Comment_Field :Str255             .Spectrum_Class         :String[10]             .This_is_a_Standard     :Boolean             .Take_Off_Angle         :real             .Number_of_Elements     :integer             .Element_Info       .Atomic_number      :integer                  .Atomic_Weight      :real                  .Weight_Fraction    :real                  .Valence            :real                                        .Acq_Info       .Begin_Faraday          :real                                                        .End_Faraday            :real                                                        .Real_Time              :real                                                        .Live_Time              :real                                                        .ActualLiveTime         :longint                        .Fit_Params     .Fit_Procedure      :String[2]                                        .Number_of_Peaks    :integer                                        .Atomic_Number      :array[1..15] of integer                                        .Siegbahn           :array[1..15] of Str_5                        .Fit_Result     .area               :array[1..15] of real                                        .Err_or_Energy      :array[1..15] of real                                        .Peak_to_Local_Bkg  :array[1..15] of real                                        .conc               :array[1..15] of real*)    BEGIN      good_data := true;      ZAF_Record^^.ZAF_data.Simplex_run := False;      ZAF_Record^^.ZAF_data.ML_run := False;      ZAF_Record^^.ZAF_data.Stoic_Diff := False; { unanalyzed element by difference }      ZAF_Record^^.ZAF_data.standard := False;      ZAF_Record^^.Num_Fit_Peaks := 0;      IF (analysis_result^^.Fit_params.Fit_Procedure = 'Sm') THEN        BEGIN          ZAF_Record^^.ZAF_data.Simplex_run := true;          peak_label[0] := 'U    ';          peak_label[1] := 'KA1  ';          peak_label[2] := 'LA1  ';          peak_label[3] := 'MA1  ';        END      ELSE        IF (analysis_result^^.Fit_params.Fit_Procedure = 'ML') THEN          BEGIN            ZAF_Record^^.ZAF_data.ML_run := true;            peak_label[0] := 'U    ';            peak_label[1] := 'K    ';            peak_label[2] := 'L    ';            peak_label[3] := 'M    ';          END        ELSE          BEGIN            { no analysis result is present - go and do a fit }          END;      ZAF_Record^^.Take_Off_Angle := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;      ZAF_Record^^.Standard_Name := analysis_result^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field;	  ZAF_Record^^.SpectrumType:='';      ZAF_Record^^.E0 := analysis_result^^.ExptStuff.kV;      ZAF_Record^^.Take_Off_Angle := analysis_result^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;      ZAF_Record^^.Instrument := analysis_result^^.ExptStuff.detector.ID;      ZAF_Record^^.Faraday_current := (analysis_result^^.SpectrumStuff.Acq_Info.Begin_Faraday + analysis_result^^.SpectrumStuff.                                      Acq_Info.End_Faraday) / 2;      IF (ZAF_Record^^.Faraday_current <= 0.0) THEN        BEGIN          ZAF_Record^^.Faraday_current := 1.0;          putmessage(' The Faraday current was not defined', ' and has arbitrarily been set to 1.0nA.',                     ' If this is not satisfactory, you should assign', ' the correct values in the spectrum header.');        END;      ZAF_Record^^.Live_Time := analysis_result^^.SpectrumStuff.Acq_Info.Live_Time;      IF NOT (analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard) THEN        IF AnswerMessage('This spectrum was not previously selected as a standard.',                         'Do you want it to be a standard??? If you hit "Its OK" then this',                         'spectrum will be computed as a standard provided the compositions ',                         'are stored in the spectrum header; otherwise you MUST edit the header.') THEN          analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard := true        ELSE analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard := False;      IF (ZAF_Record^^.E0 <= 0.0) OR (ZAF_Record^^.Live_Time <= 0.0) OR (ZAF_Record^^.Faraday_current <= 0.0) THEN        BEGIN          realtostring(ZAF_Record^^.E0, 5, 4, str1);          str := concat(' Beam Voltage = ', str1);          realtostring(ZAF_Record^^.Live_Time, 5, 4, str2);          str1 := concat(',  Live-Time = ', str2);          realtostring(ZAF_Record^^.Faraday_current, 5, 4, str3);          str2 := concat(' and  Beam Current = ', str3);          str3 := concat(str, str1, str2);          putmessage(' WARNING!  This analysis cannot proceed. The ', str3, ' in the experiment and spectrum headers.',                     ' Please edit the headers to supply the information and then REFIT the spectrum.');          IF (Is_Batch = true) THEN            BEGIN              Is_Batch := False;              abort_x := true;            END;          good_data := True {False};        END;      (*IF (good_data = true) THEN        BEGIN          realtostring(ZAF_Record^^.E0, 6, 4, str1);          str := concat('   Voltage = ', str1);          realtostring(ZAF_Record^^.Live_Time, 6, 4, str2);          str1 := concat('   Live-Time = ', str2);          realtostring(ZAF_Record^^.Faraday_current, 6, 4, str3);          str2 := concat('   Beam Current = ', str3);          str3 := concat(str, str1, str2);          IF (AnswerMessage(str3, 'Are these values OK??? If you hit "Its OK" then this',                            'spectrum will be computed as a standard provided the compositions ',                            'are stored in the spectrum header; otherwise you MUST edit the headers.')) THEN            good_data := true          ELSE good_data := False;        END;*)      IF (good_data = true) THEN        BEGIN          IF (analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard) THEN            BEGIN              ZAF_Record^^.ZAF_data.standard := true;              ZAF_Direction := 1;              ZAF_Record^^.ZAF_data.Num_elements := analysis_result^^.SpectrumStuff.Spectrum_Info.Number_of_Elements;              num_peaks := analysis_result^^.Fit_params.Number_of_Peaks;			  FOR index := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO			  	ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := 0.0;              FOR index := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO                BEGIN                  ZAF_Record^^.ZAF_data.Atomic_Number[index] := analysis_result^^.SpectrumStuff.Spectrum_Info.Element_Info[index].                                                                Atomic_Number;                  ZAF_Record^^.ZAF_data.Concentration[index] := analysis_result^^.SpectrumStuff.Spectrum_Info.Element_Info[index].                                                                Weight_Fraction;                  ZAF_Record^^.ZAF_data.Valence[index] := analysis_result^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Valence;                  flag := False;                  index1 := 1;  { realtostring(ZAF_Record^^.ZAF_data.Valence[index], 6, 4, str1);   putmessage(' The valence is ',str1,'','');}                  WHILE (NOT flag) AND (index1 <= num_peaks {analysis_result^^.Fit_params.Number_of_Peaks} ) DO                    BEGIN                      index2 := 1;                      REPEAT						IF (analysis_result^^.Fit_params.Fit_Procedure = 'Sm') THEN								analysis_result^^.Fit_params.Ref_Index[index1] := 1;                        IF (ZAF_Record^^.ZAF_data.Atomic_Number[index] = analysis_result^^.Fit_params.Atomic_Number[index1]) AND (                           peak_label[index2] = analysis_result^^.Fit_params.Siegbahn[index1]) AND (analysis_result^^.Fit_params.Ref_Index[index1] > 0)						   AND (analysis_result^^.Fit_params.Siegbahn[index1][4] <> 'D') THEN                          BEGIN                            flag := true;                            ZAF_Record^^.ZAF_data.Siegbahn[index] := peak_label[index2];                                                        IF (ZAF_Record^^.ZAF_data.Simplex_run = TRUE) THEN                              BEGIN     {Index1 is the number of the selected peak in analysis_results. If     it is greater than First_in_Roi[window_number] and less than     First_in_Roi[window_number+1] then we have found the correct ROI for     this element. We may then use ROI^^.Lo and ROI^^.Hi as the high & low     energies to be saved and between which the peaks will be summed.}                                nn := 0;                                REPEAT      {   numtostring(nn,str);        putmessage(' first val of window number is ',str, '', '');}                                  nn := nn + 1;       {  numtostring(nn,str);        putmessage(' second val of window number is ',str, '', '');}                                UNTIL (nn >= analysis_result^^.Fit_params.Number_of_Windows) OR ((index1 >= analysis_result^^.                                      Fit_params.First_in_Roi[nn]) AND (index1 < analysis_result^^.Fit_params.First_in_Roi[nn +                                      1]));                                first := analysis_result^^.Fit_params.First_in_Roi[nn]; { number of 1st pk in window }                                IF (nn = analysis_result^^.Fit_params.Number_of_Windows) { in the last ROI }                                   THEN                                  last := num_peaks {analysis_result^^.Fit_params.Number_of_Peaks}                                ELSE { before the last ROI }                                  last := analysis_result^^.Fit_params.First_in_Roi[nn + 1] - 1;                                ZAF_Record^^.ZAF_data.Spare1[index] := 0;                                ZAF_Record^^.ZAF_data.L_kRatio[index] := ROI^^.Peak[nn].Lo * Plt_Spec[10]^^.Expt_Info.dE;                                ZAF_Record^^.ZAF_data.M_kRatio[index] := ROI^^.Peak[nn].Hi * Plt_Spec[10]^^.Expt_Info.dE;                               FOR index3 := first TO last DO                                  BEGIN                                    IF (analysis_result^^.Fit_params.Atomic_Number[index3] = ZAF_Record^^.ZAF_data.Atomic_Number[                                       index]) THEN                                      BEGIN                                        ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := ZAF_Record^^.ZAF_data.                                                                                                Pure_Standard_Intensity[index] +                                                                                                analysis_result^^.Fit_Result.Area[                                                                                                index3];										{ZAF_Record^^.ZAF_data.RawArea[index] := ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index];}                                        ZAF_Record^^.ZAF_data.Spare1[index] := ZAF_Record^^.ZAF_data.Spare1[index] + 1;                                      END;                                  END;      { if ZAF_Record^^.ZAF_data.Siegbahn[index] = 'KA1  ' then        ZAF_Record^^.ZAF_data.Spare1[index] := ZAF_Record^^.ZAF_data.Spare1[index] -1;}                              END {if (ZAF_Record^^.ZAF_data.Simplex_run)}							                              ELSE                              IF (ZAF_Record^^.ZAF_data.ML_run = TRUE) AND							  	(flag = TRUE) THEN							   BEGIN							     find_peak_in_ROI(index, index1, peak_int);								 if (ZAF_Record^^.ZAF_data.Spare1[index] > 0) then								   begin									 ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := peak_int;									 {ZAF_Record^^.ZAF_data.RawArea[index] := peak_int;}								   end								 else								   flag := false;								   index1 := index1 + 1;							   END;                          END                        ELSE index2 := index2 + 1;                      UNTIL (flag) OR (index2 > 3);                      IF (index2 > 3) THEN ZAF_Record^^.ZAF_data.Siegbahn[index] := 'U    ';                      index1 := index1 + 1;                    END; { WHILE }					ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := 					ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] / 					ZAF_Record^^.Faraday_current /					ZAF_Record^^.Live_Time;					ZAF_Record^^.ZAF_data.RawArea[index] := ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index];                END; { FOR index := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO }				            END; { IF (analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard) }        END; { IF (good_data = true) then }    END; { PROCEDURE Get_ZAFInfo }		PROCEDURE ZAF_the_Fit;	{ called to quantitate a fit results file. }  { Reads through a file of fit results and calculates concentrations. }  VAR 	errcode,refnum,err : integer;  	    bytecount,count	:longint;        mytype                       : ARRAY [0..3] of OSType {SFTypeList};		sfPtr             			 : ConstSFTypeListPtr;        myprompt                      : Str255;		Inreply						 : StandardFileReply;		rd_FSSpec					 : FSSpec;			  BEGIN				mytype[0] := 'MCAb';				sfPtr := @mytype;				myprompt := 'Open the Fit File';			(*	IF (GetFileName(MCA_ResultsName, mytype, mytype, myprompt)) THEN			     begin			   errCode := FSOpen_err(MCA_ResultsName,MCA_Results_VolNum, refnum,'');*)			  errCode := getvol(Save_Volume_Name, save_vol); 			  StandardGetFile(NIL,1, sfPtr, Inreply);		{본New DTSA file spec본}			  File_Cancel_Button := Inreply.sfGood;			  if NOT Inreply.sfGood Then exit(ZAF_the_Fit);			  rd_FSSpec := Inreply.sfFile;			  errCode := FSpOpenDF(rd_FSSpec, fsRdWrPerm, refnum);			  if errCode = noerr then BEGIN			  	{MCA_Results_VolNum := rd_FSSpec.vRefNum;}			   	MCA_ResultsName := rd_FSSpec.name;	   			   MCA_File_Boolean := true;     		   errCode := SetFPos_err(refnum, fsFromStart,1,'');{ 1st byte has T or F for is_batch}			   bytecount := sizeof(Simplex_Fit);			   count := -bytecount;			   ZAF_Direction := 3;			   repeat			    {read next fit result}	              err := FSRead(refnum, bytecount, @Analysis_Result^^);				  IF (err = noerr) then				  WITH Analysis_result^^.SpectrumStuff.Spectrum_Info				  do begin				      FRAM;					  { go back to start of the same fit result}     		          errCode := SetFPos_err(refnum, fsFromMark,count,'');					  {write fit result with calculated concentrations}	                  errCode := FSWrite_err(refnum, bytecount, @Analysis_Result^^,'');				  end; { IF... WITH Analysis_result^^... }			   Until (err = eoferr);			   	 errCode := FSClose(refnum);				 errCode := FlushVol(NIL, rd_FSSpec.vRefNum);				 end;				errCode := setvol(Save_Volume_Name, save_vol);			 end;			{$S ZAF6}  PROCEDURE D_Unanalyzed_Element;    CONST      I_OK                          = 1;      I_Yes                         = 2;      I_No                          = 3;      I_Stoichiometry               = 4;      I_Difference                  = 5;      I_x11                         = 9;      Fixed_Yes                     = 10;      Fixed_No                      = 11;        VAR      ExitDialog                    : boolean;      tempRect                      : Rect;      DType                         : integer;      index, index1, indx           : integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : Str255;      itemHit                       : integer;      temp, temp1, temp2            : integer;      Peak_Substituted      		: boolean;      Un_Z_Str                      : STRING[3];      Z_Unanal                      : longint;      str, str1						: Str255;      {This is an update routine for non-controls in the dialog}      {This is executed after the dialog is uncovered by an alert}        PROCEDURE Refresh_Dialog;            BEGIN        SetPort(Get_Unanal);        GetDialogItem(Get_Unanal, I_OK, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN      WITH ZAF_Record^^, ZAF_data DO        BEGIN          Get_Unanal := GetNewDialog(737, NIL, Pointer( - 1));          ShowWindow(Get_Unanal);          SelectWindow(Get_Unanal);          SetPort(Get_Unanal);          {Setup initial conditions}          Un_Z_Str := '8';          Stoic_Diff := False;          Unanal_Z_On := False;          GetDialogItem(Get_Unanal, I_No, DType, DItem, tempRect);          SetControlValue(ControlHandle(DItem), 1);          temp := I_No;          GetDialogItem(Get_Unanal, Fixed_No, DType, DItem, tempRect);          SetControlValue(ControlHandle(DItem), 1);          fixed_bool := False;          GetDialogItem(Get_Unanal, I_Stoichiometry, DType, DItem, tempRect);          SetControlValue(ControlHandle(DItem), 1);          HiliteControl(ControlHandle(DItem), 255);          GetDialogItem(Get_Unanal, I_Difference, DType, DItem, tempRect);          SetControlValue(ControlHandle(DItem), 0);          HiliteControl(ControlHandle(DItem), 255);          GetDialogItem(Get_Unanal, I_x11, DType, DItem, tempRect);          SetDialogItemText(DItem, Un_Z_Str);          Refresh_Dialog;          ExitDialog := False;           REPEAT            ModalDialog(NIL, itemHit);            GetDialogItem(Get_Unanal, itemHit, DType, DItem, tempRect);            CItem := ControlHandle(DItem);            IF (itemHit = I_OK) THEN              BEGIN                ExitDialog := true;              END;            IF (itemHit >= I_Yes) AND (itemHit <= I_No) THEN              BEGIN                temp := itemHit;                FOR index := I_Yes TO I_No DO                  BEGIN                    GetDialogItem(Get_Unanal, index, DType, DItem, tempRect);                    SetControlValue(ControlHandle(DItem), 0);                  END;                SetControlValue(CItem, 1);              END;            IF (itemHit >= Fixed_Yes) AND (itemHit <= Fixed_No) THEN              BEGIN                temp2 := itemHit;                IF itemHit = Fixed_Yes THEN fixed_bool := true;                IF itemHit = Fixed_No THEN fixed_bool := False;                FOR index := Fixed_Yes TO Fixed_No DO                  BEGIN                    GetDialogItem(Get_Unanal, index, DType, DItem, tempRect);                    SetControlValue(ControlHandle(DItem), 0);                  END;                SetControlValue(CItem, 1);              END;            IF (itemHit >= I_Stoichiometry) AND (itemHit <= I_Difference) THEN              BEGIN                FOR index1 := I_Stoichiometry TO I_Difference DO                  BEGIN                    GetDialogItem(Get_Unanal, index1, DType, DItem, tempRect);                    SetControlValue(ControlHandle(DItem), 0);                  END;                SetControlValue(CItem, 1);              END;            IF (temp = I_Yes) THEN              BEGIN                GetDialogItem(Get_Unanal, I_x11, DType, DItem, tempRect);                GetDialogItemText(DItem, sTemp);                Un_Z_Str := Strip_Trailing_Blanks(sTemp);                IF (Un_Z_Str = '8') AND (ZAF_Record^^.ZAF_data.Valence[1] > 0.0) THEN                  BEGIN                    GetDialogItem(Get_Unanal, I_Stoichiometry, DType, DItem, tempRect);                    HiliteControl(ControlHandle(DItem), 0);                    IF (Standardless_Active) THEN SetControlValue(ControlHandle(DItem), 1);                    GetDialogItem(Get_Unanal, I_Difference, DType, DItem, tempRect);                    IF (Standardless_Active) THEN                      BEGIN                        HiliteControl(ControlHandle(DItem), 255);                        SetControlValue(ControlHandle(DItem), 0);                      END                    ELSE HiliteControl(ControlHandle(DItem), 0);                  END                ELSE                  BEGIN                    GetDialogItem(Get_Unanal, I_Stoichiometry, DType, DItem, tempRect);                    SetControlValue(ControlHandle(DItem), 0);                    HiliteControl(ControlHandle(DItem), 255);                    IF (Standardless_Active) AND (ZAF_Record^^.ZAF_data.Valence[1] <= 0.0) THEN                      BEGIN                        putmessage('Standardless analysis allows only oxygen to be done by stoichiometry.',                                   ' No valences were found for the analyzed elements.',                                   ' You must first enter the valences for the analyzed elements in the ',                                   'Spectrum Header then select the standardless analysis again.');                        ExitDialog := true;                      END;                    GetDialogItem(Get_Unanal, I_Difference, DType, DItem, tempRect);                    SetControlValue(ControlHandle(DItem), 1);                    IF (Standardless_Active) THEN HiliteControl(ControlHandle(DItem), 255)                    ELSE HiliteControl(ControlHandle(DItem), 0);                  END;              END            ELSE              IF (temp = I_No) THEN                BEGIN                  GetDialogItem(Get_Unanal, I_Stoichiometry, DType, DItem, tempRect);                  SetControlValue(ControlHandle(DItem), 1);                  HiliteControl(ControlHandle(DItem), 255);                  GetDialogItem(Get_Unanal, I_Difference, DType, DItem, tempRect);                  SetControlValue(ControlHandle(DItem), 0);                  HiliteControl(ControlHandle(DItem), 255);                END;          UNTIL ExitDialog;          {Get results after dialog}          str := 'neither';          IF fixed_bool THEN str := 'true';          IF NOT fixed_bool THEN str := 'false';          {putmessage('the boolean for fixed conc is ',str,'','');}          { Setup for fixing the concentrations of certain elements.}          FOR index := 1 TO 15 DO            Fixed_conc[index] := False;          IF (fixed_bool) THEN            BEGIN   {If NOT (Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated) then     Begin}              Num_Anal_Peaks := ZAF_Record^^.ZAF_data.Num_elements;               Xray_Data_Request := TRUE;              FOR index := 1 TO 15 DO                BEGIN                  IF (Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Atomic_Number > 1) AND (Plt_Spec[10]^^.                     SpectrumStuff.Spectrum_Info.Element_Info[index].Weight_Fraction > 0) THEN                    BEGIN                      Peak_Substituted := False;                      FOR indx := 1 TO Num_Anal_Peaks DO                        BEGIN                          IF (Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Atomic_Number = ZAF_Record^^.ZAF_data.                             Atomic_Number[indx]) THEN                            BEGIN                              ZAF_Record^^.ZAF_data.Concentration[indx] := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[                                                                           index].Weight_Fraction;                              Get_Energies(ZAF_Record^^.ZAF_data.Atomic_Number[index1]);                              ZAF_Record^^.ZAF_data.Atom_Wt[indx] := Atomic_Weight;                              ZAF_Record^^.ZAF_data.Valence[indx] := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index].                                                                     Valence;                              Fixed_conc[indx] := true;                              Peak_Substituted := true;                            END;                        END;                      IF NOT (Peak_Substituted) THEN                        BEGIN                          ZAF_Record^^.ZAF_data.Num_elements := ZAF_Record^^.ZAF_data.Num_elements + 1;                          IF ZAF_Record^^.ZAF_data.Num_elements > 15 THEN                            BEGIN                              ZAF_Record^^.ZAF_data.Num_elements := 15;                              putmessage('ZAF_Record^^.ZAF_data.Num_elements just tried to go over 15 at ~~2, I clamped it at 15',                                         'Im in ZAF.P', '', '');                            END;                          index1 := ZAF_Record^^.ZAF_data.Num_elements;                          ZAF_Record^^.ZAF_data.Atomic_Number[index1] := 						       Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Atomic_Number;                          ZAF_Record^^.ZAF_data.Concentration[index1] := 						       Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Weight_Fraction;                          Get_Energies(ZAF_Record^^.ZAF_data.Atomic_Number[index1]);                          ZAF_Record^^.ZAF_data.Atom_Wt[index1] := Atomic_Weight;                          ZAF_Record^^.ZAF_data.Valence[index1] := 						       Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Valence;                          Fixed_conc[index1] := true;                        END;                    END;                  {end;}                  Num_Anal_Peaks := 0;                  FOR indx := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO                    IF NOT (Fixed_conc[indx]) THEN Num_Anal_Peaks := Num_Anal_Peaks + 1;                END; {if (fixed_bool)}            END;          index := I_Yes;          REPEAT            GetDialogItem(Get_Unanal, index, DType, DItem, tempRect);            temp := GetControlValue(ControlHandle(DItem));            index := index + 1;          UNTIL (temp <> 0) OR (index > I_No);          temp := index - I_Yes + 1;          numtostring(temp, str);          IF (temp = I_Yes) THEN            BEGIN              Unanal_Z_On := true;              index := I_Stoichiometry;              REPEAT                GetDialogItem(Get_Unanal, index, DType, DItem, tempRect);                temp1 := GetControlValue(ControlHandle(DItem));                index := index + 1;              UNTIL (temp1 <> 0) OR (index > I_Difference);              temp1 := index - I_Stoichiometry;              numtostring(temp1, str1);              IF (temp1 = 1) THEN Stoic_Diff := true              ELSE IF (temp1 = 2) THEN Stoic_Diff := False;              GetDialogItem(Get_Unanal, I_x11, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              Un_Z_Str := Strip_Trailing_Blanks(sTemp);              StringToNum(Un_Z_Str, Z_Unanal);              ZAF_Record^^.ZAF_data.Num_elements := ZAF_Record^^.ZAF_data.Num_elements + 1;              IF ZAF_Record^^.ZAF_data.Num_elements > 15 THEN                BEGIN                  ZAF_Record^^.ZAF_data.Num_elements := 15;                  putmessage('ZAF_Record^^.ZAF_data.Num_elements just tried to go over 15 at ~~3, I clamped it at 15',                             'Im in ZAF.P', '', '');                END;              index1 := ZAF_Record^^.ZAF_data.Num_elements;              ZAF_Record^^.ZAF_data.Atomic_Number[index1] := Z_Unanal;              Get_Energies(Z_Unanal);              ZAF_Record^^.ZAF_data.Atom_Wt[index1] := Atomic_Weight;              ZAF_Record^^.ZAF_data.Valence[index1] := 2;              ZAF_Record^^.ZAF_data.Siegbahn[index1] := 'U';            END;          tempRect := Get_Unanal^.portRect;          DisposeDialog(Get_Unanal);          FillWhiteSpace(tempRect);		  Xray_Data_Request := FALSE;        END;    END; { procedure D_Unanalyzed_Element }	{$S ZAF2}  PROCEDURE D_Select_Element;    CONST      I_Done                        = 1;      {I_Cancel                      = 2;}      Icb_1                         = 3;      Icb_20                        = 22;      Ist_1                         = 23;      Ist_20                        = 42;    VAR      ExitDialog                    : boolean;      tempRect                      : Rect;      DType                         : integer;      index, index_l, index_x       : integer;      DItem                         : Handle;      itemHit                       : integer;      temp                          : integer;      Do_substitute, reject         : boolean;      index_replace, X_temporaneous : integer;      str, str1, str2, str3, str4	: Str255;      {This is an update routine for non-controls in the dialog}      {This is executed after the dialog is uncovered by an alert}    PROCEDURE Refresh_Dialog;      BEGIN        SetPort(Get_Sel_Ele);        GetDialogItem(Get_Sel_Ele, I_Done, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN      Get_Sel_Ele := GetNewDialog(733, NIL, Pointer( - 1));      ShowWindow(Get_Sel_Ele);      SelectWindow(Get_Sel_Ele);      SetPort(Get_Sel_Ele);      Refresh_Dialog;      FOR index := Icb_1 TO Icb_20 DO { turn off and hide all the check boxes }        BEGIN          GetDialogItem(Get_Sel_Ele, index, DType, DItem, tempRect);          SetControlValue(ControlHandle(DItem), 0);          HideControl(ControlHandle(DItem));        END;      str := '              ';      FOR index := Ist_1 TO Ist_20 DO { turn off all the static text }        BEGIN          GetDialogItem(Get_Sel_Ele, index, DType, DItem, tempRect);          SetDialogItemText(DItem, str);        END;      {  upper limit is Ist_1 + Num_elements - 1  }      index_l := 0;      {index_x := 0;}      FOR index := Ist_1 TO Ist_1 + ZAF_standard[index_g]^^.ZAF_data.Num_elements - 1 DO       { load the static text items }        BEGIN          index_l := index_l + 1;          IF NOT (ZAF_standard[index_g]^^.ZAF_data.Siegbahn[index_l] = 'U    ') THEN            BEGIN              str := concat(A^.Sym[ZAF_standard[index_g]^^.ZAF_data.Atomic_Number[index_l]], ZAF_standard[index_g]^^.ZAF_data.                            Siegbahn[index_l]);              { put in here the standards info }              { index_x := index_x + 1;}              GetDialogItem(Get_Sel_Ele, index, DType, DItem, tempRect);              SetDialogItemText(DItem, str);              GetDialogItem(Get_Sel_Ele, index - 20, DType, DItem, tempRect); { Show corresponding check box }              ShowControl(ControlHandle(DItem));            END;        END;      ExitDialog := False;      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(Get_Sel_Ele, itemHit, DType, DItem, tempRect);        IF (itemHit = I_Done) THEN          BEGIN            ExitDialog := true;          END;        FOR index := Icb_1 TO Icb_1 + ZAF_standard[index_g]^^.ZAF_data.Num_elements - 1 DO         { Read all the check boxes }          BEGIN            IF (itemHit = index) THEN              BEGIN                temp := GetControlValue(ControlHandle(DItem));                SetControlValue(ControlHandle(DItem), (temp + 1) MOD 2);              END;          END;      UNTIL ExitDialog;      IF (total_stds = 0) THEN        BEGIN          ZAF_Record^^.SpectrumType := ZAF_standard[index_g]^^.SpectrumType;          ZAF_Record^^.E0 := ZAF_standard[index_g]^^.E0;          ZAF_Record^^.Take_Off_Angle := ZAF_standard[index_g]^^.Take_Off_Angle;          ZAF_Record^^.Instrument := ZAF_standard[index_g]^^.Instrument;          ZAF_Record^^.Faraday_current := ZAF_standard[index_g]^^.Faraday_current;          ZAF_Record^^.Live_Time := ZAF_standard[index_g]^^.Live_Time;          standard_ok := true;        END      ELSE        BEGIN          realtostring(ZAF_Record^^.Take_Off_Angle, 5, 3, str3);          realtostring(ZAF_standard[index_g]^^.Take_Off_Angle, 5, 3, str4);          IF {(ZAF_Record^^.SpectrumType[1] = ZAF_standard[index_g]^^.SpectrumType[1]) AND (ZAF_Record^^.SpectrumType[2] =             ZAF_standard[index_g]^^.SpectrumType[2]) AND }(ZAF_Record^^.E0 <= (ZAF_standard[index_g]^^.E0 + 0.001)) AND (             ZAF_Record^^.E0 >= (ZAF_standard[index_g]^^.E0 - 0.001)) AND (str3 = str4) THEN            standard_ok := true          ELSE standard_ok := False;        END;      IF NOT (standard_ok) THEN        BEGIN          str := concat('The spectrum types of the first standard and the failure are: ', ZAF_Record^^.SpectrumType, '  ',                        ZAF_standard[index_g]^^.SpectrumType);          realtostring(ZAF_Record^^.E0, 5, 5, str3);          realtostring(ZAF_standard[index_g]^^.E0, 5, 5, str4);          str1 := concat('The Beam Energies of the first standard and the failure are: ', str3, '  ', str4);          realtostring(ZAF_Record^^.Take_Off_Angle, 5, 5, str3);          realtostring(ZAF_standard[index_g]^^.Take_Off_Angle, 5, 5, str4);          str2 := concat('The Take_Off_Angles of the first standard and the failure are: ', str3, '  ', str4);          putmessage('The first standard and the one you just picked do not match', str, str1, str2);        END      ELSE        BEGIN { Standard_ok }          stds_found := 0;          X_temporaneous := Icb_1 + ZAF_standard[index_g]^^.ZAF_data.Num_elements - 1;          IF X_temporaneous > Icb_20 THEN            BEGIN              X_temporaneous := Icb_20;              putmessage('Index Problem, X_temporaneous ', '', '', '');            END;          FOR index := Icb_1 TO X_temporaneous DO { Read all the check boxes }            BEGIN              GetDialogItem(Get_Sel_Ele, index, DType, DItem, tempRect);              temp := GetControlValue(ControlHandle(DItem)); {If the box is checked temp=1}              IF temp = 1 THEN                BEGIN                  stds_found := stds_found + 1; { this is counting the # of elements chkd }                  IF stds_found > 30 THEN                    BEGIN                      putmessage('stds_found tried to go beyond 30, the limit, I have clamped to 30, BEWARE...', '', '', '');                      stds_found := 30;                    END;                  stds_picked[stds_found] := index - 2;                  IF (stds_picked[stds_found] < 1) OR (stds_picked[stds_found] > 15) THEN                    BEGIN                      beepbeep;                      numtostring(stds_picked[stds_found], str1);                      putmessage('Warning, index problem', 'stds_picked[stds_found] is', str1, 'I have arbitrarily made it 1...');                      stds_picked[stds_found] := 1;                    END;                  { Check for duplicate elements }                  Do_substitute := False;                  reject := False;                  FOR index_l := 1 TO total_stds DO                    BEGIN                      IF (ZAF_standard[index_g]^^.ZAF_data.Atomic_Number[stds_picked[stds_found]] < 3) OR (ZAF_standard[index_g]^^.                         ZAF_data.Atomic_Number[stds_picked[stds_found]] > 95) THEN                        BEGIN                          ZAF_standard[index_g]^^.ZAF_data.Atomic_Number[stds_picked[stds_found]] := 1;                          beepbeep;                          beepbeep;                          beepbeep;                        END;                      IF (ZAF_standard[index_g]^^.ZAF_data.Atomic_Number[stds_picked[stds_found]] = ZAF_Record^^.ZAF_data.                         Atomic_Number[index_l]) THEN                        BEGIN                          IF AnswerMessage('A standard for this element has already been selected.',                                           'Do you want to replace it with the current selection??? If you hit "Its OK"',                                           'then the new selection will become the standard for this element. ', A^.Sym[                                           ZAF_Record^^.ZAF_data.Atomic_Number[index_l]]) THEN                            BEGIN                              Do_substitute := true;                              index_replace := index_l;                              reject := False;                            END                          ELSE reject := true;                        END;                    END;                  IF NOT (reject) THEN                    BEGIN                      IF NOT (Do_substitute) THEN                        BEGIN                          total_stds := total_stds + 1;                          ZAF_Record^^.ZAF_data.Num_elements := total_stds;                          IF ZAF_Record^^.ZAF_data.Num_elements > 15 THEN                            BEGIN                              ZAF_Record^^.ZAF_data.Num_elements := 15;                              putmessage('ZAF_Record^^.ZAF_data.Num_elements just tried to go over 15 at ~~4, I clamped it at 15',                                         'Im in ZAF.P', '', '');                            END;                          index_replace := total_stds;                        END;                      ZAF_Record^^.ZAF_data.Atomic_Number[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Atomic_Number[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.Atom_Wt[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Atom_Wt[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.Valence[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Valence[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.Siegbahn[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Siegbahn[stds_picked[stds_found]];					  if (length(ZAF_standard[index_g]^^.Standard_Name) > 64) then					    ZAF_Record^^.ZAF_data.Std_Name[index_replace] := copy(ZAF_standard[index_g]^^.Standard_Name,1,64)					  else                        ZAF_Record^^.ZAF_data.Std_Name[index_replace] := ZAF_standard[index_g]^^.Standard_Name;                      ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Pure_Standard_Intensity[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.K_kRatio[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Atomic_Number[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.Peak_to_Bkg[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.K_kRatio[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.ChiSqr[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.ChiSqr[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.Err_Energy[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Err_Energy[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.L_kRatio[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.L_kRatio[stds_picked[stds_found]]; {lo ROI energy}                      ZAF_Record^^.ZAF_data.M_kRatio[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.M_kRatio[stds_picked[stds_found]]; {hi ROI energy}                      ZAF_Record^^.ZAF_data.Spare1[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Spare1[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.RawArea[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.RawArea[stds_picked[stds_found]];                      ZAF_Record^^.ZAF_data.Concentration[index_replace] := 					               ZAF_standard[index_g]^^.ZAF_data.Concentration[stds_picked[stds_found]];                      ZAF_Record^^.Quant_stds.Num_Std_Elems[index_replace] := 					               ZAF_standard[index_g]^^.Quant_stds.Num_Std_Elems[stds_picked[stds_found]];                      FOR index_x := 1 TO ZAF_Record^^.Quant_stds.Num_Std_Elems[index_replace] DO                        BEGIN                          ZAF_Record^^.Quant_stds.Z_of_Std_Elems[index_replace, index_x] := 						               ZAF_standard[index_g]^^.Quant_stds.Z_of_Std_Elems[1 {stds_picked[stds_found]}, index_x];                          ZAF_Record^^.Quant_stds.C_of_Std_Elems[index_replace, index_x] := 						               ZAF_standard[index_g]^^.Quant_stds.C_of_Std_Elems[1 {stds_picked[stds_found]}, index_x];                        END;                    END; { IF NOT (reject) }                END;            END;        END; { Standard_ok }      tempRect := Get_Sel_Ele^.portRect;      DisposeDialog(Get_Sel_Ele);      FillWhiteSpace(tempRect);    END;  {===========================================================}  FUNCTION ZAFFilter(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: integer): boolean;	CONST		I_Done                        = 1;		kVisualDelay				  = 8;		kReturnKey					  = $0D;		kEnterKey					  = $03;		kESCKey					      = $1B;    VAR      tempRect                      : Rect;	  DType                         : integer;	  DItem                         : Handle;      DoubleClick                   : boolean;      datalen                       : integer;      temp                          : longint;      str_3                         : STRING[3];      gotClicked                    : Cell;      SingleClick                   : boolean;	  finalTicks					: Longint;	  key							: Char;	      BEGIN      ZAFFilter := False;      Do_select := False;      standard_ok := False;      IF (theEvent.what = MouseDown) THEN        BEGIN          datalen := 3;          MyPt := theEvent.where;          GlobalToLocal(MyPt);          IF PtInRect(MyPt, Rect_I_List1) THEN            BEGIN              DoubleClick := LClick(MyPt, theEvent.modifiers, List_I_List1);              IF DoubleClick THEN                BEGIN                  str_3 := '   ';                  LGetCell(Pointer(ord(@str_3) + 1), datalen, List_I_List1^^.lastClick, List_I_List1);                  str_3 := Strip_Trailing_Blanks(str_3);                  StringToNum(str_3, temp);                  index_g := temp;                  itemHit := integer(temp + 100);                  ZAFFilter := true;                  Do_select := true;                END; { If DoubleClick }              SingleClick := LClick(MyPt, 0, List_I_List1); { single click handling }              IF SingleClick THEN                BEGIN                  gotClicked := LLastClick(List_I_List1);                  str_3 := '   ';                  LGetCell(Pointer(ord(@str_3) + 1), datalen, gotClicked, List_I_List1);                  str_3 := Strip_Trailing_Blanks(str_3);                  StringToNum(str_3, temp);                  index_g := temp;                  itemHit := integer(temp + 200);                  ZAFFilter := true;                  { Do_select := True;  }                END; { if SingleClick }            END;	{ IF PtInRect(MyPt, Rect_I_List1) }        END	{ IF (theEvent.what = MouseDown) }	  ELSE	    CASE theEvent.what OF			keyDown, Autokey:	{user pressed a key}			BEGIN				key := Char(BAnd(theEvent.message, charCodeMask));				IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN				  BEGIN				    GetDialogItem(theDialog, I_Done, DType, DItem, tempRect);							{invert the OK button for user feedback}					HiliteControl(ControlHandle(DItem), kControlButtonPart);					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(ControlHandle(DItem), 0);					ZAFFilter := TRUE;								{event's being handled}					itemHit := I_Done;								{return the default button}				  END;				END; { keyDown, Autokey }			END;{CASE theEvent.what}    END;  {===========================================================}  PROCEDURE D_Select_Standard;    CONST      I_OpenFile                    = 2;      I_Done                        = 1;    VAR      ExitDialog                    : boolean;      tempRect                      : Rect;      DType                         : integer;      index, indexx, nn             : integer;      DItem                         : Handle;      sTemp                         : Str255;      itemHit                       : integer;      dataBounds                    : Rect;      cSize                         : Point;      errcode		                : integer;      bytecount                     : longint;      mytype                        : OsType;      myprompt                      : Str255;      refNum_s                      : integer;      Std_Num                       : integer;      str, str1, str2				: Str255;    PROCEDURE Refresh_Dialog;      VAR        rTempRect                     : Rect;      BEGIN        SetPort(Get_Sel_Std);        LUpdate(Get_Sel_Std^.visRgn, List_I_List1);        rTempRect := Rect_I_List1;        InsetRect(rTempRect, - 1, - 1);        FrameRect(rTempRect);        GetDialogItem(Get_Sel_Std, I_Done, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    {This is a routine used to add strings to an existing list}    PROCEDURE Add_List_String(theString: Str255; theList: ListHandle);      VAR        theRow                        : integer;      BEGIN        IF (theList <> NIL) THEN          BEGIN            cSize.h := 0;            theRow := LAddRow(1, 200, theList);            cSize.v := theRow;            sTemp := theString;            LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);            LDraw(cSize, theList);          END;      END;		{ PROCEDURE Add_List_String }    BEGIN		{ PROCEDURE D_Select_Standard }      Get_Sel_Std := GetNewDialog(734, NIL, Pointer( - 1));      MoveWindow(Get_Sel_Std, MaxWindowRect.Left, MaxWindowRect.Bottom - 123, true);      ShowWindow(Get_Sel_Std);      SelectWindow(Get_Sel_Std);      SetPort(Get_Sel_Std);      SetRect(Rect_I_List1, 18, 20, 487, 115);      tempRect := Rect_I_List1;      tempRect.Right := tempRect.Right - 15;      IF (tempRect.Right <= (tempRect.Left + 15)) THEN tempRect.Right := tempRect.Left + 15;      InsetRect(tempRect, - 1, - 1);      FrameRect(tempRect);      InsetRect(tempRect, 1, 1);      SetRect(dataBounds, 0, 0, 1, 0);      cSize.h := tempRect.Right - tempRect.Left;      cSize.v := 0;      List_I_List1 := LNew(tempRect, dataBounds, cSize, 0, Get_Sel_Std, true, False, False, true);      List_I_List1^^.selFlags := lOnlyOne + lNoNilHilite;      Refresh_Dialog;      total_stds := 0;      ExitDialog := False;      REPEAT        ModalDialog(NewModalFilterProc(@ZAFFilter), itemHit);        GetDialogItem(Get_Sel_Std, itemHit, DType, DItem, tempRect);        IF (itemHit > 100) AND (itemHit < 200) THEN          BEGIN { Handle a Double Click }          END; { if (ItemHit > 100)...}        IF (itemHit = I_OpenFile) THEN          BEGIN            IF NOT Review_std_file THEN IF NOT citzaf_active THEN ZAF_Active := true;            Hall_Active := False;            Whole_Cell_Active := False;            Cliff_Lorimer_Active := False;            Standardless_Active := False;            IF (num_std_structures > 0) THEN              BEGIN                FOR indexx := 1 TO num_std_structures DO                  H_UnLock_Dispose(Handle(ZAF_standard[indexx]), 'ZAF_standard[indexx]');              END;            LdelRow(0, 1, List_I_List1);            {Open a file of ZAF standards}            mytype := 'MCAx';            myprompt := 'Open ZAF Standard File';              REPEAT              UNTIL (GetFileName(Std_File_name, mytype, mytype, myprompt) = true) OR (File_Cancel_Button = false);              IF (File_Cancel_Button = false) THEN 			  BEGIN				tempRect := Get_Sel_Std^.portRect;				DisposeDialog(Get_Sel_Std);				FillWhiteSpace(tempRect);				exit(D_Select_Standard);			  END;				Stds_VolRefNum := In_VolRefNum;				errcode := FSOpen_err(Std_File_name, Stds_VolRefNum, refNum_s, '');				IF errcode <> NoErr THEN putmessage('Error on Open', '', '', '');				IF errcode = fnOpnErr THEN putmessage(' File not open', '', '', '');				IF errcode = rfNumErr THEN putmessage(' Bad reference number', '', '', '');				IF errcode = extFSErr THEN putmessage(' External File System', '', '', '');            bytecount := 2;            errcode := FSRead_err(refNum_s, bytecount, @Std_Num, '');            Mouse_Active_Window;            IF FreeMem < SizeOf(ZAF_full) THEN              BEGIN                putmessage('Not enough memory available to run program at ZAF_standard', '', '', '');                Exit(D_Select_Standard);              END;            str2 := '  ';			LSetDrawingMode(false, List_I_List1);            FOR index := 1 TO Std_Num DO              BEGIN                Test_a_Handle(Handle(ZAF_standard[index]), 'ZAF_standard[index]');                ZAF_standard[index] := ZAF_fullHdl(NewHandle(SizeOf(ZAF_full)));                MoveHHi(Handle(ZAF_standard[index]));                HLock(Handle(ZAF_standard[index]));                ZAF_standard[index]^^.ZAF_data.Num_elements := 0;                FOR nn := 1 TO 15 DO                  BEGIN                    ZAF_standard[index]^^.ZAF_data.Atomic_Number[nn] := 0;                    ZAF_standard[index]^^.ZAF_data.Atom_Wt[nn] := 0.0;                    ZAF_standard[index]^^.ZAF_data.Pure_Standard_Intensity[nn] := 0.0;                    ZAF_standard[index]^^.ZAF_data.Concentration[nn] := 0.0;                  END;                bytecount := SizeOf(ZAF_full);                errcode := FSRead_err(refNum_s, bytecount, @ZAF_standard[index]^^, '');                { **** different **** }                IF NOT (ZAF_standard[index]^^.Standard_Name = '') THEN                  BEGIN                    numtostring(index, str1);                    str1 := Strip_Trailing_Blanks(str1);                    str := concat(str1, str2, ZAF_standard[index]^^.Standard_Name);                    Add_List_String(str, List_I_List1);                  END;				                  cSize.v := 0;                { LSetSelect(True, cSize, List_I_List1);  } { this selects the first entry }              END;			LSetDrawingMode(true, List_I_List1);            num_std_structures := {indexx} Std_Num;            errcode := FSClose(refNum_s);            errcode := FlushVol(NIL, Stds_VolRefNum);            Refresh_Dialog;          END;        IF (itemHit = I_Done) THEN          BEGIN            tempRect := Get_Sel_Std^.portRect;            DisposeDialog(Get_Sel_Std);            FillWhiteSpace(tempRect);            IF NOT Review_std_file THEN D_Unanalyzed_Element;            exit(D_Select_Standard);          END;        IF Do_select THEN        { a double click occurred indicating that element selection should be done }          BEGIN            IF NOT Review_std_file THEN D_Select_Element            ELSE See_the_Standard;            Refresh_Dialog;            Do_select := False;          END; { if Do_select... }      UNTIL ExitDialog;      tempRect := Get_Sel_Std^.portRect;      DisposeDialog(Get_Sel_Std);      FillWhiteSpace(tempRect);    END;  PROCEDURE ZAF_Help;    VAR      tempRect                      : Rect;      offset                        : integer;      Left                          : integer;      Top                           : integer;      n                             : integer;      G_Help                        : DialogPtr;      itemHit                       : integer;      DType                         : integer;      DItem                         : Handle;      ExitDialog                    : boolean;      str                           : Str255;        CONST      G_Accept                      = 1;    BEGIN      G_Help := GetNewDialog(433, NIL, Pointer( - 1));      ShowWindow(G_Help);      SelectWindow(G_Help);      SetPort(G_Help);      OutlineButton(G_Help, 1, 16); { outline the OK button }      SetFont('Monaco', 9, []);      offset := 12;      Left := 5;      Top := 15;      n := 0;      moveto(Left, Top);      DrawString('This Dialog will setup a ZAF matrix correction.  Prior to this step, the user must have:');      n := n + 1;      moveto(Left, Top + n * offset);      str := '1. Processed standards and created a file of ZAF standards for the analysis (ANALYSIS menu). ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '2. Run the simplex or least squares fitting routines on the WORK spectrum.';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'The results are currently added to the Analysis Results and will be saved with them. In ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'addition, a file containing all the correction factors for the analysis may be produced by ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'selecting the "Full ZAF Report File?" button. This is the ZAF Output file.';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := 'The "Setup an Analysis" button allows the user to select standards from a menu. After selecting';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'this button, select the "Open File" button on the lower window. The user should then select a ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'standards file to open. Standards in the file are listed by name and selecting a standard ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'will open a window showing the elements and x-ray lines available in that standard. Select ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'all appropriate elements and click "OK" in the upper window. Additional standards may be ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'selected or other standards files may be opened and included. When all standards have been';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'selected, click the "OK" button in the lower window. Another window for selecting an';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'unanalyzed element will appear. Select the appropriate information and click the "OK" ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'button. The original ZAF window will now be active. The setup is now complete and may be';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'saved for future use. These saved setup files may be selected by clicking the ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '"Use a Setup File" button.';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := '"Quantitate? - Work File" will allow the spectrum currently in WORK to be processed after the';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'peaks have been fitted by either the simplex or least squares routines. ';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := '본 IMPORTANT 본   A switch is set so that the ZAF procedure will be executed at the end';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'of each simplex or least squares procedure until the ZAF menu item is selected again.';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := '"Quantitate? - Fit Results" will process all the fitted data in a file of "Analysis Results".';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := ' ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);        IF (itemHit = G_Accept) THEN          BEGIN            ExitDialog := true;          END;      UNTIL ExitDialog;      DisposeDialog(G_Help);      beginupdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);    END; {End of ZAF_Help procedure}{$S ZAF5}  PROCEDURE D_DialZAF;    CONST      I_Accept                      = 1;      I_Cancel                      = 2;      I_Use_a_Setup_File            = 3;      I_Save_the_Setup_File         = 4;      I_Set_Up_an_Analysis          = 5;      I_NOT_Normalize               = 6;      I_Normalize                   = 7;      I_Help                        = 10;      I_Flowchart                   = 11;      I_Report_File                 = 12;	  I_Fit_Results					= 14;	  I_Work_File					= 15;    VAR      ExitDialog                    : boolean;      tempRect                      : Rect;      DType                         : integer;      index                         : integer;      DItem                         : Handle;      CItem			                : controlhandle;      itemHit                       : integer;      temp                          : integer;      Setup_File_name               : fnamestr;      refNum_su                     : integer;      errcode                       : integer;      bytecount                     : longint;      mytype                        : OsType;      myprompt                      : Str255;      ZAF_Trip_keeper               : boolean;	  str2                          : Str255;        LABEL      100;    PROCEDURE Refresh_Dialog;      VAR        rTempRect                     : Rect;      BEGIN        SetPort(Get_Dial_ZAF);        rTempRect := tempRect;        GetDialogItem(Get_Dial_ZAF, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);        {Draw a rectangle, Rectangle1  }        PenSize(3, 3);        {SetRect(tempRect, 118, 1, 266, 30);}		SetRect(tempRect, 206, 5, 358, 35);        FrameRect(tempRect);        PenSize(1, 1);        tempRect := rTempRect;      END;    PROCEDURE ZAF_Flowchart;      VAR        tempRect                      : Rect;        GetFlowChart                  : DialogPtr;        itemHit                       : integer;        DType                         : integer;        DItem                         : Handle;        ExitDialog                    : boolean;            CONST        G_Accept                      = 1;      BEGIN        GetFlowChart := GetNewDialog(438, NIL, Pointer( - 1));        ShowWindow(GetFlowChart);        SelectWindow(GetFlowChart);        SetPort(GetFlowChart);        OutlineButton(GetFlowChart, 1, 16); { outline the OK button }        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(GetFlowChart, itemHit, DType, DItem, tempRect);          IF (itemHit = G_Accept) THEN            BEGIN              ExitDialog := true;            END;        UNTIL ExitDialog;        DisposeDialog(GetFlowChart);        beginupdate(BackPlane);        DrawAxesFull;        Update_Full;        EndUpdate(BackPlane);        UpDate_SiLi_Window(SiLiWindow);      END; {End of FlowChart procedure}    BEGIN { procedure D_dialzaf }      ZAF_Trip_keeper := False;    100:      Get_Dial_ZAF := GetNewDialog(736, NIL, Pointer( - 1));      ShowWindow(Get_Dial_ZAF);      SelectWindow(Get_Dial_ZAF);      SetPort(Get_Dial_ZAF);      GetDialogItem(Get_Dial_ZAF, I_Normalize, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 0);      GetDialogItem(Get_Dial_ZAF, I_NOT_Normalize, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 1);	  	IF Do_Fit_Results = true Then begin      GetDialogItem(Get_Dial_ZAF, I_Work_File, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 0);	        GetDialogItem(Get_Dial_ZAF, I_Fit_Results, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 1);	END	  	ELSE begin      GetDialogItem(Get_Dial_ZAF, I_Work_File, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 1);	        GetDialogItem(Get_Dial_ZAF, I_Fit_Results, DType, DItem, tempRect);      SetControlValue(ControlHandle(DItem), 0);		END;		        IF NOT (ZAF_Trip_keeper) THEN        BEGIN          GetDialogItem(Get_Dial_ZAF, I_Save_the_Setup_File, DType, DItem, tempRect);          HiliteControl(ControlHandle(DItem), 255);          GetDialogItem(Get_Dial_ZAF, I_Accept, DType, DItem, tempRect);          HiliteControl(ControlHandle(DItem), 255);        END      ELSE        BEGIN          GetDialogItem(Get_Dial_ZAF, I_Use_a_Setup_File, DType, DItem, tempRect);          HiliteControl(ControlHandle(DItem), 255);          GetDialogItem(Get_Dial_ZAF, I_Set_Up_an_Analysis, DType, DItem, tempRect);          HiliteControl(ControlHandle(DItem), 255);        END;      Refresh_Dialog;      ExitDialog := False;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(Get_Dial_ZAF, itemHit, DType, DItem, tempRect);		CItem := ControlHandle(DItem);        IF (itemHit = I_Accept) THEN          BEGIN            { *** This should run the ZAF procedure *** }            ZAF_Direction := 3;            {FRAM;}            ZAF_Run := true;            ZAF_Record^^.Num_Fit_Peaks := 0;            ExitDialog := true;            Refresh_Dialog;          END;        IF (itemHit = I_Cancel) THEN          BEGIN            { *** Simply get out *** }            ZAF_Run := False; { Turn off auto ZAF }            tempRect := Get_Dial_ZAF^.portRect;            DisposeDialog(Get_Dial_ZAF);            FillWhiteSpace(tempRect);            exit(D_DialZAF);          END;        IF (itemHit = I_Flowchart) THEN          BEGIN            ZAF_Flowchart;            Refresh_Dialog;          END;        IF (itemHit = I_Help) THEN          BEGIN            ZAF_Help;            Refresh_Dialog;          END;        IF (itemHit = I_Use_a_Setup_File) THEN          BEGIN            { *** Go and open a setup file - select the file *** }            mytype := 'MCAz';            myprompt := 'Open ZAF Setup File';            IF (GetFileName(Setup_File_name, mytype, mytype, myprompt)) THEN              BEGIN                errcode := FSOpen_err(Setup_File_name, In_VolRefNum, refNum_su, '');                IF errcode <> NoErr THEN putmessage('Error on Open', '', '', '');                IF errcode = fnOpnErr THEN putmessage(' File not open', '', '', '');                IF errcode = rfNumErr THEN putmessage(' Bad reference number', '', '', '');                IF errcode = extFSErr THEN putmessage(' External File System', '', '', '');                OutlineButton(Get_Dial_ZAF, 1, 16); { outline the accept button }                bytecount := SizeOf(ZAF_full);                errcode := FSRead_err(refNum_su, bytecount, @ZAF_Record^^, '');              				GetDialogItem(Get_Dial_ZAF, I_Set_Up_an_Analysis, DType, DItem, tempRect);				HiliteControl(ControlHandle(DItem), 255);				GetDialogItem(Get_Dial_ZAF, I_Accept, DType, DItem, tempRect);				HiliteControl(ControlHandle(DItem), 0);				{ExitDialog:=TRUE;}				OutlineButton(Get_Dial_ZAF, 1, 16); { outline the accept button }				errcode := FSClose(refNum_su);				errcode := FlushVol(NIL, In_VolRefNum);			END;			OutlineButton(Get_Dial_ZAF, 1, 16); { outline the accept button }            Refresh_Dialog;          END;        IF (itemHit = I_Save_the_Setup_File) THEN          BEGIN            { *** Save the setup generated - do a putfile ***  }            {create a ZAF standard setup file}            Setup_File_name := 'ZAF_Setup.Sav';            IF (CreateFile(Setup_File_name, 'Create Setup File:') = true) OR (File_Cancel_Button = False) THEN;            IF (File_Cancel_Button) THEN              BEGIN                errcode := Create(Setup_File_name, Out_VolRefNum, 'DTSA', 'MCAz');                errcode := FSOpen_err(Setup_File_name, Out_VolRefNum, refNum_su, '');                IF errcode = NoErr THEN                  BEGIN                    errcode := setfpos_err(refNum_su, FSFromSTART, 0, '');                    bytecount := SizeOf(ZAF_full);                    errcode := FSWrite_err(refNum_su, bytecount, @ZAF_Record^^, '');                  END                ELSE putmessage('The file did not open', '', '', '');                Refresh_Dialog;              END;            OutlineButton(Get_Dial_ZAF, 1, 16); { outline the accept button }            errcode := FSClose(refNum_su);            errcode := FlushVol(NIL, Out_VolRefNum);            {   ExitDialog:=TRUE;}            Refresh_Dialog;          END;        IF (itemHit = I_Report_File) THEN { immediate action button }          BEGIN            ZAF_File_Name := 'ZAF Output'; { the user's choice replaces this }            IF (CreateFile(ZAF_File_Name, 'Save ZAF Data File:') = true) OR (File_Cancel_Button = False) THEN;            IF (File_Cancel_Button) THEN              BEGIN                ZAF_vol := Out_VolRefNum;                errcode := getvol(Save_Volume_Name, save_vol);                IF errcode = NoErr THEN errcode := SetVol(NIL, ZAF_vol);                IF errcode = NoErr THEN                  BEGIN                    Rewrite(refnum_Z, ZAF_File_Name);                    fndrInfo.fdcreator := 'MSWD';                    fndrInfo.fdtype := 'TEXT';                    fndrInfo.fdFlags := 0;                    errcode := setfinfo(ZAF_File_Name, ZAF_vol, fndrInfo);                    IF errcode <> NoErr THEN begin						numtostring(errcode,str2);						putmessage('setFinfo error just occured', 'in CreateFile ',str2, '');						close(refnum_Z);						errcode := FlushVol(NIL, ZAF_vol);						errcode := SetVol(Save_Volume_Name, save_vol);						exit(D_DialZAF);					end;                    save_ZAF := true;                  END;              END            ELSE save_ZAF := False;            Refresh_Dialog;          END; {if (ItemHit...}        IF (itemHit = I_Set_Up_an_Analysis) THEN          BEGIN            { *** Call the routine to select standards - should have all data *** }            num_std_structures := 0;            ZAF_Trip_keeper := true;            tempRect := Get_Dial_ZAF^.portRect;            DisposeDialog(Get_Dial_ZAF);            FillWhiteSpace(tempRect);            Review_std_file := False;            D_Select_Standard;            GOTO 100;          END;        IF (itemHit >= I_NOT_Normalize) AND (itemHit <= I_Normalize) THEN          BEGIN            FOR index := I_NOT_Normalize TO I_Normalize DO              BEGIN                GetDialogItem(Get_Dial_ZAF, index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;		          IF (itemHit >= I_Fit_Results) AND (itemHit <= I_Work_File) THEN          BEGIN            FOR index := I_Fit_Results TO I_Work_File DO              BEGIN                GetDialogItem(Get_Dial_ZAF, index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);            IF (itemHit = I_Fit_Results) then Do_Fit_Results := true            else Do_Fit_Results := False;          END;      UNTIL ExitDialog;      {Get results after dialog}      index := I_NOT_Normalize;      REPEAT        GetDialogItem(Get_Dial_ZAF, index, DType, DItem, tempRect);        temp := GetControlValue(ControlHandle(DItem));        index := index + 1;      UNTIL (temp <> 0) OR (index > I_Normalize);      temp := index - I_NOT_Normalize;      IF (temp = 1) THEN ZAF_Record^^.ZAF_data.Normalize_On := False      ELSE IF (temp = 2) THEN ZAF_Record^^.ZAF_data.Normalize_On := true;	        index := I_Fit_Results;      REPEAT        GetDialogItem(Get_Dial_ZAF, index, DType, DItem, tempRect);        temp := GetControlValue(ControlHandle(DItem));        index := index + 1;      UNTIL (temp <> 0) OR (index > I_Work_File);      temp := index - I_Fit_Results;      IF (temp = 1) THEN Do_Fit_Results := true      ELSE IF (temp = 2) THEN Do_Fit_Results := False;	        tempRect := Get_Dial_ZAF^.portRect;      DisposeDialog(Get_Dial_ZAF);      FillWhiteSpace(tempRect);	  	  If ((Do_Fit_Results = True) AND (ZAF_Run = true)) then	  ZAF_the_Fit;    END; { D_dialzaf 736 }{$S ZAF3}  PROCEDURE ZAF_Std_Help;    VAR      tempRect                      : Rect;      offset                        : integer;      Left                          : integer;      Top                           : integer;      n                             : integer;      G_Help                        : DialogPtr;      itemHit                       : integer;      DType                         : integer;      DItem                         : Handle;      ExitDialog                    : boolean;      str                           : Str255;        CONST      G_Accept                      = 1;    BEGIN      G_Help := GetNewDialog(433, NIL, Pointer( - 1));      ShowWindow(G_Help);      SelectWindow(G_Help);      SetPort(G_Help);      OutlineButton(G_Help, 1, 16); { outline the OK button }      SetFont('Monaco', 9, []);      offset := 12;      Left := 5;      Top := 15;      n := 0;      moveto(Left, Top);      DrawString(' ');      n := n + 1;      moveto(Left, Top + n * offset);      str := 'This window is for creating or adding to a data file of ZAF standards. ';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := 'In general, you will be processing the spectrum of a standard through a peak-fitting routine ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '(either the simplex or the least squares), performing the matrix correction on the standard ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'and storing the results in a file of ZAF standards which can be used by the ZAF in the ANALYSIS menu. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'This is not a file of spectra but a file of information needed for a ZAF analysis ';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := 'There are two steps that must be done prior to opening this window: ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '  1. The spectrum of the standard must be in WORK and the Experiment Header and Spectrum  ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'Header must be filled out. The Experiment Header has the beam voltage. The standard composition ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'must be entered in the Spectrum Header and the "Make This a Standard" button must be clicked. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'The comments field in the Spectrum Header will become the NAME of the standard inside the file. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'Be sure to attach the header to the spectrum in WORK before leaving this window. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '  NOTE: The take-off angle is defined in the detector geometry windows. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '2. Set up and run either the simplex or the least squares fitting routine. One or the other ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'must be selected for an analysis - THEY CANNOT BE MIXED. ';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := 'If you are starting a new standards file, select "Create a Standards File", otherwise select ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := '"Open a File of Standards" to open an existing standards file. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'Select "Run ZAF on Standard" and then select "Add Standard to the File" to store the data. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'The "OK" button will close this window and close the file. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'Repeat this procedure for each standard to be added to the file. You do not need to open it ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'each time this menu item is selected. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := ' ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);        IF (itemHit = G_Accept) THEN          BEGIN            ExitDialog := true;          END;      UNTIL ExitDialog;      DisposeDialog(G_Help);      beginupdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);    END; {End of ZAF_Std_Help procedure}  PROCEDURE See_the_Standard;			{ The handle for the selected standard is ZAF_standard[index_g]^^. }       VAR      tempRect                      : Rect;      offset                        : integer;      Left                          : integer;      Top                           : integer;      n                             : integer;      disp_std                      : DialogPtr;      itemHit                       : integer;      DType                         : integer;      index	                     	: integer;      DItem                         : Handle;      ExitDialog                    : boolean;      str, str1, str2, str3, str4, str5, str6, str7	: Str255;    CONST      G_Accept                      = 1;    BEGIN      disp_std := GetNewDialog(433, NIL, Pointer( - 1));      ShowWindow(disp_std);      SelectWindow(disp_std);      SetPort(disp_std);      OutlineButton(disp_std, 1, 16); { outline the OK button }      ChangeCursor(ArrowC);      SetFont('Monaco', 9, []);      offset := 12;      Left := 5;      Top := 15;      n := 0;      moveto(Left, Top);      DrawString(' ');      n := n + 1;      moveto(Left, Top + n * offset);      str := 'This window displays the data stored for a ZAF standard. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := concat('Standard name is ',ZAF_standard[index_g]^^.Standard_Name);      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := ' Element  X-ray line   k-ratio    Pure_Std_Int     Conc     Peak_Area    Valence';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      WITH ZAF_standard[index_g]^^, ZAF_data, Quant_stds DO        BEGIN          FOR index := 1 TO Num_elements DO            BEGIN              IF NOT (Siegbahn[index] = 'U    ') THEN                BEGIN                  str1 := A^.Sym[Atomic_Number[index]];                  str2 := Siegbahn[index];                  realtostring(K_kRatio[index], 5, 4, str3);                  realtostring(Pure_Standard_Intensity[index], 5, 4, str4);				  realtostring(Concentration[index], 5, 4, str5);				  realtostring(RawArea[index], 5, 4, str6);				  realtostring(Valence[index], 5, 1, str7);                  str := concat('   ', str1, '       ', str2, '       ', str3, '      ', str4, '    ',				  				str5, '    ',str6, '    ',str7);                  DrawString(str);                  n := n + 1;                  moveto(Left, Top + n * offset);                END;            END;		    n := n + 2;		    moveto(Left, Top + n * offset);			str := 'The elements in the standard are:';			DrawString(str);			n := n + 1;		    moveto(Left, Top + n * offset);			str := ' Element  Concentration';			DrawString(str);			n := n + 1;		    moveto(Left, Top + n * offset);						for index := 1 to Num_Std_Elems[1] do				begin				  numtostring(Z_of_Std_Elems[1,index],str1);				  realtostring(C_of_Std_Elems[1,index], 5, 4, str5);				  str := concat('   ',str1,'       ',str5);                  DrawString(str);                  n := n + 1;                  moveto(Left, Top + n * offset);				end;		  str := ' ';		  DrawString(str);		  n := n + 2;		  moveto(Left, Top + n * offset);		  if (Simplex_Run = true) then str := 'Peaks fit by Simplex'		  else if (ML_Run = true) then str := 'Peaks fit by Linear Least Squares';		  DrawString(str);		  n := n + 1;		  moveto(Left, Top + n * offset);		  realtostring(E0, 5, 2, str1);		  realtostring(Take_off_angle, 5, 2, str2);		  realtostring(Faraday_Current, 5, 2, str3);		  realtostring(Live_Time, 5, 2, str4);		  str := concat('Beam Voltage: ',str1,'   X-ray Emission Angle: ',str2);		  DrawString(str);		  n := n + 1;		  moveto(Left, Top + n * offset);		  str := concat('Faraday Current: ',str3,'   Live Time: ',str4);		  DrawString(str);        END;		{ WITH ZAF_standard[index_g]^^, ZAF_data, Quant_stds }	        REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(disp_std, itemHit, DType, DItem, tempRect);        IF (itemHit = G_Accept) THEN          BEGIN            ExitDialog := true;          END;      UNTIL ExitDialog;      DisposeDialog(disp_std);      beginupdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);    END;  PROCEDURE Review_standard;   {VAR}    BEGIN      Review_std_file := true;      D_Select_Standard;	  Review_std_file := False;    END; { PROCEDURE Review_standard }  PROCEDURE Std_display;    VAR      tempRect                      : Rect;      offset                        : integer;      Left                          : integer;      Top                           : integer;      n                             : integer;      G_Help                        : DialogPtr;      itemHit                       : integer;      DType                         : integer;      index	                        : integer;      DItem                         : Handle;      ExitDialog                    : boolean;      str, str1, str2, str3, str4	: Str255;    CONST      G_Accept                      = 1;    BEGIN      G_Help := GetNewDialog(433, NIL, Pointer( - 1));      ShowWindow(G_Help);      SelectWindow(G_Help);      SetPort(G_Help);      OutlineButton(G_Help, 1, 16); { outline the OK button }      ChangeCursor(ArrowC);      SetFont('Monaco', 9, []);      offset := 12;      Left := 5;      Top := 15;      n := 0;      moveto(Left, Top);      DrawString(' ');      n := n + 1;      moveto(Left, Top + n * offset);      str := 'This window displays the data computed for a ZAF standard. ';      DrawString(str);      n := n + 2;      moveto(Left, Top + n * offset);      str := ' Element  X-ray line   k-ratio     Pure_Standard_Intensity';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      WITH ZAF_Record^^, ZAF_data DO        BEGIN          FOR index := 1 TO Num_elements DO            BEGIN              IF NOT (Siegbahn[index] = 'U    ') THEN                BEGIN                  str1 := A^.Sym[Atomic_Number[index]];                  str2 := Siegbahn[index];                  realtostring(K_kRatio[index], 5, 4, str3);                  realtostring(Pure_Standard_Intensity[index], 5, 4, str4);                  str := concat('   ', str1, '      ', str2, '       ', str3, '      ', str4);                  DrawString(str);                  n := n + 1;                  moveto(Left, Top + n * offset);                END;            END;        END;      str := ' ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := ' If these results are satisfactory, you may add them to your standards file after ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      str := 'exiting from this window. ';      DrawString(str);      n := n + 1;      moveto(Left, Top + n * offset);      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);        IF (itemHit = G_Accept) THEN          BEGIN            ExitDialog := true;          END;      UNTIL ExitDialog;      DisposeDialog(G_Help);      beginupdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);    END; {End of Std_display procedure}  PROCEDURE D_Add_standard;    CONST      I_Done                        = 1;      I_Cancel                      = 2;      I_Run_ZAF_on_standard         = 3;      I_Add_standard_to_the_f       = 4;      I_Create_a_standards_fi       = 5;      I_Help                        = 7;	  I_File_open_text				= 8;      I_Open_a_file_of_standa       = 9;    VAR      ExitDialog                    : boolean;      tempRect                      : Rect;      DType                         : integer;      index, index1                 : integer;      DItem                         : Handle;      itemHit                       : integer;      errcode		                : integer;      bytecount                     : longint;      mytype                        : OsType;      myprompt                      : Str255;      refNum_s                      : integer;      Std_Num                       : integer;      ZAF_ready , std_added         : boolean;      str, str1						: Str255;    PROCEDURE Refresh_Dialog;      BEGIN        SetPort(Get_Add_std);        GetDialogItem(Get_Add_std, I_Done, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;    BEGIN      Get_Add_std := GetNewDialog(735, NIL {DRecPtr}, Pointer( - 1));      ShowWindow(Get_Add_std);      SelectWindow(Get_Add_std);      SetPort(Get_Add_std);      GetDialogItem(Get_Add_std, I_Add_standard_to_the_f, DType, DItem, tempRect);      HiliteControl(ControlHandle(DItem), 255);	  		GetDialogItem(Get_Add_std, I_File_open_text, DType, DItem, tempRect);		GetDialogItemText(DItem,str);		IF (file_ready) THEN		str1 := str		ELSE		str1 := '';		SetDialogItemText(DItem,str1);		      Refresh_Dialog;      ZAF_ready := False;      ExitDialog := False;	  std_added := False;      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(Get_Add_std, itemHit, DType, DItem, tempRect);        IF (itemHit = I_Cancel) THEN          BEGIN				ExitDialog := true;          END;        IF (itemHit = I_Done) THEN          BEGIN		    if not std_added then			  begin			    putmessage('You have not added the standard results to the ','standards file. ',							'If you wish to do so, click the 베dd Standard to the File button ',							'after leaving this window, otherwise click OK again.');				std_added := True;			  end			else			  begin				{ exit the dialog}				IF ZAF_Active THEN H_UnLock_Dispose(Handle(ZAF_Record), 'ZAF_Record in Add_standard in ZAF.p');				ZAF_Active := False;				ExitDialog := true;			  end;          END;        IF (itemHit = I_Help) THEN          BEGIN            ZAF_Std_Help;            Refresh_Dialog;          END;        IF (itemHit = I_Open_a_file_of_standa) THEN          BEGIN            {Open a file of ZAF standards}            mytype := 'MCAx';            myprompt := 'Open ZAF Standard File';            IF (GetFileName(Std_File_name, mytype, mytype, myprompt)) THEN              BEGIN                Stds_VolRefNum := In_VolRefNum;                file_ready := true;                IF (ZAF_ready) THEN                  BEGIN                    GetDialogItem(Get_Add_std, I_Add_standard_to_the_f, DType, DItem, tempRect);                    HiliteControl(ControlHandle(DItem), 0);                  END;                Refresh_Dialog;                {OutlineButton(Get_Add_std, 1, 16);} { outline the accept button }              END;          END;        IF (itemHit = I_Run_ZAF_on_standard) THEN          BEGIN            {Set the computation switch to 1 and execute the ZAF procedure}            ZAF_Record^^.ZAF_data.Unanal_Z_On := False;            save_ZAF := False;            ZAF_Direction := 1;            Get_ZAFInfo;            IF (good_data) AND (analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard) THEN              BEGIN                FRAM;               Std_display;                Refresh_Dialog;                ZAF_ready := true;                IF (file_ready) THEN                  BEGIN                    GetDialogItem(Get_Add_std, I_Add_standard_to_the_f, DType, DItem, tempRect);                    HiliteControl(ControlHandle(DItem), 0);                  END;              END;            {OutlineButton(Get_Add_std, 1, 16);} { outline the accept button }          END;        IF (itemHit = I_Add_standard_to_the_f) THEN          BEGIN            errcode := FSOpen_err(Std_File_name, Stds_VolRefNum, refNum_s, '');            bytecount := 2;            errcode := FSRead_err(refNum_s, bytecount, @Std_Num, '');            errcode := setfpos_err(refNum_s, FSFromSTART, 0, '');            Std_Num := Std_Num + 1;            FOR index1 := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO              BEGIN                ZAF_Record^^.Quant_stds.Num_Std_Elems[index1] := ZAF_Record^^.ZAF_data.Num_elements;                FOR index := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO                  BEGIN                    ZAF_Record^^.Quant_stds.Z_of_Std_Elems[index1, index] := ZAF_Record^^.ZAF_data.Atomic_Number[index];                    ZAF_Record^^.Quant_stds.C_of_Std_Elems[index1, index] := ZAF_Record^^.ZAF_data.Concentration[index];                  END;              END;            errcode := FSWrite_err(refNum_s, bytecount, @Std_Num, '');            {write ZAF_Record to the file}			std_added := True;            bytecount := SizeOf(ZAF_full);            errcode := setfpos_err(refNum_s, fsFromLEOF, 0, '');            errcode := FSWrite_err(refNum_s, bytecount, @ZAF_Record^^, '');            errcode := FSClose(refNum_s);            errcode := FlushVol(NIL, Stds_VolRefNum);            Refresh_Dialog;            {OutlineButton(Get_Add_std, 1, 16);} { outline the accept button }          END;        IF (itemHit = I_Create_a_standards_fi) THEN          BEGIN            {create a file of standards}            Std_File_name := 'ZAF_Standard.Sav';            IF (CreateFile(Std_File_name, 'Create File of Standards:') = true) OR (File_Cancel_Button = False) THEN;            IF (File_Cancel_Button) THEN              BEGIN                Stds_VolRefNum := Out_VolRefNum;                errcode := Create(Std_File_name, Stds_VolRefNum, 'DTSA', 'MCAx');                errcode := FSOpen_err(Std_File_name, Stds_VolRefNum, refNum_s, '');                IF errcode = NoErr THEN                  BEGIN                    file_ready := true;                    IF (ZAF_ready) THEN                      BEGIN                        GetDialogItem(Get_Add_std, I_Add_standard_to_the_f, DType, DItem, tempRect);                        HiliteControl(ControlHandle(DItem), 0);                      END;                    errcode := setfpos_err(refNum_s, FSFromSTART, 0, '');                    Std_Num := 0;                    bytecount := 2;                    errcode := FSWrite_err(refNum_s, bytecount, @Std_Num, '');                    errcode := FSClose(refNum_s);                    errcode := FlushVol(NIL, Stds_VolRefNum);                  END                ELSE putmessage('The file did not open', '', '', '');              END;            Refresh_Dialog;            {OutlineButton(Get_Add_std, 1, 16);} { outline the accept button }          END;      UNTIL ExitDialog;      {Get results after dialog}      tempRect := Get_Add_std^.portRect;      DisposeDialog(Get_Add_std);      FillWhiteSpace(tempRect);    END; { PROCEDURE D_Add_standard; Dialog(735)}  PROCEDURE start_stdless;    VAR      found                         : boolean;      replaced                      : boolean;      elem_found                    : boolean;      Line_found                    : integer;      Z_found                       : integer;      peak_label                    : ARRAY [0..3] OF Str_5;      nwin                          : integer;      f_of_chi                      : real;      Gen_Peak                      : real;      Mu_over_Rho                   : real;      line_wt                       : real;      index1                        : integer;      errcode                       : integer;      str, str1, str2, str4, str5	: Str255;      index                         : integer;      {=======================}        FUNCTION fChiChar(VPLine: real): real; {========================}      VAR        term                          : real;        term1                         : real;        cscTheta                      : real;        { 본벡egin fChi expression for characteristic radiation }      BEGIN        term1 := exp(1.65 * LN(ZAF_Record^^.E0));        cscTheta := 1 / Sin(ZAF_Record^^.Take_Off_Angle / 57.295779);        Mu_over_Rho := MassAbsCoeff(VPLine, Z_found);        term := 1.2E-6 * (term1 - exp(1.65 * LN(VPLine * 0.001)));        fChiChar := 1 / ((1 + term * Mu_over_Rho * cscTheta) * (1 + term * Mu_over_Rho * cscTheta));      END;    { 본벤nd fChi expression for characteristic radiation }    {=============================}    PROCEDURE SelectLine; { called for each window }    CONST      I_Stored                      = 1;      I_New	                        = 2;      VAR        index, index1                 : integer;		tempRect                      : Rect;		Lo_region, Hi_region		  : array [1..15] of real;		DItem                         : Handle;		DType                         : integer;		itemHit                       : integer;		ExitDialog					  : Boolean;      BEGIN {procedure SelectLine }      	 Xray_Data_Request := TRUE;        FOR index := 1 TO Number_of_Elements_Simplexed DO          BEGIN            found := False;            Get_Energies(periodic_picks[index]);   {  numtostring(nwin,str);     numtostring(periodic_picks[index],str1);     putmessage('The window number is ',str,' Z = ',str1);     Get_energies(periodic_picks[index]);}            IF (eV_Line[1] >= ROI^^.Peak[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND (eV_Line[1] <= ROI^^.Peak[nwin].Hi * Plt_Spec[10]^^.               Expt_Info.dE) THEN              BEGIN                Line_found := 1;                Z_found := periodic_picks[index];                found := true;				ZAF_Record^^.ZAF_data.Spare1[index] := 1;				Lo_region[index]  := ROI^^.Peak[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE;				Hi_region[index] := ROI^^.Peak[nwin].Hi * Plt_Spec[10]^^.Expt_Info.dE;              END            ELSE              IF (eV_Line[42] >= ROI^^.Peak[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND (eV_Line[42] <= ROI^^.Peak[nwin].Hi * Plt_Spec[10]^^.                 Expt_Info.dE) THEN                BEGIN                  Line_found := 2;                  Z_found := periodic_picks[index];                  found := true;				  ZAF_Record^^.ZAF_data.Spare1[index] := 1;				  Lo_region[index] := ROI^^.Peak[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE;				  Hi_region[index] := ROI^^.Peak[nwin].Hi * Plt_Spec[10]^^.Expt_Info.dE;                END              ELSE                IF (eV_Line[72] >= ROI^^.Peak[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND (eV_Line[72] <= ROI^^.Peak[nwin].Hi * Plt_Spec                   [10]^^.Expt_Info.dE) THEN                  BEGIN                    Line_found := 3;                    Z_found := periodic_picks[index];                    found := true;					ZAF_Record^^.ZAF_data.Spare1[index] := 1;					Lo_region[index] := ROI^^.Peak[nwin].Lo * Plt_Spec[10]^^.Expt_Info.dE;					Hi_region[index] := ROI^^.Peak[nwin].Hi * Plt_Spec[10]^^.Expt_Info.dE;                  END;            IF (found) THEN              BEGIN                elem_found := False;                replaced := False;                FOR index1 := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO                  BEGIN                    IF (Z_found = ZAF_Record^^.ZAF_data.Atomic_Number[index1]) THEN                      BEGIN                        elem_found := true;                        str1 := A^.Sym[Z_found];                        str2 := ZAF_Record^^.ZAF_data.Siegbahn[index1]; { stored x-ray line }                        str := peak_label[Line_found]; { new x-ray line found for element }                       (* str3 := concat('one x-ray line for the analysis of element ', str1, '. ');*)                        str4 := concat( str1, str2);                        str5 := concat(str1, str);                        (*IF AnswerMessage('Two principal lines of an element are being fitted, you must choose ', str3, str4, str5) *)						Get_Sel_Line := GetNewDialog(423, NIL, Pointer( - 1));						ShowWindow(Get_Sel_Line);						SelectWindow(Get_Sel_Line);						SetPort(Get_Sel_Line);						SetFont('Geneva', 12, [bold]);						GetDialogItem(Get_Sel_Line, I_Stored, DType, DItem, tempRect);						SetControlTitle(ControlHandle(DItem),str4);						GetDialogItem(Get_Sel_Line, I_New, DType, DItem, tempRect);						SetControlTitle(ControlHandle(DItem),str5);						SetFont('Monaco', 9, []);						ExitDialog := false;						REPEAT						  ModalDialog(NIL, itemHit);						  GetDialogItem(Get_Sel_Line, itemHit, DType, DItem, tempRect);						if (itemHit = I_New)                           THEN begin                          replaced := true;						  ExitDialog := true;						    end                        ELSE if (itemHit = I_Stored)						    THEN begin						replaced := False;						ExitDialog := true;						    end;						UNTIL ExitDialog;						DisposeDialog(Get_Sel_Line);						FillWhiteSpace(temprect); 						Mouse_Active_Window;						                      END;                    IF (replaced) THEN					  begin					    ZAF_Record^^.ZAF_data.Siegbahn[index1] := peak_label[Line_found];						ZAF_Record^^.ZAF_data.L_kRatio[index1] := Lo_region[index];						ZAF_Record^^.ZAF_data.M_kRatio[index1] := Hi_region[index];							replaced := False;					  end;                  END;                IF NOT (elem_found) THEN                  BEGIN                    Get_Energies(Z_found);                    ZAF_Record^^.ZAF_data.Num_elements := ZAF_Record^^.ZAF_data.Num_elements + 1;                    IF ZAF_Record^^.ZAF_data.Num_elements > 15 THEN                      BEGIN                        ZAF_Record^^.ZAF_data.Num_elements := 15;                        putmessage('ZAF_Record^^.ZAF_data.Num_elements just tried to go over 15 at ~~1, I clamped it at 15',                                   'Im in ZAF.P', '', '');                      END;                    ZAF_Record^^.ZAF_data.Atomic_Number[ZAF_Record^^.ZAF_data.Num_elements] := Z_found;                    ZAF_Record^^.ZAF_data.Concentration[ZAF_Record^^.ZAF_data.Num_elements] := 1.0;                    ZAF_Record^^.ZAF_data.Siegbahn[ZAF_Record^^.ZAF_data.Num_elements] := peak_label[Line_found];                    ZAF_Record^^.ZAF_data.Atom_Wt[ZAF_Record^^.ZAF_data.Num_elements] := Atomic_Weight;					ZAF_Record^^.ZAF_data.L_kRatio[ZAF_Record^^.ZAF_data.Num_elements] := Lo_region[index];					ZAF_Record^^.ZAF_data.M_kRatio[ZAF_Record^^.ZAF_data.Num_elements] := Hi_region[index];											                    FOR index1 := 1 TO Number_of_Elements_Simplexed DO                      BEGIN                        IF (Z_found = Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Atomic_Number) THEN                          ZAF_Record^^.ZAF_data.Valence[ZAF_Record^^.ZAF_data.Num_elements] := Plt_Spec[10]^^.SpectrumStuff.                                                                                               Spectrum_Info.Element_Info[index1].                                                                                               Valence;                      END;                  END; { IF NOT (elem_found) }              END; { IF (found) }          END; { FOR index := 1 TO Number_of_Elements_Simplexed DO }           Xray_Data_Request := FALSE;      END; { procedure SelectLine }    BEGIN {procedure start_stdless }	  if (NOT AnswerMessage('Standardless uses the cross-sections selected in Physics of Generate Bulk.',		 'Are these cross-sections OK??? If you hit "Its OK" then the calculation will proceed,',		 'otherwise, hit "Its not OK" and go to Generate to select a cross-section. ',		 'If you are in doubt, select the defaults for the cross-sections.')) Then		exit(start_stdless);		      IF NOT (SiLi_Response_Calculated) THEN        BEGIN          Detector_Efficiency(theBGRec, SiLi_Response_Calculated);        END;      good_data := true;      ZAF_Record^^.ZAF_data.Simplex_run := False;      ZAF_Record^^.ZAF_data.ML_run := False;      ZAF_Record^^.ZAF_data.Stoic_Diff := False; { unanalyzed element by stoichiometry only}      ZAF_Record^^.ZAF_data.standard := False;      ZAF_Record^^.ZAF_data.Unanal_Z_On := False;      FOR index := 1 TO 15 DO        ZAF_Record^^.ZAF_data.Valence[index] := zero;      IF (Simplex_Active) THEN        BEGIN          ZAF_Record^^.ZAF_data.Simplex_run := true;          peak_label[0] := 'U    ';          peak_label[1] := 'KA1  ';          peak_label[2] := 'LA1  ';          peak_label[3] := 'MA1  ';        END      ELSE        IF (LLSQ_Active) THEN          BEGIN            ZAF_Record^^.ZAF_data.ML_run := true;            peak_label[0] := 'U    ';            peak_label[1] := 'KA   ';            peak_label[2] := 'LA   ';            peak_label[3] := 'MA   ';          END        ELSE          BEGIN            putmessage(' WARNING!  This analysis cannot proceed. ', ' You have not set up a peak fitting procedure. ',                       ' You must pick the necessary regions of interest (ROIs) and then select',                       ' either the Simplex or Least Squares routines for peak fitting.');            exit(start_stdless);          END;      ZAF_Record^^.E0 := Plt_Spec[10]^^.Expt_Info.kV;      ZAF_Record^^.Take_Off_Angle := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;       { ZAF_Record^^.Faraday_current := (Plt_Spec[10]^^.SpectrumStuff.Acq_Info.Begin_Faraday +                                        Plt_Spec[10]^^.SpectrumStuff.Acq_Info.End_Faraday) / 2;        ZAF_Record^^.Live_Time := Plt_Spec[10]^^.SpectrumStuff.Acq_Info.Live_Time;}      IF (ZAF_Record^^.E0 <= 0.0) THEN        BEGIN          putmessage(' WARNING!  This analysis cannot proceed. ', ' The beam voltage ',                     ' contained in the experiment header is undefined.',                     ' Please edit the header to supply the information and then REFIT the spectrum.');          good_data := False;        END; { IF (good_data = true) then  BEGIN  realtostring(ZAF_Record^^.E0, 6, 4, str1);  str := concat('   Voltage = ',str1);  realtostring(ZAF_Record^^.Live_Time, 6, 4, str2);  str1 := concat('   Live-Time = ', str2);  realtostring(ZAF_Record^^.Faraday_current, 6, 4, str3);  str2 := concat('   Beam Current = ', str3);  str3 := concat(str,str1,str2);  if (AnswerMessage(str3,     'Are these values OK??? If you hit "Its OK" then this',     'spectrum will be computed as a standard provided the compositions ',     'are stored in the spectrum header; otherwise you MUST edit the headers.')) Then    good_data := TRUE    ELSE    good_data := FALSE;  END;  }      IF (good_data = true) THEN        BEGIN          ZAF_Direction := 3;          ZAF_Record^^.ZAF_data.Num_elements := 0;          Standardless_Active := true;          ZAF_Record^^.Num_Fit_Peaks := 0;			Xray_Data_Request := TRUE;          FOR nwin := 1 TO Number_of_PeakRois - 1 DO            BEGIN              SelectLine;            END;          Domega := Plt_Spec[10]^^.Expt_Info.Detector_Area / (Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance *                    Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance);                     FOR index := 1 TO ZAF_Record^^.ZAF_data.Num_elements DO            BEGIN              Z_found := ZAF_Record^^.ZAF_data.Atomic_Number[index];              ZAF_Record^^.ZAF_data.Fixed_conc[index] := False;              Get_Energies(Z_found);              Bulk_Physics_Constant := 1.0 / Atomic_Weight * 6.023E23 * 6.24196E9 * Domega / Pi4;  {1}  {realtostring(Bulk_Physics_Constant,8,-2,str);    numtostring(Z_found,str1); putmessage(' Bulk_Physics_Constant, Z & line  ',str,str1,ZAF_Record^^.ZAF_data.Siegbahn[index]);      Get_Energies(Z_found); }               FOR index1 := 1 TO 15 DO                BEGIN                  IF (Z_found = Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Atomic_Number) THEN                    ZAF_Record^^.ZAF_data.Valence[index] := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Valence;                END;     {2} { numtostring(index,str);       numtostring(Z_found,str1);       realtostring(ZAF_Record^^.ZAF_data.Valence[index], 6, 2, str2);       putmessage('Element number & Valence ',str,str1,str2);       realtostring(Bulk_Physics_Constant,8,-2,str);    numtostring(Z_found,str1); putmessage(' Bulk_Physics_Constant, Z & line  ',str,str1,ZAF_Record^^.ZAF_data.Siegbahn[index]);       		Get_Energies(Z_found); }              IF (ZAF_Record^^.ZAF_data.Siegbahn[index][1] = 'K') THEN                BEGIN                  f_of_chi := fChiChar(eV_Line[1]);                  IF (LLSQ_Active) THEN line_wt := 1.0                  ELSE line_wt := Wt_Line[1] / (Wt_Line[1] + Wt_Line[2]);                  Gen_Peak := Bulk_Physics_Constant * Integrate_Q_over_S(1) {* line_wt} * Backscatter(A^.edge[1] / 1000.0) * WK(                              Z_found) * SAK(Z_found);                  ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := Gen_Peak * f_of_chi * Det_Effic_P^[rinttol(eV_Line[1] /                                                                          Plt_Spec[10]^^.Expt_Info.dE)];    {3} { realtostring(f_of_chi,6,4,str);      realtostring(Gen_Peak,8,-2,str1);      realtostring(ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index],8,-2,str2);      putmessage('K fchi, generated, & pure_std ',str,str1,str2);}                END              ELSE                IF (ZAF_Record^^.ZAF_data.Siegbahn[index][1] = 'L') THEN                  BEGIN                    f_of_chi := fChiChar(eV_Line[42]);                    Gen_Peak := Bulk_Physics_Constant * Integrate_Q_over_S(2) {* Weight_LA1} * Backscatter(A^.edge[4] / 1000.0) * WL(                                Z_found) * SAL(Z_found);                    ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := Gen_Peak * f_of_chi * Det_Effic_P^[rinttol(eV_Line[42] /                                                                            Plt_Spec[10]^^.Expt_Info.dE)];   {4}  { realtostring(f_of_chi,6,4,str);      realtostring(Gen_Peak,8,-2,str1);      realtostring(ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index],8,-2,str2);      putmessage('L fchi, generated, & pure_std ',str,str1,str2);}                  END                ELSE                  IF (ZAF_Record^^.ZAF_data.Siegbahn[index][1] = 'M') THEN                    BEGIN                      f_of_chi := fChiChar((eV_Line[72] + eV_Line[73])/2);                      Gen_Peak := Bulk_Physics_Constant * Integrate_Q_over_S(3) {* Weight_MA1_2} * Backscatter(A^.edge[9] / 1000.0) *                                  WM(Z_found) * SAM(Z_found);                      ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index] := Gen_Peak * f_of_chi * Det_Effic_P^[rinttol((eV_Line[72] + eV_Line[73])/2 /                                                                              Plt_Spec[10]^^.Expt_Info.dE)];  {5}  {  realtostring(f_of_chi,6,4,str);      realtostring(Gen_Peak,8,-2,str1);      realtostring(ZAF_Record^^.ZAF_data.Pure_Standard_Intensity[index],8,-2,str2);      putmessage('M fchi, generated, & pure_std ',str,str1,str2);}                    END;            END;          ZAF_Run := true;          ZAF_Record^^.ZAF_data.Normalize_On := true;          ZAF_File_Name := 'ZAF Output'; { the user's choice replaces this }          IF (CreateFile(ZAF_File_Name, 'Save ZAF Data File:') = true) OR (File_Cancel_Button = False) THEN;          IF (File_Cancel_Button) THEN            BEGIN              ZAF_vol := Out_VolRefNum;			  errcode := getvol(Save_Volume_Name, save_vol);			  IF errcode = NoErr THEN errcode := SetVol(NIL, ZAF_vol);			  IF errcode = NoErr THEN			    BEGIN			  				  Rewrite(refnum_Z, ZAF_File_Name);				  fndrInfo.fdcreator := 'MSWD';				  fndrInfo.fdtype := 'TEXT';				  fndrInfo.fdFlags := 0;				  errcode := setfinfo(ZAF_File_Name, ZAF_vol, fndrInfo);				  IF errcode <> NoErr THEN begin					  numtostring(errcode,str2);					  putmessage('setFinfo error just occured', 'in CreateFile', ' start_stdless ', str2);					  close(refnum_Z);					  errcode := FlushVol(NIL, ZAF_vol);					  errcode := SetVol(Save_Volume_Name, save_vol);					  exit(start_stdless);				  end;				  save_ZAF := true;				END;            END          ELSE save_ZAF := False;          D_Unanalyzed_Element;        END; { IF (good_data = true) }        Xray_Data_Request := FALSE;    END; { procedure start_stdless }  PROCEDURE Read_KFJH_File;        VAR      conc1, ee0, phi, kex, eeg     : real;      run, k, zet1, zet2     		 : integer;      col_labels                    : STRING[40];      thefile1, outfile             : text;      str, str1, str2, str3, str4, str5, str6, str7	: Str255;    BEGIN      WITH ZAF_Record^^, ZAF_data DO        BEGIN          reset(thefile1, 'datafile.txt');          readln(thefile1, col_labels);          save_ZAF := False;          KFJH_Active := true;          Simplex_run := False;          ML_run := true;          Unanal_Z_On := true;          Stoic_Diff := False;          Faraday_current := 1.0;          Live_Time := 1.0;          Num_elements := 2;          ZAF_Direction := 1;          Rewrite(outfile, 'KFJH_binaries');          Xray_Data_Request := TRUE;          (* write col headers *)          writeln(outfile, 'Number', chr(9), 'Line', chr(9), 'At.No.1', chr(9), 'At.No.2', chr(9), 'Conc 1', chr(9), 'E0', chr(9),                  'Eq', chr(9), 'Psi', chr(9), 'k exp', chr(9), 'k calc', chr(9), 'Absorb', chr(9), 'At_Num', chr(9), 'Fluor', chr                  (9), 'f(chi)spec');          WHILE NOT Eof(thefile1) DO            BEGIN              readln(thefile1, run, k, zet1, zet2, conc1, ee0, phi, kex);              Atomic_Number[1] := zet1;              Atomic_Number[2] := zet2;              E0 := ee0;              Take_Off_Angle := phi;              {putmessage('Analyzed Z = ',A^.Sym[zet1],' Other Z = ',A^.Sym[zet2]);}              Get_Energies(zet1);              IF (k = 1) THEN                BEGIN                  Siegbahn[1] := 'K';                  eeg := A^.edge[1] / 1000.0; { K edge }                END;              IF (k = 2) THEN                BEGIN                  Siegbahn[1] := 'L';                  eeg := A^.edge[4] / 1000.0; { L edge }                END;              IF (k = 3) THEN                BEGIN                  Siegbahn[1] := 'M';                  eeg := A^.edge[9] / 1000.0; { M edge }                END;              Siegbahn[2] := 'U';              Concentration[1] := conc1;              Concentration[2] := 1 - conc1;              Atom_Wt[1] := Atomic_Weight;              Get_Energies(zet2);              Atom_Wt[2] := Atomic_Weight;              good_data := true;              FRAM;              (* write data *)              realtostring(conc1, 5, 4, str);              realtostring(ee0, 4, 4, str1);              realtostring(eeg, 5, 4, str2);              realtostring(phi, 5, 4, str3);              realtostring(kex, 5, 4, str4);              str5 := concat(str, chr(9), str1, chr(9), str2, chr(9), str3, chr(9), str4, chr(9));              realtostring(K_kRatio[1], 5, 4, str);              realtostring(L_kRatio[1], 5, 4, str1);              realtostring(M_kRatio[1], 5, 4, str2);              realtostring(ChiSqr[1], 5, 4, str3);              realtostring(Err_Energy[1], 5, 4, str7);              str6 := concat(str, chr(9), str1, chr(9), str2, chr(9), str3, chr(9), str7);              numtostring(run, str);              numtostring(k, str1);              numtostring(zet1, str2);              numtostring(zet2, str3);              str := concat(str, chr(9), str1, chr(9), str2, chr(9), str3, chr(9));              writeln(outfile, str, str5, str6);            END;        END; { WITH ZAF_Record^^, ZAF_data }      close(thefile1);      close(outfile);      ZAF_Active := False;      ZAF_Record^^.ZAF_data.ML_run := False;      ZAF_Record^^.KFJH_Active := False;      ZAF_Record^^.ZAF_data.Unanal_Z_On := False;      Xray_Data_Request := FALSE;    END; (*typeBLNKtype = record  E0 : real;                                 {beam voltage KeV}  Z,                                         {atomic number}  Q  : array [1..15] of integer; {byte ok} {valence for each element}  N,                                     {# elements in standard or unknown}  NX : integer;                          {# analyzed elements} end;ENERtype = record  L  : array [1..15] of integer;  {byte OK} {L = line code for x-ray lines                                               1=Ka,2=La,3=Ma,0=not analyzed}  E  : array [1..10, 1..15] of real;  {edge energy of each element}  EL : array [1..17,1..15] of real;   {x-ray line energy for each element} end;    FCDATA = record        BLNK   : BLNKtype;        ENER   : ENERtype;      end;*)  {$S ZAF4}  PROCEDURE FRAM;    TYPE      varray                        = ARRAY [1..15] OF real {double_t};      marray                        = ARRAY [1..15, 1..15] OF real {double_t};    VAR      eq                            : ARRAY [1..15] of real;      E                             : varray;      h                             : varray;      U                             : varray;      XKF                           : varray;      FCS                           : varray;      C                             : varray;      W                             : varray;      eta                           : ARRAY [1..15] of real;      XK                            : varray;      P                             : ARRAY [1..15,1..2] OF real {double_t};      R1                            : ARRAY [1..15,1..2] OF real {double_t};      OM                            : ARRAY [1..15,1..2] OF real {double_t};      AA                            : ARRAY [1..15] of real;      X                             : ARRAY [1..15,1..2] OF real {double_t};      FC                         	: varray;      BV                            : varray;      CN                            : varray;      Ek                            : varray;      unk_inten                     : varray;      AC                            : marray;      Fluor_AC                      : ARRAY [1..15, 1..15,1..2] OF real {double_t};      R                             : ARRAY [1..15, 1..15] of real;      StPwr                         : ARRAY [1..15, 1..15] of real;      LI                            : ARRAY [1..15] OF integer;      iwarn                         : ARRAY [1..15] OF integer;      KEY                           : ARRAY [1..15, 1..15] OF integer;      atno                          : ARRAY [1..15] of integer;      {  Ledge:  ARRAY [1..num_of_lines] OF integer; }      index                         : integer;      index1                        : integer;      index2                        : integer;      index3                        : integer;      k2                            : integer;      Num_an                        : integer;      co                            : real {double_t};      k, fswt                       : integer;      kk                            : integer;      Cosec, sine_beam              : real {double_t};      Total, Total_known            : real {double_t};      OM1                           : real {double_t};      ss                            : real {double_t};      rs                            : real {double_t};      as                            : real {double_t};      xu                            : real {double_t};      nu                            : real {double_t};      xuv                           : real {double_t};      at, E_line                    : real {double_t};      B1, E165, E_edge          	: real {double_t};	  peak_int						: real {double_t};      peak_label                    : Str_5;      line_pos_in_structure         : ARRAY [1..15] OF integer;      num_peaks                     : integer;      {Rec_num                       : longint;}      Analysis_Total                : real {double_t};      k_too_big                     : boolean;      errcode                       : integer;      z_temp						: real;      str, str1, str2, str3, str4, str5	: Str255;    BEGIN      spincursor;      ZAF_Record^^.KFJH_Active := False;      Xray_Data_Request := TRUE;      IF (Geom.Beam_Entry_Angle = 0.0) THEN Geom.Beam_Entry_Angle := 90.0;      IF NOT (ZAF_Record^^.KFJH_Active) THEN        BEGIN          ZAF_Record^^.E0 := Plt_Spec[10]^^.Expt_Info.kV;          IF (analysis_result^^.Fit_params.Number_of_Peaks <= 0) THEN            BEGIN              putmessage(' You must setup either the Simplex or LLSQ and do a fit before setting up a ZAF.',                         ' After doing the fit, return to the ZAF menu and click Accept ', '', '');              exit(FRAM);            END;        END;      IF (save_ZAF) THEN        BEGIN		errcode := getvol(Save_Volume_Name, save_vol);		IF errcode = NoErr THEN errcode := SetVol(NIL, ZAF_vol);		IF errcode = NoErr THEN		  BEGIN			  {Rec_num := $80000;}			  open(refnum_Z, ZAF_File_Name);			  Seek(refnum_Z, MaxLONGINT);		  END;        END;		Total := 0.0;        {numtostring(analysis_result^^.Fit_params.Number_of_Peaks, str);        putmessage(' num pks in results is', str, '', ''); }      IF NOT (ZAF_Record^^.KFJH_Active) THEN        BEGIN          num_peaks := analysis_result^^.Fit_params.Number_of_Peaks;          ZAF_Record^^.Num_Fit_Peaks := num_peaks; { Number of fitted peaks }          good_data := true;          IF (ZAF_Record^^.E0 <= 0.0) OR (analysis_result^^.SpectrumStuff.Acq_Info.Live_Time <= 0.0) OR (analysis_result^^.             SpectrumStuff.Acq_Info.Begin_Faraday <= 0.0) OR (analysis_result^^.SpectrumStuff.Acq_Info.End_Faraday <= 0.0) THEN            BEGIN              putmessage(' WARNING!  This analysis cannot proceed. ', ' The beam voltage, the beam current or ',                         'the live-time contained in the experiment or spectrum headers are undefined.',                         ' Please edit the headers to supply the information and then REFIT the spectrum.');              good_data := False;            END;		  for index1 := 1 to num_peaks do			analysis_result^^.Fit_Result.conc[index1] := -1.0;        END; { if NOT (ZAF_Record^^.KFJH_Active) }      IF (good_data) THEN        BEGIN          WITH ZAF_Record^^, ZAF_data DO            BEGIN              Analysis_Total := 0.0;              FOR index := 1 TO 15 DO begin                FOR index1 := 1 TO 15 DO                  KEY[index1, index] := 0;              end;              Cosec := 1.0 / Sin(Take_Off_Angle / 57.2958);              sine_beam := Sin(Geom.Beam_Entry_Angle / 57.2958);              IF (save_ZAF) THEN                BEGIN                  writeln(refnum_Z, 'Spectrum Label:  ', analysis_result^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);                  IF (Standardless_Active) THEN writeln(refnum_Z, 'Standardless Analysis');                  realtostring(Take_Off_Angle, 5, 2, str);                  writeln(refnum_Z, 'Take-Off Angle:  ', str);                  realtostring(Geom.Beam_Entry_Angle, 5, 2, str);                  writeln(refnum_Z, 'Beam Entry Angle:  ', str);                  realtostring(E0, 5, 2, str);                  writeln(refnum_Z, 'Beam keV:  ', str);                  writeln(refnum_Z, 'Number of elements: ', Num_elements);                END;              IF (Unanal_Z_On) THEN                BEGIN                  Num_an := Num_elements - 1; { Number of analyzed elements = number of elements }                  IF (save_ZAF) THEN writeln(refnum_Z, 'Number of analyzed elements is ', Num_an);                  atno[Num_elements] := Atomic_Number[Num_elements];                  BV[Num_elements] := Valence[Num_elements];                  XK[Num_elements] := zero;                  AA[Num_elements] := Atom_Wt[Num_elements];                END              ELSE Num_an := Num_elements;              {writeln(f,' Element Line    Standard        Standard Int    Unknown Int    k-Value');}              IF (save_ZAF) THEN writeln(refnum_Z, 'Elem & Line  k-Value    Conc.    AtNo Fact.    Absorp Fact    Fluor Fact.');              FOR index := 1 TO Num_an DO                BEGIN                  atno[index] := Atomic_Number[index];				  unk_inten[index] := 0.0;                  IF (ZAF_Direction = 3) THEN                    BEGIN                      ZAF_Run := true; { Turn on auto ZAF for unknowns }                      IF NOT (Fixed_conc[index]) THEN                        BEGIN                          IF (analysis_result^^.Fit_params.Fit_Procedure = 'Sm') THEN                            BEGIN                              ZAF_Record^^.ZAF_data.Simplex_run := true;                              IF (Siegbahn[index][1] = 'K') THEN peak_label := 'KA1  ';                              IF (Siegbahn[index][1] = 'L') THEN peak_label := 'LA1  ';                              IF (Siegbahn[index][1] = 'M') THEN peak_label := 'MA1  ';                            END                          ELSE                            IF (analysis_result^^.Fit_params.Fit_Procedure = 'ML') THEN                              BEGIN                                ZAF_Record^^.ZAF_data.ML_run := true;                                IF (Siegbahn[index][1] = 'K') AND									(Siegbahn[index][2] = 'A') THEN peak_label := 'KA   ';                                IF (Siegbahn[index][1] = 'L') AND									(Siegbahn[index][2] = 'A') THEN peak_label := 'LA   ';                                IF (Siegbahn[index][1] = 'M') AND									(Siegbahn[index][2] = 'A') THEN peak_label := 'MA   ';                              END;                          k2 := 0;						  ZAF_Record^^.Faraday_current := (analysis_result^^.SpectrumStuff.Acq_Info.Begin_Faraday +														  analysis_result^^.SpectrumStuff.Acq_Info.End_Faraday) / 2;						  IF (ZAF_Record^^.Faraday_current <= 0.0) THEN ZAF_Record^^.Faraday_current := 1.0;                          FOR index1 := 1 TO num_peaks DO                            BEGIN                              spincursor;								  						  IF (ZAF_Record^^.ZAF_data.Simplex_run = TRUE) THEN							BEGIN                              IF ((analysis_result^^.Fit_params.Atomic_Number[index1] = Atomic_Number[index]) AND							  	 (analysis_result^^.Fit_params.Siegbahn[index1] = peak_label) AND								 (analysis_result^^.Fit_params.Siegbahn[index1][4] <> 'D')) THEN                                BEGIN									  line_pos_in_structure[index] := index1;                                      (*  Select peaks here *)                                      FOR index2 := 1 TO num_peaks DO                                        BEGIN										  IF (analysis_result^^.Fit_params.Atomic_Number[index2] = Atomic_Number[index]) AND (											 analysis_result^^.Fit_Result.Err_or_Energy[index2] * 1000 < ZAF_Record^^.ZAF_data.											 M_kRatio[index]) AND (analysis_result^^.Fit_Result.Err_or_Energy[index2] * 1000 >											 ZAF_Record^^.ZAF_data.L_kRatio[index]) THEN											BEGIN											  k2 := k2 + 1;											  unk_inten[index] := unk_inten[index] + analysis_result^^.Fit_Result.Area[index2];											 END;											 										END; {for index2 := 1 TO Num_Peaks}																				(*  BOB, this is not doing what you want, I think..........?????????????	  IF k2 < ZAF_Record^^.ZAF_data.Spare1[index] THEN		BEGIN		  realtostring(ZAF_Record^^.ZAF_data.L_kRatio[index], 8, 3, str);		  realtostring(ZAF_Record^^.ZAF_data.M_kRatio[index], 8, 3, str1);		  numtostring(Atomic_Number[index], str2);		  str3 := concat('The ROI selected for element ', str2,						 ' must be at least as wide as for the standard.');		  putmessage(str3, ' The ROI for the standard is ', str, str1);		  IF (save_ZAF) THEN			BEGIN			  writeln(refnum_Z, '   ');			  close(refnum_Z);			END;		  exit(FRAM);		END; {if k2 < ZAF_Record^^.ZAF_data.Spare1}*)						END;					END {if ZAF_Record^^.ZAF_data.Simplex_run}				  ELSE					IF (ZAF_Record^^.ZAF_data.ML_run = TRUE) THEN					  BEGIN					  IF ((analysis_result^^.Fit_params.Atomic_Number[index1] = Atomic_Number[index]) AND (						 analysis_result^^.Fit_params.Siegbahn[index1][1] = peak_label[1]) AND (analysis_result^^.Fit_params.						 Ref_Index[index1] > 0) AND (analysis_result^^.Fit_params.Siegbahn[index1][4] <> 'D')) THEN						BEGIN					    find_peak_in_ROI(index, index1, peak_int);						if (ZAF_Record^^.ZAF_data.Spare1[index] > 0) AND							(peak_int <> 0.0) then						  begin							unk_inten[index] := peak_int;							line_pos_in_structure[index] := index1;						  end;						END;					  END;		{IF (ZAF_Record^^.ZAF_data.ML_run = TRUE)}				              			END; { for index1 := 1 to Num_Peaks }			{IF (ZAF_Record^^.ZAF_data.Simplex_run = TRUE) THEN}				  unk_inten[index] := unk_inten[index] / analysis_result^^.SpectrumStuff.Acq_Info.Live_Time /						ZAF_Record^^.Faraday_current;		if (unk_inten[index] <> 0.0) then		  begin			  XK[index] := unk_inten[index] / Pure_Standard_Intensity[index];			  Total := Total + XK[index];		  end;                    {  if (Standardless_Active) then         Std_Name[index] := 'No Standard';                      writeln(f,'   ',str1,'     ',Std_Name[index],'        ',str2,'     ',str3,'      ',str);            }                          BV[index] := Valence[index];                        END { if NOT (Fixed_conc[index] }                      ELSE { fixed concentrations }                        BEGIN                          XK[index] := Concentration[index];                          BV[index] := Valence[index];                          Siegbahn[index] := 'U';                        END;                    END; { IF (ZAF_Direction = 3) }                  IF (ZAF_Direction = 1) THEN                    BEGIN                      ZAF_Run := False; { Turn off auto ZAF for standards }                      XK[index] := Concentration[index];                      BV[index] := Valence[index];                    END;                  {writeln(f, ' Z = ', atno[index], ' k-value = ', XK[index], ' valence = ', BV[index]);}				                  END; { For index := 1 to Num_elements do...}							 if (Standardless_Active = true) then				begin				  k_too_big := False;				  for index1 := 1 to Num_an do				 if (XK[index1] > 1.0) then k_too_big := True;				  if (k_too_big) then					begin					 for index1 := 1 to Num_an do					 XK[index1] := XK[index1]/Total;					end;				end;				              FOR index := 1 TO Num_an DO                BEGIN                  Get_Energies(atno[index]);                  AA[index] := Atomic_Weight;                  Atom_Wt[index] := AA[index];                  peak_label := Siegbahn[index];                  IF peak_label[1] = 'K' THEN                    BEGIN                      LI[index] := 1;                      E[index] := eV_Line[1] / 1000.0; { K line }                      eq[index] := A^.edge[1] / 1000.0; { K edge }                    END                  ELSE                    IF peak_label[1] = 'L' THEN                      BEGIN                        LI[index] := 2;                        E[index] := eV_Line[42] / 1000.0; { L line }                        eq[index] := A^.edge[4] / 1000.0; { L edge }                      END                    ELSE                      IF peak_label[1] = 'M' THEN                        BEGIN                          LI[index] := 3;                          E[index] := eV_Line[72] / 1000.0; { M line }                          eq[index] := A^.edge[9] / 1000.0; { M edge }                        END                      ELSE                        IF peak_label[1] = 'U' THEN                          BEGIN                            LI[index] := 0;                          END;                  {writeln(f, Siegbahn[index]);}                  iwarn[index] := 0;                  IF (LI[index] > 0) THEN                    BEGIN                      U[index] := E0 / eq[index];     {if (save_ZAF) then begin     writeln(refnum_Z, ' Eo = ', E0, ' overvoltage is ', U[index]);     writeln(refnum_Z, index, ' A =', AA[index], ' E line=', E[index], ' E edge=', eq[index]);     end;}                      IF (U[index] < 1.5) THEN iwarn[index] := iwarn[index] + 1;                    END;                END; { FOR index := 1 TO Num_an DO }              E165 := fast_power(E0, 1.65);              FOR index1 := 1 TO Num_an DO                BEGIN                  IF (LI[index1] > 0) THEN                    BEGIN                      FOR index := 1 TO Num_elements DO                        BEGIN                          spincursor;                          {  Compute R and StPwr  }     					  z_temp := atno[index];                          rmczyfab(eq[index1], z_temp, AA[index], E0, R[index, index1], StPwr[index, index1], eta[index]);                          {writeln(f,'line ',index1,' matrix ', index, 'S = ', StPwr[index, index1], '  R = ', R[index, index1]);}                          Get_Energies(atno[index]);                          AC[index, index1] := MassAbsCoeff(E[index1] * 1000.0, atno[index]);                          {  Check for too near an edge - if so iwarn[index1] + 2;}                        END; { index }                      h[index1] := 1.2E-6 * (E165 - fast_power(eq[index1], 1.65));                      FC[index1] := (1 + h[index1] * AC[index1, index1] * Cosec * sine_beam);                      FC[index1] := FC[index1] * FC[index1];                      {writeln(f, ' F(chi) standard = ', FC[index1]);}                      IF (FC[index1] > 1.3333) THEN iwarn[index1] := iwarn[index1] + 4;                      { find characteristic fluorescence }                      CASE LI[index1] OF                        1:                          BEGIN                            co := 5.0;                            kk := 0;                          END;                        2:                          BEGIN                            co := 3.5;                            kk := 1;                          END;                        3:                          BEGIN                            co := 3.5;                            kk := 2;                          END;                        END; { case }                      FOR index := 1 TO Num_elements DO {begin checking for fluorescence}                        BEGIN                          fswt := 0;                          IF index1 <> index THEN {skip if same element}                            FOR k := 1 TO 2 DO {1 for K lines, 2 for L lines}                              BEGIN                                E_edge := 0.0;                                E_line := 0.0;                                {k2 := k * k;}                                IF ((k = 1) AND (atno[index] > 2)) THEN                                  BEGIN                                    E_edge := K_ABS_Handle^^.Data[atno[index]].value / 1000.0;         { if (save_ZAF) then          writeln(refnum_Z, 'E edge of K = ', E_edge, ' for Z = ', atno[index]);}                                    E_line := KA1_Handle^^.Data[atno[index]].Lamda / 1000.0;                                  END;                                IF ((k = 2) AND (fswt = 0) AND (atno[index] > 19)) THEN                                  BEGIN                                    E_edge := LIII_ABS_Handle^^.Data[atno[index]].value / 1000.0;          {if (save_ZAF) then                                  writeln(refnum_Z, 'E edge of LIII = ', E_edge);}                                    E_line := LA1_Handle^^.Data[atno[index]].Lamda / 1000.0;                                  END;                                IF (1.022 * E_edge < E0) AND (E_line > eq[index1]) AND (E_line <= eq[index1] + co) THEN                                  BEGIN                                    fswt := 1;                                    IF (KEY[index1, index] = 0) THEN                                      BEGIN                                        KEY[index1, index] := k + 2 * kk;                                        X[index,k] := E0 / E_edge;                                        FOR index3 := 1 TO Num_elements DO                                          BEGIN      { if (save_ZAF) then begin      numtostring( index3,str);      if not(answermessage('index3',str,'','')) then exit(FRAM);}     {writeln(refnum_Z,'index3 = ',index3,' Num_elements = ',Num_elements);     writeln(refnum_Z,' index = ',index,' E_line is ',E_line);     end;}                                            Get_Energies(atno[index3]);                                            Fluor_AC[index3, index, k] := MassAbsCoeff(E_line * 1000.0, atno[index3]);	{if (save_ZAF) then begin     numtostring(atno[index3],str2);     realtostring(E_line,4,-2,str);     realtostring(Fluor_AC[index3, index, k],6,-2,str1);     writeln(refnum_Z,str2,str,' Fl mu/rho = ',str1);	end;}         {if (save_ZAF) thenwriteln(refnum_Z,' fl absorb is Fluor_AC[index3, index] ',Fluor_AC[index3, index],' index ',index,' index3 ',index3);}                                          END;                                      END;                                  END;                              END; { FOR k := 1 TO 2 DO }                        END; { FOR index := 1 TO ZAF_Setup^^.Num_elements DO }                      FOR index := 1 TO Num_elements DO                        BEGIN                          IF (KEY[index1, index] > 0) THEN                            BEGIN                              k := KEY[index1, index];                              IF (odd(k)) THEN kk := 1                              ELSE kk := 2;                              P[index,kk] := 1.0;                              R1[index,kk] := 0.88;                              CASE kk OF                                1:                                  BEGIN                                    OM1 := 0.015 + 0.0327 * atno[index] - 6.4E-7 * fast_power(atno[index], 3);                                    OM1 := fast_power(OM1, 4);                                    OM[index, kk] := OM1 / (1 + OM1);                                    IF (k > 1) THEN                                      IF (k <> 5) THEN                                        BEGIN                                          P[index, kk] := 0.24;                                          R1[index, kk] := 0.75;                                        END                                      ELSE                                        BEGIN                                          P[index, kk] := 0.02;                                          R1[index, kk] := 0.5;                                        END;                                  END; { case 1:}                                2:                                  BEGIN                                    OM[index, kk] := exp(2.946 * LN(atno[index]) - 13.94);                                    IF (k = 2) THEN P[index, kk] := 4.2;                                    IF (k = 4) THEN R1[index, kk] := 0.75;                                    IF (k = 6) THEN                                      BEGIN                                        P[index, kk] := 0.02;                                        R1[index, kk] := 0.5;                                      END;                                  END; { case 2:}                                END; { Case }                            END; { end if ( key[index1,index] > 0 )... }                        END; { end index }                    END; { IF (LI[index1] > 0) }                END; { FOR index1 := 1 TO Num_an DO }              IF (ZAF_Direction <> 1) THEN ZAF_Direction := 3; { 3 iterations for an unknown }              Total_known := zero;              IF (ZAF_Direction <> 1) THEN                BEGIN                  Total := zero;                  Total_known := zero;                  FOR index1 := 1 TO Num_an DO                    BEGIN                      IF (Fixed_conc[index1]) THEN Total_known := Total_known + XK[index1]                      ELSE Total := Total + XK[index1];                    END;                  IF (Unanal_Z_On) THEN                    BEGIN                      C[Num_elements] := 1.0 - Total;                      Total := 1.0;                    END;                END              ELSE Total := 1.0;           { writeln(f, 'Total Concentration = ', Total);   writeln(f, 'Total Fixed Concentration = ', Total_known);}              FOR index := 1 TO Num_an DO                IF (Fixed_conc[index]) THEN                  BEGIN                    C[index] := XK[index];                    IF ((fixed_bool) AND (Num_Anal_Peaks = 1)) THEN C[index] := C[index] / (Total + Total_known);                    {writeln(f,' Initial k and C ',index,'  ',XK[index],'  ',C[index]);}                  END                ELSE                  IF ((fixed_bool) AND (Num_Anal_Peaks = 1)) THEN C[index] := XK[index] / (Total + Total_known)                  ELSE C[index] := XK[index] / Total * (1.0 - Total_known);              {if (Standardless_Active = true) then XK[index] := C[index];}              { 본본 Start the main iteration loop here 본본 }           { writeln(f, 'Total Concentration = ', Total);   writeln(f, 'Total Fixed Concentration = ', Total_known);}              FOR index2 := 1 TO ZAF_Direction DO                BEGIN                  FOR index1 := 1 TO Num_an DO                    BEGIN					  k := LI[index1];                      IF (LI[index1] > 0) THEN                        BEGIN                          ss := zero;                          rs := zero;                          as := zero;    { if (save_ZAF) then      writeln(refnum_Z, 'Analyzed elem is ',A^.Sym[atno[index1]]);}                          IF (KFJH_Active) THEN                            BEGIN                              C[1] := Concentration[1];                              C[2] := Concentration[2];                              Total := 1.0;                            END;                          FOR index := 1 TO Num_elements DO                            BEGIN                              spincursor;                              { writeln(f, ' elem ',atno[index],' conc is ',C[index]);}                              ss := ss + C[index] * StPwr[index, index1];                              rs := rs + C[index] * R[index, index1];                              as := as + C[index] * AC[index, index1];                            END;                          FCS[index1] := sqr(1 + h[index1] * as * Cosec * sine_beam);                          W[index1] := (R[index1, index1] * ss) / (StPwr[index1, index1] * rs);                          XKF[index1] := zero;                          FOR index := 1 TO Num_elements DO                            BEGIN                              IF (KEY[index1, index] > 0) THEN                                BEGIN                                  spincursor;								  k := KEY[index1, index];								  IF (odd(k)) THEN kk := 1								  ELSE kk := 2;{  FOR index3 := 1 TO Num_elements DO writeln(f,'mu/rho Fl ',index3,' ',index,' ',Fluor_AC[index3, index]);}                                  at := zero;                                  FOR index3 := 1 TO Num_elements DO                                    at := at + C[index3] * Fluor_AC[index3, index, kk];                                  xu := Cosec * as / at;                                  nu := (3.33E5 / (E165 - fast_power(eq[index1], 1.65))) / at;                                  xuv := Ln(xu+1) / xu + Ln(nu+1) / nu;  { if (save_ZAF) then begin   realtostring(at,6,-2,str);   realtostring(xu,6,-2,str1);   realtostring(nu,6,-2,str2);   realtostring(xuv,6,-2,str3);   writeln(refnum_Z,'at= ',str,' xu= ',str1, ' nu= ',str2,' xuv= ',str3);   realtostring(P[index, kk],6,-2,str);   realtostring(OM[index, kk],6,-2,str1);   realtostring(R1[index, kk],6,-2,str2);     writeln(refnum_Z, 'P= ', str, ' Omega= ', str1, ' R1= ', str2);   end;}                                  XKF[index1] := XKF[index1] + C[index] * P[index, kk] * OM[index, kk] / 2 * R1[index, kk] * fast_power(((X[                                                 index,kk] - 1) / (U[index1] - 1)), 1.67) * AA[index1] / AA[index] * Fluor_AC[index1,                                                 index, kk] / at * xuv;	{if (save_ZAF) then begin  											   realtostring(XKF[index1],6,-2,str3);   writeln(refnum_Z, A^.Sym[atno[index1]],' by ', A^.Sym[atno[index]], ' Fluor. correction = ',str3 );	end;	}										 												                                 END;                            END; { FOR index := 1 TO Num_an DO }{if (index2 = ZAF_Direction) thenbegin} { realtostring(XKF[index1],6,-2,str3);   writeln(refnum_Z, 'Fluor. correction = ',str3 );}   {writeln(f, 'Absorp. Correction is ', FC[index1] / FCS[index1]);end;}                          Ek[index1] := C[index1] / W[index1] * (1 + XKF[index1]) * FC[index1] / FCS[index1];						  						 {if ((index2 = ZAF_Direction) and (save_ZAF)) then writeln(refnum_Z, 'k-ratio = ', Ek[index1],' for element ',atno[index1]); writeln(f,'XK[index1] is ',XK[index1],' and C[index1] is ',C[index1]);}                          IF (KFJH_Active) THEN                            BEGIN                              L_kRatio[1] := FC[index1] / FCS[index1];                              M_kRatio[1] := 1.0 / W[index1];                              ChiSqr[1] := 1 + XKF[index1];                              K_kRatio[1] := Ek[index1];                              Err_Energy[1] := 1.0 / FCS[index1];                            END;                          IF (ZAF_Direction > 1) THEN                            CN[index1] := (XK[index1] * C[index1] * (1 - Ek[index1])) / (XK[index1] * (C[index1] - Ek[index1]) +                                          Ek[index1] * (1 - C[index1]));										  							{ realtostring(Ek[index1], 7, 4, str1);							 realtostring(CN[index1], 7, 4, str2);						  writeln(refnum_Z, A^.Sym[Atomic_Number[index1]], Siegbahn[index1],' k= ', str1,' C= ', str2);}			  							                          {writeln(f,'The new computed conc is ',CN[index1],' for elem ',atno[index1]);}                        END; { IF (LI[index1] > 0) }                    END; { FOR index1 := 1 TO Num_an DO }                  IF (ZAF_Direction > 1) THEN                    BEGIN                      Total := zero;                      FOR index1 := 1 TO Num_an DO                        BEGIN                          IF NOT (Fixed_conc[index1]) THEN                            BEGIN                              C[index1] := CN[index1];                              Total := Total + C[index1];                            END                          ELSE C[index1] := Concentration[index1];                        END;                      IF (Unanal_Z_On) THEN                        BEGIN                          { writeln(f,' Stoic_Diff boolean is ',Stoic_Diff);}                          IF (Stoic_Diff) THEN                            BEGIN                              C[Num_elements] := zero;                              FOR index := 1 TO Num_an DO                                BEGIN                                  B1 := C[index] / AA[index] * AA[Num_elements] * BV[index] / BV[Num_elements];                                  C[Num_elements] := C[Num_elements] + B1;                                END;                              Total := Total + C[Num_elements];                            END                          ELSE                            BEGIN                              C[Num_elements] := 1.0 - Total;                              Total := 1.0;                              { writeln(f,' The difference total is ',total,' C[Num_elements] is ',C[Num_elements]);}                            END;                        END; { writeln(f,'fixed_bool is ',fixed_bool,' and Num_Anal_Peaks is ',Num_Anal_Peaks);      if (index2 = ZAF_Direction) then writeln(f,' The total is ',total);}                      IF (index2 < ZAF_Direction) THEN                        FOR index := 1 TO Num_elements DO                          BEGIN                            IF ((fixed_bool) AND (Num_Anal_Peaks = 1)) THEN C[index] := C[index] / (Total + Total_known)                            ELSE IF NOT (Fixed_conc[index]) THEN C[index] := C[index] / Total * (1.0 - Total_known);                          END                      ELSE                        IF (index2 = ZAF_Direction) THEN                          BEGIN                            { writeln(f,'Elemental Concentrations in weight fraction');}                            IF (Normalize_On) THEN                              BEGIN                                FOR index := 1 TO Num_elements DO                                  BEGIN                                    IF ((fixed_bool) AND (Num_Anal_Peaks = 1)) THEN C[index] := C[index] / (Total + Total_known)                                    ELSE IF NOT (Fixed_conc[index]) THEN C[index] := C[index] / Total * (1.0 - Total_known);                                  END;                              END;                            FOR index1 := 1 TO Num_an DO                              BEGIN                                IF NOT (Fixed_conc[index1]) THEN                                  BEGIN                                    analysis_result^^.Fit_Result.conc[line_pos_in_structure[index1]] := (C[index1]);                                    Concentration[index1] := (C[index1]);                                    IF (save_ZAF) THEN                                      BEGIN                                        realtostring(XK[index1], 5, 4, str);                                        realtostring(Concentration[index1], 5, 4, str1);                                        realtostring(W[index1], 5, 4, str2);                                        realtostring(FC[index1] / FCS[index1], 5, 4, str3);                                        realtostring(1.0 + XKF[index1], 5, 4, str4);                                        str5 := concat(chr(9), str, chr(9), str1, chr(9), str2, chr(9), str3, chr(9), str4);                                        writeln(refnum_Z, A^.Sym[Atomic_Number[index1]], Siegbahn[index1], str5);                                      END;                                    Analysis_Total := Analysis_Total + Concentration[index1];                                  END                                ELSE                                  BEGIN                                    analysis_result^^.Fit_params.Number_of_Peaks := 										analysis_result^^.Fit_params.Number_of_Peaks + 1;                                    num_peaks := analysis_result^^.Fit_params.Number_of_Peaks;                                    analysis_result^^.Fit_params.Atomic_Number[num_peaks] := atno[index1];                                    analysis_result^^.Fit_Result.conc[num_peaks] := (Concentration[index1]);                                    analysis_result^^.Fit_params.Siegbahn[num_peaks] := 'Fixed';                                    analysis_result^^.Fit_Result.Err_or_Energy[num_peaks] := 0.0;									analysis_result^^.Fit_params.Ref_Index[num_peaks] := 10;                                    Concentration[index1] := (C[index1]);                                    Atomic_Number[index1] := atno[index1];                                    Siegbahn[index1] := 'Fixed';                                    IF (save_ZAF) THEN                                      BEGIN                                        realtostring(XK[index1], 5, 4, str);                                        realtostring(Concentration[index1], 5, 4, str1);                                       (* realtostring(W[index1], 7, 4, str2);                                        realtostring(FC[index1] / FCS[index1], 7, 4, str3);                                        realtostring(XKF[index1], 7, 4, str4);*)                                        str5 := concat(chr(9), str, chr(9), str1, chr(9) {, str2, chr(9), str3, chr(9), str4});                                        writeln(refnum_Z, A^.Sym[Atomic_Number[index1]], Siegbahn[index1], str5);                                      END;                                    Analysis_Total := Analysis_Total + Concentration[index1];                                  END;                              END;                            IF (Unanal_Z_On) THEN                              BEGIN                                IF (analysis_result^^.Fit_params.Atomic_Number[num_peaks] = atno[Num_elements]) THEN                                  BEGIN                                    analysis_result^^.Fit_Result.conc[num_peaks] := (C[Num_elements]);                                    Concentration[Num_elements] := (C[Num_elements]);                                    IF (Stoic_Diff) THEN analysis_result^^.Fit_params.Siegbahn[num_peaks] := 'Stoic'                                    ELSE analysis_result^^.Fit_params.Siegbahn[num_peaks] := 'Diff ';                                  END                                ELSE                                  BEGIN                                    analysis_result^^.Fit_params.Number_of_Peaks := num_peaks + 1;                                    index1 := analysis_result^^.Fit_params.Number_of_Peaks;                                    Concentration[Num_elements] := (C[Num_elements]);                                    analysis_result^^.Fit_Result.conc[index1] := Concentration[Num_elements];                                    analysis_result^^.Fit_params.Atomic_Number[index1] := atno[Num_elements];									analysis_result^^.Fit_params.Ref_Index[index1] := 10;                                    Atomic_Number[Num_elements] := atno[Num_elements];                                    IF (Stoic_Diff) THEN                                      BEGIN                                        analysis_result^^.Fit_params.Siegbahn[index1] := 'Stoic';                                        Siegbahn[Num_elements] := 'Stoic';                                      END                                    ELSE                                      BEGIN                                        analysis_result^^.Fit_params.Siegbahn[index1] := 'Diff ';                                        Siegbahn[Num_elements] := 'Diff';                                      END;                                  END;                                IF (save_ZAF) THEN                                  writeln(refnum_Z, A^.Sym[Atomic_Number[Num_elements]], Siegbahn[Num_elements], Concentration[                                          Num_elements]);                                Analysis_Total := Analysis_Total + Concentration[Num_elements];                              END;                            IF (save_ZAF) THEN                              BEGIN                                writeln(refnum_Z, '  ');                                realtostring(Analysis_Total, 5, 4, str2);                                writeln(refnum_Z, 'Analysis Total is ', str2);                              END;                          END;                    END                  ELSE                    BEGIN                      FOR index1 := 1 TO Num_elements DO                        BEGIN                          IF (LI[index1] > 0) THEN                            BEGIN                              C[index1] := Ek[index1];                              { writeln(f, ' stored value of k-ratio = ', C[index1]);}                              IF ((ZAF_Direction = 1) AND NOT (KFJH_Active)) THEN                                BEGIN                                  {writeln(f, ' Pure_Standard_Intensity[index1] ',Pure_Standard_Intensity[index1]);}                                  K_kRatio[index1] := (C[index1]);                                  Pure_Standard_Intensity[index1] := (Pure_Standard_Intensity[index1] / C[index1]);                                END;                            END;                        END;                      {IF ((ZAF_Direction = 1) AND NOT (KFJH_Active)) THEN Std_display;}                    END;                END;              IF (save_ZAF) THEN                BEGIN                  writeln(refnum_Z, '   ');                  close(refnum_Z);                  errcode := FlushVol(NIL, ZAF_vol);                  errcode := SetVol(Save_Volume_Name, save_vol);                END;    {  if ZAF_Direction = 1 then C[i] contains the k-values -    if ZAF_Direction = 3 then C[i] contains concentrations  }            END; {ZAF_Record^^.ZAF_data}          ChangeCursor(ArrowC);        END;	{ IF ( good_data) }        Xray_Data_Request := FALSE;    END; 	END.