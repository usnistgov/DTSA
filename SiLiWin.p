{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]}{*********************************} UNIT SiLiWin;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Icons, Controls, Events, Packages, Printing, StandardFile, Fonts, fenv, fp, Retrace, SegLoad, TextUtils, Dialogs, Windows, TextEdit, Spectrum_Structures, Declarations, INITIALIZE,  Global_Functions, Utilities,  SANDIA, MathWin, CurveFit,  Simplexer, Physics, Physics_Windows, Linear_Least_Squares,  Xray_Energies, Hall, Calibrate, XRay, CliffLor, ZAF, Connect, Qual_scan; PROCEDURE Get_Nearest_Peak;PROCEDURE Escape_Peaks;PROCEDURE Generate_Gaussians;PROCEDURE SetUp_ROIs;PROCEDURE D_Peak_Information;PROCEDURE D_Spectrum_CopyW;PROCEDURE D_Get_Reference_Dialog;PROCEDURE Update_SiLi_Thumbs;PROCEDURE Update_ID_Window(whichWindow: WindowPtr);PROCEDURE Update_Strip_Peak(whichWindow: WindowPtr);PROCEDURE Do_SiLi_Window(myEvent: EventRecord );PROCEDURE Do_ROI_Window(myEvent: EventRecord );PROCEDURE Do_ID_Window(myEvent: EventRecord );PROCEDURE Do_Strip_Peak(myEvent: EventRecord );(*PROCEDURE Init_ROI_Window;PROCEDURE Init_ID_Window;PROCEDURE Init_Strip_Peak;*)PROCEDURE Init_My_Windows;PROCEDURE Open_ROI_Window;PROCEDURE Open_ID_Window;PROCEDURE Open_Strip_Peak; PROCEDURE Close_ROI_Window(whichWindow: WindowPtr );PROCEDURE Close_Strip_Peak(whichWindow: WindowPtr );PROCEDURE ScaleUp;PROCEDURE ScaleDown;Procedure Do_A_Fit;Procedure Add_A_Fit;Procedure See_A_Fit;Procedure Rotate_W_R;{******************************} IMPLEMENTATION {**********************************}{$S SiLiWin1}VAR  R1control                    : ARRAY [1..2] OF ControlHandle;  { Strip dialog }  R2control                    : ARRAY [1..3] OF ControlHandle;  { Strip dialog }  Peak_Bi_Polar                : ControlHandle;  ID_CtrlHandle                : ControlHandle;  ID_CtrlHandle1               : ARRAY [1..6] OF ControlHandle;                    ID_R2Control                 : ARRAY [1..6] OF ControlHandle; { Radio button handles for group 2}  ID_R3Control                 : ARRAY [1..3] OF ControlHandle; { Radio button handles for group 3}  setup_vol                    : integer;  errcode                      : integer;  save_setup                   : Boolean;  TheGlobal_LValue             : integer;  The_Amplitude                : Real;  BigScale                     : Real;  Ref_Amp                      : Real;  theWidth                     : Real;  Autovalue                    : LongInt;  theValue                     : LongInt;  Number_of_Gaussians          : integer;(*!  MBGCtrlHandle                : ControlHandle;  *) {Control handle in ROI window stuff}  ROI_R1Control                : ARRAY [1..5] OF ControlHandle;    Peak_Control                 : ControlHandle;  UP_DowN					   : boolean; {[f+]}Procedure Rotate_W_R;VAR nn : integer; BgSub9,BgSub10	:	boolean;Begin	IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted THEN BgSub9 := true		Else BgSub9 := false;	IF Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted = True THEN BgSub10 := true		Else BgSub10 := false;	For nn := 1 to Maximum_Channels do col_1^[nn] := 0.0;                             { in case there is left over crap in the high channels }	     BlockMove(@Plt_spec[9]^^.S, @col_1^, Sizeof(col_1^));  	BlockMove(@Plt_spec[10]^^.S, @Plt_spec[9]^^.S, Sizeof(Plt_spec[9]^^.S)); 	 	BlockMove(@col_1^, @Plt_spec[10]^^.S, Sizeof(col_1^)); 		Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted := BgSub9;	Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted := BgSub10;	Refresh_ROIs;	UpDate_Max_Min(9);	Spectrum_Full[9] := True;	CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);	UpDate_Max_Min(10);	Spectrum_Full[10] := True;	CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);	Update_Full;	SpecWork_has_been_Changed := True;  	end;Procedure See_A_Fit;Begin		{ show OLD FIT has its own code}	Fit_Invisibly := False;    { The batch code in menus sets all booleans false but Plain_Options because	  the files are written when batch finishes...}		IF ((LLSQ_active OR Simplex_active) AND Results_Added)	THEN BEGIN	{see whole add fit or batch file...}	  IF (not Plain_Options) THEN	{no plain ascii from in D_Results_Options} 	  begin	{must make default ASCII file to review}	       See_Fit := true;	{Spread_boolean then saved,set F,restored in WriteFitResults}		   WriteFitResults;			   See_Fit := False;		 end;	 ReviewFitResults(PlainName, Plain_VolNum); {puts on display}   END	{ show the whole file... }   ELSE IF (LLSQ_active OR Simplex_active)   THEN BEGIN	{show one newest fit only}	  Putmessage('This fit has not been added to a results file.',				 'If you wish to do this, select ADD FIT when you`re finished examining it.','','');	  WriteOneFit;	{defines the global var filename and writes one fit text file}	  ReviewFitResults(fileName, MCA_Results_VolNum);   END	{show newest fit only}   ELSE IF  (MCA_file_boolean) THEN   BEGIN	{ show the fit file... }		  IF (not Plain_Options) THEN	{no plain ascii was made in D_Results_Options} 	  begin	{must make default ASCII file to review}	       See_Fit := true;	{Spread_boolean then saved;set F;restored in WriteFitResults}		   WriteFitResults;			   See_Fit := False;		 end;	 ReviewFitResults(PlainName, Plain_VolNum); {puts on display}   END	{ show the whole file... }   ELSE Putmessage('There is no active Results File to show.', 'Go to the FILE MENU Open Old Fit.',					 '', '');   Mouse_Active_Window;End;	{Procedure See_A_Fit;}Procedure Add_A_Fit;{DO NOT make errcode a local var!!!}				BEGIN		   Fit_Invisibly := False;		   Num_of_Fits := Num_of_Fits + 1;{Num_of_Fits for WriteFitResults;		   								   set to 0 in D_Results_options if Plain made; 										   incremented in Batch} 		  IF (not MCA_file_boolean) THEN		  {...MCA_Options_Boolean may be T from D_ResultsOptions but			     there is no binary fit file created with the name;		     otherwise keep adding to existing file}		  BEGIN			  MakeBinaryResults; {in CurveFit; If successful sets MCA_file_boolean true			  					  and  MCA_OptionsBoolean = false}		  END;		  		  {if there is a binary results file, append to it}		  IF ( MCA_file_boolean) THEN {it must be a file we want to append...}			  BEGIN	{ MakeBinaryResults was successful... }			  WriteBinaryResults; { see CurveFit: add one fit result }			  if errcode = noerr then results_added := true;{set false when next fit done}			  IF (Hall_Active) THEN WritetoHall			  Else if Cliff_Lorimer_Active then WritetoCL;			  {...D_Output_Options defines the file vars and creates these...}						{if you name a plain Add_Fit or Batch File in D_Results_options both Booleans			 are true. When batch is finished Plain_Boolean and Spread_Boolean			 are set false so the Batch file cannot be appended by accident.}			If ((Plain_Boolean and Plain_Options) or Spread_Boolean) then WriteFitResults;	{just one}				{if file not selected in D_Results_options its boolean(s) are set f there}		  END;	{IF ( MCA_file_boolean)...}	  End;	{Procedure Add_A_Fit;}			Procedure Do_A_Fit;VAR index                         : Integer;Begin   IF (NOT Simplex_active) AND (NOT LLSQ_active) THEN	 BEGIN	   BeepBeep;	   Putmessage('You have not chosen and setup a fitting procedure.',				  'Setup either Linear Least Squares (LLSQ) or the Simplex.', '', '');	   Fit_Invisibly := False;	 END;   IF (Elements_Chosen) THEN   BEGIN {IF (Elements_Chosen) ...}	   IF Simplex_active THEN	   BEGIN {IF Simplex_Active then... }		  { FOR Index := 1 TO 10 DO		   BEGIN			 Spectrum_Full[Index] := False;			 CheckItem(FullMenu, A^.C_Full[Index], Spectrum_Full[Index]);		   END;}		   Spectrum_Full[10] := True;		   CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);		   Spectrum_Full[9] := True;		   CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);		   Spectrum_Full[1] := True;		   CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);		 {  Auto_Scale_Display := False; }		   OffScreen_2_OnScreen;		   Markers;		   if (ZAF_Run) THEN			 IF (ZAF_Record^^.Num_Fit_Peaks > 0) then			   analysis_result^^.Fit_params.Number_of_Peaks := ZAF_Record^^.Num_Fit_Peaks;  		   Sequential_SIMPLEX;		   SetControlValue(AutoScale_CtrlHandle, 0); {Set AutoScale checkbox to off value}	   END { IF Simplex_Active then... }	   ELSE	   IF LLSQ_active THEN	   BEGIN			  if (ZAF_Run) THEN			    IF (ZAF_Record^^.Num_Fit_Peaks > 0) then			   analysis_result^^.Fit_params.Number_of_Peaks := ZAF_Record^^.Num_Fit_Peaks;  			 Do_LLS_Fit;	   END;     	   Results_Added := False;	   {is_batch := false;}	{this is set by calling routine}  		  ChangeCursor(ArrowC);	   IF (Hall_Active) THEN	   begin			Do_Hall_Quant;			if (not is_batch) then Show_One_Hall;	   end	   ELSE IF Cliff_Lorimer_Active then	   begin			Do_CL_Quant;			if (not is_batch) then CLResults(true);	{show the one cl result} 				   end	{IF Cliff_Lorimer_Active}	   ELSE IF (ZAF_Run) THEN FRAM { auto run the ZAF }	   ELSE IF (CitZAF_Run) THEN aSpectrum_Handler_1;   END; {IF (Elements_Chosen)... }   Mouse_Active_Window; End;	{Procedure Do_A_Fit}FUNCTION Select_Scale(scal_Value : real): real;	VAR		val1, val2, Iscal_value			: longint;		ch_len, indx_z					: integer;		value_stng						: Str255;			BEGIN		Iscal_value := rinttol(scal_value);		NumToString(Iscal_value, value_stng);		ch_len := Ord(value_stng[0]) - 1;		val1 := 1;		for indx_z := 1 to ch_len do			val1 := val1 * 10;		val2 := Iscal_value DIV val1;		UP_DowN := true;		Select_Scale := val2 * val1;	END;PROCEDURE  ToggleAutoScale;VAR IconRect					  : Rect;index                         : integer;  BEGIN   SetControlValue(AutoScale_CtrlHandle, theValue); {Set AutoScale checkbox to new value}   Autovalue := GetControlValue(AutoScale_CtrlHandle);     IF Autovalue = 1 THEN	 BEGIN	   Auto_Scale_Display := True;	   if not Bipolar_Display then	   begin	   if not OptionKeyDown then  	   For index := 1 to 8 do	   begin	   if (Spectrum_Full[index]) then	   WITH Plt_Spec[index]^^ DO BEGIN { set "top" max and min to be the plotting max, min }		 V_Scale_Top :=  SpectrumStuff.Spectrum_Info.Maximum_Counts;		 V_Scale_Bottom :=  0 {SpectrumStuff.Spectrum_Info.Minimum_Counts};	   END;	   leave;	  end;	   if not OptionKeyDown then  	   if Spectrum_Full[9] then	   WITH Plt_Spec[9]^^ DO BEGIN { set "9" max and min to be the plotting max, min }		 V_Scale_Top :=  SpectrumStuff.Spectrum_Info.Maximum_Counts;		 V_Scale_Bottom :=  0 {SpectrumStuff.Spectrum_Info.Minimum_Counts};	   END;	   if not OptionKeyDown then  	   if Spectrum_Full[10] then	   WITH Plt_Spec[10]^^ DO BEGIN { set "10" max and min to be the plotting max, min }		 V_Scale_Top :=  SpectrumStuff.Spectrum_Info.Maximum_Counts;		 V_Scale_Bottom :=  0 {SpectrumStuff.Spectrum_Info.Minimum_Counts};	   END;	   end;	 END;   IF Autovalue = 0 THEN	 BEGIN	   Auto_Scale_Display := False;	   V_Scale_Top := Select_Scale(V_Scale_Top);	 END;   Update_Full;   GetPort(GrafPtr(SavePort));     SetPort(SiLiWindow);      Setrect(IconRect, 475, 16, 507, 49); {Position of the up Icon}   InValRect(IconRect);   Setrect(IconRect, 475, 49, 507, 81); {Position of the down Icon}   InValRect(IconRect);   SetPort(GrafPtr(SavePort));END;PROCEDURE ScaleUp;Begin   if Auto_Scale_Display then      begin	  theValue := (theValue + 1) MOD 2;      ToggleAutoScale;	  UP_DowN := false;     end;	 if UP_DowN then   		V_Scale_Top := V_Scale_Top / 2  	 else   		V_Scale_Top := Select_Scale(V_Scale_Top) / 2;   IF Bipolar_Display THEN V_Scale_Bottom := V_Scale_Bottom / 2   ELSE V_Scale_Bottom := zero;   Scale_Changed_Event := True;   V_Scale_Top_Arrow := V_Scale_Top; { Holding variable for scrollbar use }   V_Scale_Bottom_Arrow := V_Scale_Bottom; { Holding variable for scrollbar use }   SetControlValue(Vertical_SiLi_CtrlHandle, 500); {Put scroll thumb in middle}   Update_Full;End;PROCEDURE ScaleDown;Begin   if Auto_Scale_Display then      begin	  theValue := (theValue + 1) MOD 2;      ToggleAutoScale;	  UP_DowN := false;     end;	 if UP_DowN then   		V_Scale_Top := V_Scale_Top * 2  	 else   		V_Scale_Top := Select_Scale(V_Scale_Top) * 2;   IF Bipolar_Display THEN V_Scale_Bottom := V_Scale_Bottom * 2   ELSE V_Scale_Bottom := zero;						     Scale_Changed_Event := True;   V_Scale_Top_Arrow := V_Scale_Top; { Holding variable for scrollbar use }   V_Scale_Bottom_Arrow := V_Scale_Bottom; { Holding variable for scrollbar use }   SetControlValue(Vertical_SiLi_CtrlHandle, 500); {Put scroll thumb in middle}   Update_Full;End;  PROCEDURE Generate_Gaussians;    VAR      K, i, j, JJ                   : Integer;      E, SIGSQ, DELESQ, YE          : Real;      Switch                        : ARRAY [1..10] OF Integer;    BEGIN      i := 0;      FOR JJ := 1 TO 10 DO        Switch[JJ] := 0;      FOR K := 1 TO 10 DO        BEGIN          IF (Gaussian_Energy[K] <> 0.0) AND (Gaussian_Amplitude[K] <> 0.0) THEN i := i + 1;          IF Gaussian_Width[K] > 0.0 THEN Switch[i] := 1;        END;      Number_of_Gaussians := i;             For k := 1 to Maximum_Channels do Gen_P^[k] := 0.0;      FOR j := 1 TO Spectrum_Size DO        BEGIN          E := j * Plt_spec[10]^^.Expt_Info.dE;          FOR JJ := 1 TO Number_of_Gaussians DO            BEGIN              IF Switch[JJ] = 0 THEN			  			  begin				if Ge_Active then SIGSQ := (2.5 * (Gaussian_Energy[JJ] - 5895.0) + 				        theBGRec^^.Si_Resolution * theBGRec^^.Si_Resolution) / (2.354825 * 2.354825)				else if WDS_Active then SIGSQ := theBGRec^^.WDS_Resolution * theBGRec^^.WDS_Resolution 				else {if Si_Active then} SIGSQ := (2.5 * (Gaussian_Energy[JJ] - 5895.0) + 				         theBGRec^^.Si_Resolution * theBGRec^^.Si_Resolution) / 						 (2.354825 * 2.354825);              end; 			  			  IF Switch[JJ] = 1 THEN 			  begin				if Ge_Active then SIGSQ := (Gaussian_Width[JJ] / 2.354825) * (Gaussian_Width[JJ] / 2.354825)				else if WDS_Active then SIGSQ := theBGRec^^.WDS_Resolution * theBGRec^^.WDS_Resolution 				else {if Si_Active then} SIGSQ := (Gaussian_Width[JJ] / 2.354825) * (Gaussian_Width[JJ] / 2.354825);              end;			  			                DELESQ := (E - Gaussian_Energy[JJ]) * (E - Gaussian_Energy[JJ]);              YE := Gaussian_Amplitude[JJ] * exp( - 0.5 * DELESQ / SIGSQ);        { We do not want Gaussian_Amplitude[jj]/Sqrt(2*pi*SigSq)*dE term for          manually entered Gaussians where we want to specify the number of         counts in the peak channel }               Gen_P^[j] := Gen_P^[j] + YE;            END;        END;      Spectrum_Full[9] := True;      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);    END; { of proc Generate_Gaussians }  {=================================}  PROCEDURE D_Peak_Information;        CONST      Peak_Info_Proceed             = 1;      Peak_Info_Cancel              = 2;      Peak_Info_Defaults            = 49;      Peak_Info_Reset_MnK 			= 48;        Peak_Info_Static_Text         = 3;      Peak_Info_Amp                 = 4;      Peak_Info_Energy_keV         = 5;      Peak_Info_Peak                = 6;      Peak_Info_Peak7               = 7;      Peak_Info_Peak9               = 8;      Peak_Info_Peak11              = 9;      Peak_Info_Peak13              = 10;      Peak_Info_Peak15              = 11;      Peak_Info_Peak17              = 12;      Peak_Info_Peak19              = 13;      Peak_Info_Peak21              = 14;      Peak_Info_Width_eV           = 15;      Peak_Info_Peak24              = 16;    VAR      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      Index                         : Integer;      DItem                         : Handle;      CItem			                : ControlHandle;      sTemp                         : Str255;      itemHit                       : Integer;      nn                      		: Integer;      str   						: str255;	  Peak_ExitDialog               : Boolean;	  SIGSQ							: real;    LABEL      100;    BEGIN      GetSelection := GetNewDialog(402, NIL, pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);        GetDialogItem(GetSelection, Peak_Info_Proceed, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);		{GenFromWork;}		{Load theGenRec from WORK}    100:	(*      GetDialogItem(GetSelection, Peak_Info_Add_Incomplete_Charge, DType, DItem, tempRect);       CItem := pointer(DItem);      SetControlValue(CItem, 1);    *)      FOR Index := 1 TO 10 DO        BEGIN          GetDialogItem(GetSelection, A^.Peak_Info_Width[Index], DType, DItem, tempRect);          RealToString(Gaussian_Width[Index], 3, 2, str);          SetDialogItemText(DItem, str);          GetDialogItem(GetSelection, A^.Peak_Info_Amplitude[Index], DType, DItem, tempRect);          RealToString(Gaussian_Amplitude[Index], 3, 2, str);          SetDialogItemText(DItem, str);          GetDialogItem(GetSelection, A^.Peak_Info_Energy[Index], DType, DItem, tempRect);          RealToString(Gaussian_Energy[Index], 3, 2, str);          SetDialogItemText(DItem, str);		  		  If ((Gaussian_Energy[Index] > 0.0) AND (Gaussian_Width[Index] <= 0.0)) then			  begin				if Ge_Active then SIGSQ := (2.5 * (Gaussian_Energy[Index] - 5895.0) + 				        theBGRec^^.Si_Resolution * theBGRec^^.Si_Resolution) / (2.354825 * 2.354825)				else if WDS_Active then SIGSQ := theBGRec^^.WDS_Resolution * theBGRec^^.WDS_Resolution				else {if Si_Active then} SIGSQ := (2.5 * (Gaussian_Energy[Index] - 5895.0) + 				         theBGRec^^.Si_Resolution * theBGRec^^.Si_Resolution) / 						 (2.354825 * 2.354825);				Gaussian_Width[Index] := 2.354825 * SQRT(SIGSQ);              end;          GetDialogItem(GetSelection, A^.Peak_Info_Width[Index], DType, DItem, tempRect);          RealToString(Gaussian_Width[Index], 3, 2, str);          SetDialogItemText(DItem, str);		  		          END; { for index...}      Peak_ExitDialog := False;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);                IF (itemHit = Peak_Info_Proceed) THEN          BEGIN            Peak_ExitDialog := True;          END;        IF (itemHit = Peak_Info_Cancel) THEN          BEGIN            (*DisposeDialog(GetSelection);            exit(D_Peak_Information);*)			Peak_ExitDialog := True;          END;        IF (itemHit = Peak_Info_Defaults) THEN          BEGIN            FOR nn := 1 TO 10 DO              BEGIN                Gaussian_Energy[nn] := 0.0;                Gaussian_Width[nn] := 0.0;                Gaussian_Amplitude[nn] := 0.0;              END;             GOTO 100;          END;        IF (itemHit = Peak_Info_Reset_MnK) THEN          BEGIN            FOR nn := 1 TO 10 DO              BEGIN				  GetDialogItem(GetSelection, A^.Peak_Info_Energy[nn], DType, DItem, tempRect);				  GetDialogItemText(DItem, sTemp);				  Gaussian_Energy[nn] := MyStr2Num(sTemp);				  If Gaussian_Energy[nn] > 0.0 then					  begin						if Ge_Active then SIGSQ := (2.5 * (Gaussian_Energy[nn] - 5895.0) + 								theBGRec^^.Si_Resolution * theBGRec^^.Si_Resolution) / (2.354825 * 2.354825)						else if WDS_Active then SIGSQ := theBGRec^^.WDS_Resolution * theBGRec^^.WDS_Resolution						else {if Si_Active then} SIGSQ := (2.5 * (Gaussian_Energy[nn] - 5895.0) + 								 theBGRec^^.Si_Resolution * theBGRec^^.Si_Resolution) / 								 (2.354825 * 2.354825);						Gaussian_Width[nn] := 2.354825 * SQRT(SIGSQ);					  end;				  GetDialogItem(GetSelection, A^.Peak_Info_Width[nn], DType, DItem, tempRect);				  RealToString(Gaussian_Width[nn], 3, 1, str);				  SetDialogItemText(DItem, str);			  			  			  END;			Peak_ExitDialog := false;          END;		  (*        IF (DType = (chkCtrl + ctrlItem)) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);          END;*)      UNTIL Peak_ExitDialog;      (*      GetDialogItem(GetSelection, Peak_Info_Add_Incomplete_Charge, DType, DItem, tempRect); {Get the Checkbox handle}      CItem := pointer(DItem);      temp := GetControlValue(CItem);      {    Add Incomplete Charge Tail }      IF temp = 1 THEN Peak_Incomplete_Charge := True;	 *) 	 IF (itemHit = Peak_Info_Proceed) THEN          BEGIN		    For index := 1 to Maximum_Channels do Plt_spec[10]^^.S[index] := 0.0;			  FOR Index := 1 TO 10 DO				BEGIN				  GetDialogItem(GetSelection, A^.Peak_Info_Width[Index], DType, DItem, tempRect);				  GetDialogItemText(DItem, sTemp);				  Gaussian_Width[Index] := MyStr2Num(sTemp);						  GetDialogItem(GetSelection, A^.Peak_Info_Amplitude[Index], DType, DItem, tempRect);				  GetDialogItemText(DItem, sTemp);				  Gaussian_Amplitude[Index] := MyStr2Num(sTemp);						  GetDialogItem(GetSelection, A^.Peak_Info_Energy[Index], DType, DItem, tempRect);				  GetDialogItemText(DItem, sTemp);				  Gaussian_Energy[Index] := MyStr2Num(sTemp);				END;					  Generate_Gaussians;			  BlockMove(@ Gen_P^,@Plt_spec[10]^^.S,SizeOf(Plt_spec[10]^^.S));			  UpDate_Max_Min(10);			  Spectrum_Full[10] := True;			  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);			  Refresh_ROIs;		END;      DisposeDialog(GetSelection);      Mouse_Active_Window;    END; {End of procedure D_Peak_Information}  PROCEDURE Update_Strip_Peak(whichWindow: WindowPtr);    VAR       Peak_temp                     : Str255;      Icon_Handle                   : Handle;         {Temp handle to read an Icon into}      offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;      str    : str255;	      BEGIN      IF (Strip_PeakWindow <> NIL) AND (Strip_PeakWindow = whichWindow) THEN        BEGIN          GetPort(GrafPtr(SavePort));          SetPort(Strip_PeakWindow);          SelectWindow(Strip_PeakWindow);          Mouse_Active_Window;          BackColor(WhiteColor);          ForeColor(BlackColor);          BeginUpdate(whichWindow);    {Set the clipping to the update area. Draw the Icon, ScaleUp}          Icon_Handle := GetIcon(314); {Get Icon into memory}          Setrect(tempRect, 378, 16, 410, 49); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN {Only use handle if it is valid}            PlotIcon(tempRect, Icon_Handle); {Draw the icon in the window}          {Draw the Icon, ScaleDown}          Icon_Handle := GetIcon(318); {Get Icon into memory}          Setrect(tempRect, 378, 49, 410, 81); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN {Only use handle if it is valid}            PlotIcon(tempRect, Icon_Handle); {Draw the icon in the window}          {Draw the Icon, CursorLeft}          Icon_Handle := GetIcon(334); {Get Icon into memory}          Setrect(tempRect, 62, 52, 94, 85); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN {Only use handle if it is valid}            PlotIcon(tempRect, Icon_Handle); {Draw the icon in the window}          {Draw the Icon, CursorRight}          Icon_Handle := GetIcon(335); {Get Icon into memory}          Setrect(tempRect, 95, 52, 128, 85); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN {Only use handle if it is valid}            PlotIcon(tempRect, Icon_Handle); {Draw the icon in the window}          { Draw a rectangle, Rectangle }          PenSize(3, 3); {Change pen size to draw a thicker line}          PenSize(1, 1); {Change pensize to draw the shadow lines}          MoveTo(450, 103); {Move to bottom left edge}          LINETO(612, 103); {Draw to bottom right edge}          LINETO(612, 43); {Draw to top right edge}          PenSize(3, 3); {Set the pen size to draw the rectangle}          Setrect(Peak_rect, 449, 42, 612, 103); {left,top,right,bottom}          Framerect(Peak_rect);          PenSize(1, 1); {Restore the pen size to default}          TextSize(12);          TextFont(systemFont);          {Draw a string of text, Static Text }          Setrect(Peak_rect, 489, 47, 580, 59); { l,t,r,b }          Peak_temp := 'Mouse Function';          TETextBox(pointer(Ord(@Peak_temp) + 1), length(Peak_temp), Peak_rect, Tejustleft);		  SetFont('Monaco', 9, []);		  offset := 12;		  Left := 2;		  Top := 9;		   		  n := 0;	  		  moveto(Left,Top);		  DrawString('To enter element to strip, push the "Load" button.');	  		  n := n+1; moveto(Left,Top + n*offset);		  str := 'To begin stripping, move the horizontal elevator bar, below.';		  DrawString(str); n := n+1; moveto(Left,Top + n*offset);		  str := 'When finished, "Load" next element, or "Start Over".';		  DrawString(str);          SetFont('systemFont', 12, []);		            Setrect(Peak_rect, 30, 35, 200, 50);  { l,t,r,b }          Peak_temp := 'Width, 0.5 (е5.0) eV steps';          TETextBox(pointer(Ord(@Peak_temp) + 1), length(Peak_temp), Peak_rect, Tejustleft);          SetFont('Monaco', 9, []);		  		  moveto(130,83);		  DrawString('Detector Resolution eV:');		  		  		  moveto(198,104);		  DrawString('Total Area Striped: ');		  		  moveto(262,118);		  DrawString('Amount shifted eV:');                     SetFont('Chicago', 12, []); { The System Font }          DrawControls(Strip_PeakWindow);		  EndUpdate(whichWindow);        	{Return to normal clipping area}          SetPort(GrafPtr(SavePort));		          END; 								{End for if (Strip_PeakWindow<>nil)}    END; 									{End of procedure}  {===========================================================}  PROCEDURE D_Get_Reference_Dialog;        CONST      GStrip_Ref_Cancel             = 2;      GStrip_Accept_and_Return      = 1;      GStrip_Use_ref_pk             = 4;	  GStrip_Use_sing_pk            = 5;      GStrip_generated_family       = 6;      GStrip_Ref_M                  = 7;      GStrip_Ref_L                  = 8;      GStrip_Ref_K                  = 9;      Strip_Gaussian_Position       = 14;      Strip_Gaussian_Width          = 15;      GStrip_Enter_Z                = 16;     VAR      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      Index                         : Integer;      DItem                         : Handle;      CItem			                : ControlHandle;      sTemp                         : Str255;      itemHit                       : Integer;      temp                          : Integer;      n, Big_Chan                   : integer;      str						    : str255; 	  GStrip_ExitDialog             : Boolean;	      LABEL      100;Procedure Refresh;VAR      offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;Begin      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);	  SetFont('Monaco', 9, []);	  offset := 12;	  Left := 2;	  Top := 9;		   	  n := 0;	  	  moveto(Left,Top);	  DrawString('Enter the Atomic Number (or Symbol) of the element to be stripped from the "work" ');	  	  n := n+1; moveto(Left,Top + n*offset);	  str := 'spectrum. Then choose which of the K, L or M families to do. Alternatively, you';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := 'can choose a single Gaussian to strip out, in which case you must enter the peak';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := 'parameters. You may also choose a stored, background corrected, reference peak to ';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := 'strip. ее The "shift" and "width" controls are currently not used in the reference mode. ';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := ' е The K family, when possible, is usually the best to start with. ';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := 'Pushing the F1 key will "speed up" by ten, the effect of the shift and width ';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := 'controls in the previous dialog.  ';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  str := ' ';	  DrawString(str); n := n+1; moveto(Left,Top + n*offset);	  SetFont('Chicago', 12, []); { The System Font }End;     BEGIN      GetSelection := GetNewDialog(28307, NIL, pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      GetDialogItem(GetSelection, GStrip_generated_family, DType, DItem, tempRect);       SetControlValue(ControlHandle(DItem), 1);      GetDialogItem(GetSelection, GStrip_Ref_K, DType, DItem, tempRect);       SetControlValue(ControlHandle(DItem), 1);      GetDialogItem(GetSelection, Strip_Gaussian_Position, DType, DItem, tempRect);       SetDialogItemText(DItem, '6403.0'); {Set the default text string}      GetDialogItem(GetSelection, Strip_Gaussian_Width, DType, DItem, tempRect);       SetDialogItemText(DItem, '145.5');      GetDialogItem(GetSelection, GStrip_Enter_Z, DType, DItem, tempRect);       numtostring(Atomic_Number, str);      SetDialogItemText(DItem, str);	          GetDialogItem(GetSelection, GStrip_Accept_and_Return, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      GStrip_ExitDialog := False;      Refresh; 	  Type_Strip_To_Use := 3;      Strip_Refs_Active := false;         GStrip_ExitDialog:=FALSE;                {Do not exit dialog handle loop yet}    100:         repeat      {еееееееее Start of main loop еееееееееееее}        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit); {Wait until an item is hit}        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect); {Get item information}        CItem := ControlHandle(DItem);        {Get the control handle}                IF (itemHit = GStrip_Ref_Cancel) THEN          BEGIN		   		  		    temprect := GetSelection^.portRect;             DisposeDialog(GetSelection);			  FillWhiteSpace(temprect);              Mouse_Active_Window;             Exit(D_Get_Reference_Dialog);          END;         IF (itemHit = GStrip_Accept_and_Return) THEN          BEGIN            GStrip_ExitDialog := True;          END;  		  		IF (itemHit = GStrip_generated_family) then Type_Strip_To_Use := 3;			IF (itemHit = GStrip_Use_sing_pk) then Type_Strip_To_Use := 2;		 		         IF (itemHit = GStrip_Use_ref_pk) then 		    BEGIN		    	Strip_Refs_Active := true;			    Type_Strip_To_Use := 1;  { use ref=1, sing. gaus=2, gen fam=3 }								append_ref := false;				display_ref := true;				MCA_Spectrum_Active := false; 				{move work to 9 because the ref display will go to work...}  				BlockMove(@Plt_Spec[10]^^, @Plt_Spec[9]^^, Sizeof(Plt_Spec[10]^^)); 				For n := 1 to Maximum_Channels do Plt_Spec[10]^^.S[n] := 0.0;			 			 			    SendBehind(GetSelection,BackPlane);				SetPort(BackPlane);				InValRect(GetSelection^.portrect);	{coveredRect is the rct of the dialog}				BeginUpdate(BackPlane);				DrawAxesFull;				Update_Full;				EndUpdate(BackPlane);	  				DoReferences;				Update_Strip_Peak(Strip_PeakWindow);				SelectWindow(GetSelection);								Ref_Amp := -1.0e32;				Big_Chan := 1;            FOR n := ChannelMin TO ChannelMax DO		       if Ref_Amp < Plt_spec[10]^^.S[n] then 			      BEGIN				   Ref_Amp := Plt_spec[10]^^.S[n];				   Big_Chan := n;				  END; 			                 			Ref_Amp := Plt_spec[10]^^.S[Big_Chan]/ Plt_Spec[9]^^.S[Big_Chan]; {ref/spec} 			   			               FOR n := ChannelMin TO ChannelMax DO { normalize the refs to the stripee spectrum }				Plt_spec[10]^^.S[n] := BigScale * 0.3 * Plt_spec[10]^^.S[n] / Ref_Amp  ;				                BlockMove(@Plt_spec[10]^^.S, @col_5^, Sizeof(col_1^));				BlockMove(@Plt_Spec[10]^^, @Plt_Spec[1]^^, Sizeof(Plt_Spec[10]^^));{ref counts to 1}                 BlockMove(@Plt_Spec[9]^^, @Plt_Spec[10]^^, Sizeof(Plt_Spec[10]^^));{spec back to work} 			  (*BlockMove(@Plt_Spec[9]^^.S, @Gen_P^, Sizeof(Plt_Spec[10]^^.S));*) {ref counts to 9} 		        			  Refresh;							end								 		    ELSE Strip_Refs_Active := false;            						        IF (itemHit >= GStrip_Use_ref_pk) AND (itemHit <= GStrip_generated_family) THEN          BEGIN            FOR Index := GStrip_Use_ref_pk TO GStrip_generated_family DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;         IF (itemHit >= GStrip_Ref_M) AND (itemHit <= GStrip_Ref_K) THEN          BEGIN            FOR Index := GStrip_Ref_M TO GStrip_Ref_K DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(ControlHandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;       UNTIL GStrip_ExitDialog;            Index := GStrip_Ref_M;      REPEAT        GetDialogItem(GetSelection, Index, DType, DItem, tempRect);        temp := GetControlValue(ControlHandle(DItem));        Index := Index + 1;      UNTIL (temp <> 0) OR (Index > GStrip_Ref_K);      temp := Index - GStrip_Ref_M + 1;      Strip_Line_To_Use := 5 - temp; { K=1, L=2, M=3 }      GetDialogItem(GetSelection, Strip_Gaussian_Position, DType, DItem, tempRect);       GetDialogItemText(DItem, sTemp);       Strip_One_Gauss_Position := MyStr2Num(sTemp);      GetDialogItem(GetSelection, Strip_Gaussian_Width, DType, DItem, tempRect);       GetDialogItemText(DItem, sTemp);       Strip_One_Gauss_Width := MyStr2Num(sTemp);      GetDialogItem(GetSelection, GStrip_Enter_Z, DType, DItem, tempRect);       GetDialogItemText(DItem, sTemp);       Atomic_Number := AtSymbol_To_Znum(sTemp);      IF Atomic_Number < 3 THEN        BEGIN          Atomic_Number := 3;          GetDialogItem(GetSelection, GStrip_Enter_Z, DType, DItem, tempRect);           RealToString(Atomic_Number, 3, 1, str);          SetDialogItemText(DItem, str);          GStrip_ExitDialog := False;          GOTO 100;        END;	  	  temprect := GetSelection^.portRect;	  DisposeDialog(GetSelection);	  FillWhiteSpace(temprect); 	        Mouse_Active_Window;      SetFont('Chicago', 12, []); { The System Font }    END; {End of procedure}{$S SiLiWindow2}  PROCEDURE Open_Strip_Peak;        CONST      Strip_Start_Over              = 4016;           {Button ID}      Strip_Load                    = 4015;           {Button ID}      Strip_Return                  = 4001;           {Button ID}	  Strip_Shift_Left              = 16195;	  Strip_Shift_Right             = 16196;      Strip_Bi_Polar                = 4021;           {Checkbox ID}      Strip_Contract_Horizontal     = 4012;           {Radio ID}      Strip_Expand_Horizontal       = 4011;           {Radio ID}      Strip_Log                     = 4020;           {Radio ID}      Strip_Square_Root             = 4019;           {Radio ID}      Strip_Linear                  = 4018;           {Radio ID}      Strip_Z                       = 4003;           {Edit text ID}      Strip_Vert_Scale              = 4017;           {Scroll bar ID}      Peak_Strip                    = 4010;           {Scroll bar ID}    VAR      Index            	 : Integer;      Peak_CtrlHandle    : ControlHandle;   {Control handle}		  	      BEGIN      IF (Strip_PeakWindow = NIL) THEN        BEGIN          Strip_PeakWindow := GetNewWindow(4001, NIL, pointer( - 1));          MoveWindow(Strip_PeakWindow,MaxWindowRect.Left,MaxWindowRect.Bottom-123,TRUE );           {Start over }          Peak_CtrlHandle := GetNewControl(Strip_Start_Over, Strip_PeakWindow);           {Load }          Peak_CtrlHandle := GetNewControl(Strip_Load, Strip_PeakWindow);          {Return }          Peak_CtrlHandle := GetNewControl(Strip_Return, Strip_PeakWindow);          Peak_CtrlHandle := GetNewControl(Strip_Shift_Left, Strip_PeakWindow);          Peak_CtrlHandle := GetNewControl(Strip_Shift_Right, Strip_PeakWindow);		            { Make a checkbox, Bi Polar }          Peak_Bi_Polar := GetNewControl(Strip_Bi_Polar, Strip_PeakWindow);          {Contract Horizontal }          R1control[1] := GetNewControl(Strip_Contract_Horizontal, Strip_PeakWindow); { radio button}           {Expand Horizontal }          R1control[2] := GetNewControl(Strip_Expand_Horizontal, Strip_PeakWindow); { radio button}           {Log }          R2control[1] := GetNewControl(Strip_Log, Strip_PeakWindow);            {Square Root }          R2control[2] := GetNewControl(Strip_Square_Root, Strip_PeakWindow);           {Linear }          R2control[3] := GetNewControl(Strip_Linear, Strip_PeakWindow);           { Make a scroll bar, Vert_Scale }          Peak_CtrlHandle := GetNewControl(Strip_Vert_Scale, Strip_PeakWindow); { scrollbar}          { Make a scroll bar, Peak_Strip }          Peak_CtrlHandle := GetNewControl(Peak_Strip, Strip_PeakWindow); { scrollbar}		  BigScale := 0.2 ;		  TheGlobal_LValue := 500;		  The_Amplitude := 1.0;			   		  		          END {End for if (Strip_PeakWindow<>nil)}      ELSE {Already open, so ....}        BEGIN          SelectWindow(Strip_PeakWindow);          ShowWindow(Strip_PeakWindow);		 BackColor(WhiteColor);         ForeColor(BlackColor); 	                        Auto_Scale_Display := False;          SetControlValue(AutoScale_CtrlHandle, 0); {Set AutoScale checkbox to off value}          FOR Index := 1 TO 10 DO            BEGIN              Spectrum_Full[Index] := False;              CheckItem(FullMenu, A^.C_Full[Index], Spectrum_Full[Index]);            END;           		  BlockMove(@Plt_spec[10]^^, @Plt_spec[9]^^, Sizeof(Plt_spec[9]^^));             First_Time := True;		            For Index := 1 to Maximum_Channels do Gen_P^[Index] := 0.0;          BlockMove(@Plt_spec[10]^^.S, @col_6^, Sizeof(col_6^));           IF Log_Scale_Display THEN SetControlValue(R2control[1], 1);          IF Log_Scale_Display = False THEN SetControlValue(R2control[1], 0); 	            IF Linear_Display THEN SetControlValue(R2control[3], 1);          IF Linear_Display = False THEN SetControlValue(R2control[3], 0); 		            IF Square_Root_Display THEN SetControlValue(R2control[2], 1);          IF Square_Root_Display = False THEN SetControlValue(R2control[2], 0);           IF Mouse_Function_Contract THEN SetControlValue(R1control[1], 1);          IF Mouse_Function_Contract = False THEN SetControlValue(R1control[1], 0); 		            IF Mouse_Function_Expand THEN SetControlValue(R1control[2], 1);          IF Mouse_Function_Expand = False THEN SetControlValue(R1control[2], 0);           IF Bipolar_Display THEN SetControlValue(Peak_Bi_Polar, 1);          IF Bipolar_Display = False THEN SetControlValue(Peak_Bi_Polar, 0);           Spectrum_Full[10] := True;          CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);           Spectrum_Full[9] := True;          CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]); 		  		  BigScale := 0.2 ;		  TheGlobal_LValue := 500;		  The_Amplitude := 1.0; 	      Update_Full;        END; { else }    END; {End of procedure}  {=================================}  PROCEDURE Do_Strip_Peak(myEvent: EventRecord );        CONST      Strip_Start_Over              = 4016;           {Button ID}      Strip_Load                    = 4015;           {Button ID}      Strip_Return                  = 4001;           {Button ID}	  Strip_Shift_Left              = 16195;	  Strip_Shift_Right             = 16196;	        Strip_Bi_Polar                = 4021;           {Checkbox ID}      Strip_Contract_Horizontal     = 4012;           {Radio ID}      Strip_Expand_Horizontal       = 4011;           {Radio ID}      Strip_Log                     = 4020;           {Radio ID}      Strip_Square_Root             = 4019;           {Radio ID}      Strip_Linear                  = 4018;           {Radio ID}      Strip_Z                       = 4003;           {Edit text ID}      Strip_Vert_Scale              = 4017;           {Scroll bar ID}      Peak_Strip                    = 4010;           {Scroll bar ID}    VAR      RefCon                        : Integer;      code                          : Integer;      whichWindow                   : WindowPtr;      Peak_Pt                       : Point;          {Point where event happened}      Temp_Line_Energy              : ARRAY [1..20] OF real {double_t};      Temp_Line_Weight              : ARRAY [1..20] OF real {double_t};      K_Hold                        : Integer;      L_Hold                        : Integer;      M_Hold                        : Integer;      Valid_Peak                    : Integer;     Icon_Handle                    : Handle;         {Temp handle to read an Icon into}      InIcon                        : boolean;        {Flag used in tracking Icon loops}      TheIconRect                   : Rect;           {Rectangle for Icons}      TempRect                      : Rect; 	  nn                            : integer;      str1,str2,str3	   			: str255; PROCEDURE Get_the_Pks(i, k : integer);	VAR		sh_const		: real;BEGIN	IF k = 2 then sh_const := 340.0	ELSE IF k = 3 then sh_const := 830;  IF (eV_Line[i] > sh_const) AND (eV_Line[i] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) THEN    BEGIN      Temp_Line_Energy[Valid_Peak] := eV_Line[i];      Temp_Line_Weight[Valid_Peak] := Wt_Line[i] * Temp_Line_Weight[L_Hold];      Valid_Peak := Valid_Peak + 1;    END;END;	{PROCEDURE Get_the_Pks}PROCEDURE Get_the_MPks(i, k, zx : integer);	VAR		sh_const		: real;BEGIN	IF k = 2 then sh_const := 340.0	ELSE IF k = 3 then sh_const := 830;      IF (eV_Line[i] > 830) AND (eV_Line[i] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) AND (Z >= zx) THEN        BEGIN          Temp_Line_Energy[Valid_Peak] := eV_Line[i];          Temp_Line_Weight[Valid_Peak] := Wt_Line[i] * Temp_Line_Weight[M_Hold];          Valid_Peak := Valid_Peak + 1;        END;END;	{PROCEDURE Get_the_MPks}	  PROCEDURE LoadPeaks;VAR  j, JJ, ii        : integer; E, SIGSQ, DELESQ, YE, area  : Real;BEGIN      IF (Type_Strip_To_Use = 2) or (Type_Strip_To_Use = 3) THEN  		  BEGIN				                 Get_Energies(Atomic_Number);                  Valid_Peak := 1;                  IF Strip_Line_To_Use = 1 THEN                    BEGIN { K case }                      IF (eV_Line[1] > 52) AND (eV_Line[1] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) THEN                        BEGIN                          Temp_Line_Energy[Valid_Peak] := eV_Line[1];                          Temp_Line_Weight[Valid_Peak] := Wt_Line[1] * Plt_spec[10]^^.S[rinttol(eV_Line[1] / Plt_spec[10]^^.                                                          Expt_Info.dE)];                          K_Hold := Valid_Peak;                          Valid_Peak := Valid_Peak + 1;                        END;                      IF (eV_Line[2] > 52) AND (eV_Line[2] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) THEN                        BEGIN                          Temp_Line_Energy[Valid_Peak] := eV_Line[2];                          Temp_Line_Weight[Valid_Peak] := Wt_Line[2] * Temp_Line_Weight[K_Hold];                          Valid_Peak := Valid_Peak + 1;                        END;                      IF (eV_Line[3] > 1065) AND (eV_Line[3] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) THEN                        BEGIN                          Temp_Line_Energy[Valid_Peak] := eV_Line[3];                          Temp_Line_Weight[Valid_Peak] := Wt_Line[3] * (1 + Wt_Line[2]) / (1 - Wt_Line[3]) *                                                          Temp_Line_Weight[K_Hold];                          Valid_Peak := Valid_Peak + 1;                        END;                    END; { K case }                  IF Strip_Line_To_Use = 2 THEN                    BEGIN { L case }                      IF (eV_Line[42] > 340) AND (eV_Line[42] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) THEN                        BEGIN                          Temp_Line_Energy[Valid_Peak] := eV_Line[42];                          Temp_Line_Weight[Valid_Peak] := Wt_Line[42] * Plt_spec[10]^^.S[rinttol(eV_Line[42] / Plt_spec[10]^^.                                                          Expt_Info.dE)];                          L_Hold := Valid_Peak;                          Valid_Peak := Valid_Peak + 1;                        END;                        FOR ii := 11 to 16 do						Get_the_Pks(ii, 2);						ii := 18;						Get_the_Pks(ii, 2);						ii := 24;						Get_the_Pks(ii, 2);						ii := 29;						Get_the_Pks(ii, 2);                        FOR ii := 31 to 32 do						Get_the_Pks(ii, 2);						ii := 35;						Get_the_Pks(ii, 2);						ii := 43;						Get_the_Pks(ii, 2);						FOR ii := 45 to 46 do						Get_the_Pks(ii, 2);						FOR ii := 48 to 49 do						Get_the_Pks(ii, 2);												                    END; { L case }                  IF Strip_Line_To_Use = 3 THEN                    BEGIN { M case }                      IF (eV_Line[72] > 830) AND (eV_Line[72] < Spectrum_Size * Plt_spec[10]^^.Expt_Info.dE) AND (Z >= 57)                         THEN                        BEGIN                          Temp_Line_Energy[Valid_Peak] := eV_Line[72];                          Temp_Line_Weight[Valid_Peak] := Wt_Line[72] * Plt_spec[10]^^.S[rinttol(eV_Line[72] / Plt_spec[                                                          10]^^.Expt_Info.dE)];                          M_Hold := Valid_Peak;                          Valid_Peak := Valid_Peak + 1;                        END;                        						ii := 69;						Get_the_MPks(ii, 3, 57);						ii := 66;						Get_the_MPks(ii, 3, 57);						ii := 74;						Get_the_MPks(ii, 2, 57);						ii := 70;						Get_the_MPks(ii, 2, 73);						ii := 57;						Get_the_MPks(ii, 3, 57);						ii := 61;						Get_the_MPks(ii, 3, 35);						ii := 56;						Get_the_MPks(ii, 2, 44);						FOR ii := 53 to 54 do						Get_the_MPks(ii, 2, 73);						FOR ii := 63 to 65 do						Get_the_MPks(ii, 2, 73);						                    END; { M case }              {  END;} { generated family }              IF Type_Strip_To_Use = 2 THEN                BEGIN { single generated gaussian }                  Valid_Peak := 2;                  Temp_Line_Energy[1] := Strip_One_Gauss_Position;                  Temp_Line_Weight[1] := Plt_spec[10]^^.S[rinttol(Strip_One_Gauss_Position / 				                         Plt_spec[10]^^.Expt_Info.dE)];                END;							              For j := 1 to Maximum_Channels do Gen_P^[j] := 0.0;              FOR j := ChannelMin TO ChannelMax DO                BEGIN                  E := j * Plt_spec[10]^^.Expt_Info.dE + Shift_amount;				  if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then				  begin					theWidth := Plt_Spec[10]^^.Expt_Info.Si_Resolution + Fat_amount;					SigSqMn := (theWidth * theWidth) * aSigConst;				  end;				  if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then				  begin					theWidth := Plt_Spec[10]^^.Expt_Info.WDS_Resolution + Fat_amount;					SigSqMn := (theWidth * theWidth) ;                  end;				  				                    FOR JJ := 1 TO Valid_Peak - 1 DO                    BEGIN 				if Ge_Active then SIGSQ := 				(2.5 * (Temp_Line_Energy[JJ] - 5895.0) + theWidth * theWidth) / (2.354825 * 2.354825)				else if WDS_Active then SIGSQ := theWidth * theWidth 				else {if Si_Active then} SIGSQ := 				(2.5 * (Temp_Line_Energy[JJ] - 5895.0) + theWidth * theWidth) / (2.354825 * 2.354825);                      DELESQ := (E - Temp_Line_Energy[JJ]) * (E - Temp_Line_Energy[JJ]);					                   IF Type_Strip_To_Use = 2 THEN                      SIGSQ := (Strip_One_Gauss_Width + Fat_amount) * 					           (Strip_One_Gauss_Width + Fat_amount) / (2.354825 * 2.354825);                     YE := Temp_Line_Weight[JJ] / sqrt(2 * PI * SIGSQ) * exp( - 0.5 * DELESQ / SIGSQ);                        Gen_P^[j] := Gen_P^[j] + YE ;                    END; { of jj loop }                END; { of j loop }							   area := 0.0;			  FOR j := ChannelMin TO ChannelMax DO				 BEGIN					  Gen_P^[j] := Gen_P^[j] * The_Amplitude;					  area := Gen_P^[j] + area;				 END;	 		END; { Type_Strip_To_Use 2 or 3 }			IF Type_Strip_To_Use = 1 THEN { LoadPeaks: use references }		  BEGIN			 			 For j := 1 to Maximum_Channels do Gen_P^[j] := 0.0;		    area := 0.0;					    jj:= rinttol(Shift_amount/Plt_spec[10]^^.Expt_info.dE);						IF Shift_amount = 0 then			FOR j := ChannelMin TO ChannelMax DO 			  BEGIN				  Gen_P^[j] := col_5^[j] * The_Amplitude;				  area := Gen_P^[j] + area;			  END			ELSE IF jj > 0 then			FOR j := ChannelMin TO ChannelMax - jj DO 			    BEGIN					Gen_P^[j+jj] := col_5^[j] * The_Amplitude;				  area := Gen_P^[j] + area;				END			ELSE FOR j := ChannelMin - jj TO ChannelMax  DO 			    BEGIN					Gen_P^[j+jj] := col_5^[j] * The_Amplitude;				  area := Gen_P^[j] + area;				END;				BlockMove(@Gen_P^, @Plt_Spec[2]^^.S, Sizeof(Plt_Spec[2]^^.S));{ref counts to 1} 	          END; { IF Type_Strip_To_Use = 1... } 			 		  If (strip_peakwindow <> NIL) and		     (strip_peakwindow = whichwindow) then		  Begin			  setport(strip_peakwindow);			  TempRect := strip_peakwindow^.portrect;			   SetFont('Monaco', 9, []);			   			   RealToString(area,5,4,str1); { area is the sum of all channels, the integral (area) }			   RealToString(theWidth,5,2,str2); {theWidth is MnFWHM + the amount added or subtracted}			   RealToString(Shift_amount,5,4,str3); {Shift_amount is the amount shifted in eV}					 			   TempRect.left := 315;                      { Area of removed PeakSSS }			   TempRect.Right := TempRect.left + 90;			   TempRect.Top := 95;			   TempRect.Bottom := TempRect.Top + 13;			   EraseRect(TempRect);			   moveto(TempRect.left + 2, TempRect.Top + 8);			   DrawString(str1);			   			   TempRect.left := 268;                      { FWHM Mn K alpha }			   TempRect.Right := TempRect.left + 60;			   TempRect.Top := 75;			   TempRect.Bottom := TempRect.Top + 15;			   EraseRect(TempRect);			   moveto(TempRect.left + 2, TempRect.Top + 8);			   DrawString(str2);	  	 			   TempRect.left := 370;                      { Shift }			   TempRect.Right := TempRect.left + 60;			   TempRect.Top := 110;			   TempRect.Bottom := TempRect.Top + 15;			   EraseRect(TempRect);			   moveto(TempRect.left + 2, TempRect.Top + 8);			   DrawString(str3);	  			   			   SetFont('Chicago', 12, []); { The System Font } 		  End; END; { LoadPeaks } 	      PROCEDURE Do_A_Button;      VAR        j, nn	                     : Integer;       BEGIN        Hilitecontrol(Peak_Control, 4010); {Darken the button}        RefCon := GetControlReference(Peak_Control);        Store_Work_Hi := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;        Store_Work_Lo := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts;        CASE RefCon OF {Select correct button}        {еее}          Strip_Start_Over: {Start over...same fnc for stripping}            BEGIN			  beepbeep;			  Shift_amount := 0.0;			  The_Amplitude := 1;			  For nn := 1 to Maximum_Channels do Gen_P^[nn] := 0.0;			  For nn := 1 to Maximum_Channels do Plt_spec[9]^^.S[nn] := 0.0;			{  BlockMove(@Plt_spec[10]^^.S, @col_1^, Sizeof(col_1^));			  Escape;}			  BlockMove(@Plt_spec[10]^^.S, @col_6^, Sizeof(col_6^));			 { BlockMove(@col_1^, @col_6^, Sizeof(col_6^));}               First_Time := True;			  BlockMove(@Plt_spec[10]^^, @Plt_spec[9]^^, Sizeof(Plt_spec[9]^^));			 { BlockMove(@col_1^, @Plt_spec[9]^^, Sizeof(Plt_spec[9]^^));}			  			  Update_Full;             END;          {еее}          Strip_Load: {Load}          BEGIN              For nn := 1 to Maximum_Channels do Gen_P^[nn] := 0.0;			                FOR j := 1 TO 20 DO                BEGIN                  Temp_Line_Energy[j] := 0.0;                  Temp_Line_Weight[j] := 0.0;                END;              			  D_Get_Reference_Dialog;	{dialog to pick the fnc to strip}              IF Type_Strip_To_Use = 3 THEN              BEGIN { generated family }                  IF Atomic_Number > 95 THEN                  BEGIN                      BeepBeep;                      Putmessage('Atomic Number can not be > 95', '', '', '');                      D_Get_Reference_Dialog;                  END;                  IF Atomic_Number < 5 THEN                    BEGIN                      BeepBeep;                      Putmessage('Atomic Number can not be < 5', '', '', '');                      D_Get_Reference_Dialog;                    END;					                  IF (First_Time = False) THEN BlockMove(@Plt_spec[9]^^.S,@col_6^,SizeOf(col_6^));				                     LoadPeaks;				   First_Time := False;				END;	{IF Type_Strip_To_Use = 3...}						Update_Full;	                     END;	{Strip_Load:...}	   	             {еее}          Strip_Shift_Left:              BEGIN			 IF Type_Strip_To_Use = 1 then			 		Shift_amount := Shift_amount - Plt_spec[10]^^.Expt_info.dE			 ELSE IF not OptionKeyDown then Shift_amount := Shift_amount - 0.1 			 ELSE Shift_amount := Shift_amount - 1;               			  Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;			 LoadPeaks;              FOR nn := ChannelMin TO ChannelMax DO                BEGIN               (*   Plt_spec[9]^^.S[nn] := col_6^[nn] - Gen_P^[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_spec[9]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_spec[9]^^.S[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_spec[10]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_spec[10]^^.S[nn];               *)  Plt_spec[9]^^.S[nn] := col_6^[nn] - Gen_P^[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_spec[9]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_spec[9]^^.S[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > col_1^[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := col_1^[nn];                END;              Update_Full;			 			END;			          {еее}          Strip_Shift_Right:              BEGIN			 IF Type_Strip_To_Use = 1 then			 		Shift_amount := Shift_amount + Plt_spec[10]^^.Expt_info.dE			 ELSE IF not OptionKeyDown then             Shift_amount := Shift_amount + 0.1 			 ELSE Shift_amount := Shift_amount + 1;               Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;			 LoadPeaks;              FOR nn := ChannelMin TO ChannelMax DO                BEGIN                  Plt_spec[9]^^.S[nn] := col_6^[nn] - Gen_P^[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_spec[9]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_spec[9]^^.S[nn];               (*   IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_spec[10]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_spec[10]^^.S[nn];                *)                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > col_1^[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := col_1^[nn];				END;              Update_Full;			             END;          {еее}          Strip_Return: {Return}            BEGIN			  Strip_Refs_Active := false;                Open_Sili_Window;              Mouse_Active_Window;              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Store_Work_Hi;              Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Store_Work_Lo;            END;          {еее}          OTHERWISE {allow other buttons, trap for debug}            BEGIN {start}              Putmessage('This message should not appear.', ' In trap location 2, in strip peak', '', '');            END; {end of otherwise}          END; {end of case}        		Hilitecontrol(Peak_Control, 0); {Lighten the button}      END;    PROCEDURE Do_A_Checkbox;      PROCEDURE Clear1radiogroup;        VAR          Peak_Index                    : Integer;    {Peak_Index used for radios}        BEGIN          FOR Peak_Index := 1 TO 2 DO            SetControlValue(R1control[Peak_Index], 0);          Mouse_Function_Expand := False;          Mouse_Function_Contract := False;        END;      PROCEDURE Clear2radiogroup;        VAR          Peak_Index                    : Integer;    {Peak_Index used for radios}                  BEGIN          FOR Peak_Index := 1 TO 3 DO            SetControlValue(R2control[Peak_Index], 0);          Log_Scale_Display := False;          Square_Root_Display := False;          Linear_Display := False;        END;      BEGIN        RefCon := GetControlReference(Peak_Control);        theValue := GetControlValue(Peak_Control);        theValue := (theValue + 1) MOD 2;        CASE RefCon OF {Select correct button}          Strip_Bi_Polar: {Bi Polar, checkbox}            BEGIN              SetControlValue(Peak_Control, theValue);              Autovalue := GetControlValue(Peak_Control);              IF Autovalue = 1 THEN Bipolar_Display := True;              IF Autovalue = 0 THEN Bipolar_Display := False;              Update_Full;            END;          Strip_Contract_Horizontal: {Contract Horizontal }            BEGIN              Clear1radiogroup;              SetControlValue(Peak_Control, 1);              Mouse_Function_Contract := True;            END;          Strip_Expand_Horizontal: {Expand Horizontal }            BEGIN              Clear1radiogroup;              SetControlValue(Peak_Control, 1);              Mouse_Function_Expand := True;            END;          Strip_Log: {Log }            BEGIN              Clear2radiogroup;              SetControlValue(Peak_Control, 1);              Autovalue := GetControlValue(Peak_Control);              IF Autovalue = 1 THEN Log_Scale_Display := True;              IF Autovalue = 0 THEN Log_Scale_Display := False;              Update_Full;            END;          Strip_Square_Root: {Square Root }            BEGIN              Clear2radiogroup;              SetControlValue(Peak_Control, 1);              Autovalue := GetControlValue(Peak_Control);              IF Autovalue = 1 THEN Square_Root_Display := True;              IF Autovalue = 0 THEN Square_Root_Display := False;              Update_Full;            END;          Strip_Linear: {Linear }            BEGIN              Clear2radiogroup;              SetControlValue(Peak_Control, 1);              Autovalue := GetControlValue(Peak_Control);              IF Autovalue = 1 THEN Linear_Display := True;              IF Autovalue = 0 THEN Linear_Display := False;              Update_Full;            END;          OTHERWISE {allow other checkboxes and radios, trap for debug}            BEGIN {start}              Putmessage('This message should not appear.', ' In trap location 1,', '  in strip peak', '');            END; {end of otherwise}          END; {end of case}      END;    PROCEDURE Do_A_Scrollbar(code: Integer); {Handle a ScrollBar being pressed}      VAR        nn                            : Integer;        Start                         : Integer;        Stop                          : Integer;        Increment                     : Integer;        Lincrement                    : Integer;      BEGIN {Handle a ScrollBar being pressed}        RefCon := GetControlReference(Peak_Control);        CASE RefCon OF {Select correct scrollbar}          Strip_Vert_Scale: {Vert_Scale', scroll bar}            BEGIN {start for this scroll bar}              SiLi_Vert_Value := 1001 - GetControlValue(Peak_Control); {Get current state}              Start := 1; { These are the endpoints of the scroll bar set in resource file }              Stop := 1000;              Increment := 10;              Lincrement := 100;              IF (code = kControlUpButtonPart) THEN {See if in the up/left arrow}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value + Increment; {Subtract the single decrement}                  IF (SiLi_Vert_Value < Start) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Start; {Bump at the start value}                END;              IF (code = kControlDownButtonPart) THEN {See if in the down/right arrow}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value - Increment; {Add the single increment}                  IF (SiLi_Vert_Value > Stop) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Stop; {Bump at the stop value}                END;              IF (code = kControlPageUpPart) THEN {See if in the up/left grey area}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value + Lincrement; {Subtract the page increment}                  IF (SiLi_Vert_Value < Start) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Start; {Bump at the Start value}                END;              IF (code = kControlPageDownPart) THEN {See if in the down/right grey area}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value - Lincrement; {Add the page increment}                  IF (SiLi_Vert_Value > Stop) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Stop; {Bump at the Stop value}                END;              IF (code = kControlIndicatorPart) THEN {See if in the drag box area}                BEGIN                  code := TrackControl(Peak_Control, Peak_Pt, NIL); {Let the OS drag it around}                  SiLi_Vert_Value := 1001 - GetControlValue(Peak_Control); {Get current state}                END;              SetControlValue(Peak_Control, 1001 - SiLi_Vert_Value); {Set new state}              { SiLi_Vert_Value is set in resource to go 1 to 1000 }              V_Scale_Top := V_Scale_Top_Arrow * (2.001501502 - 1.501501502E-3 * SiLi_Vert_Value);              V_Scale_Bottom := zero;              Scale_Changed_Event := True;              Update_Full;            END; {end for vertical scroll bar}			          Peak_Strip: { Peak_Strip, scroll bar }            BEGIN { start for this scroll bar }              Start := - 100;              Stop := 1000;              Increment := 1;              Lincrement := 10;              TheLValue := GetControlValue(Peak_Control); {Get current state}               IF (code = kControlUpButtonPart) THEN {See if in the up/left arrow}                BEGIN                  TheLValue := TheLValue - Increment; {Subtract the single decrement}                  IF (TheLValue < Start) THEN {Check for boundary conditions}                    TheLValue := Start; {Bump at the start value}                END;              IF (code = kControlDownButtonPart) THEN {See if in the down/right arrow}                BEGIN                  TheLValue := TheLValue + Increment; {Add the single increment}                  IF (TheLValue > Stop) THEN {Check for boundary conditions}                    TheLValue := Stop; {Bump at the stop value}                END;              IF (code = kControlPageUpPart) THEN {See if in the up/left grey area}                BEGIN                  TheLValue := TheLValue - Lincrement; {Subtract the page increment}                  IF (TheLValue < Start) THEN {Check for boundary conditions}                    TheLValue := Start; {Bump at the Start value}                END;              IF (code = kControlPageDownPart) THEN {See if in the down/right grey area}                BEGIN                  TheLValue := TheLValue + Lincrement; {Add the page increment}                  IF (TheLValue > Stop) THEN {Check for boundary conditions}                    TheLValue := Stop; {Bump at the Stop value}                END;              IF (code = kControlIndicatorPart) THEN {See if in the drag box area}                BEGIN                  code := TrackControl(Peak_Control, Peak_Pt, NIL); {Let the OS drag it around}                  TheLValue := GetControlValue(Peak_Control); {Get current state}                END;              SetControlValue(Peak_Control, TheLValue); {Set new state}              TheGlobal_LValue := TheLValue;              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;			  			  The_Amplitude := BigScale * TheGlobal_LValue ;			  			  LoadPeaks;	{get the function to be stripped}              			  FOR nn := ChannelMin TO ChannelMax DO                BEGIN                  Plt_spec[9]^^.S[nn] := col_6^[nn] - Gen_P^[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_spec[9]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_spec[9]^^.S[nn];               (* IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_spec[10]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_spec[10]^^.S[nn];                *)  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > col_1^[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := col_1^[nn];                END;              Update_Full;            END; {end for strip scroll bar}          OTHERWISE { debug }            BEGIN              Putmessage('This message should not appear.', ' In trap ', 'location 3, in strip peak', '');            END;          END; {end of case}      END; {Handle a ScrollBar being pressed}    {еееее}    PROCEDURE Track_the_Icon(NormIcon_ID, HilightIcon_ID: Integer; IconRect: Rect); {Track the Icon}      BEGIN {Start of Track the Icon}	          Icon_Handle := GetIcon(HilightIcon_ID); {Get Hilighted Icon into memory}        IF (Icon_Handle <> NIL) THEN {Only do if we got the resource OK}          BEGIN {Get ready to plot the hilighted icon}            eraseRect(IconRect); {Erase the original icon}            PlotIcon(IconRect, Icon_Handle); {Draw the hilighted icon}          END; {End of drawing hilighted icon}        InIcon := True; {Flag as mouse in the Icon}        REPEAT {Start of mouse tracking routine}          GetMouse(Strip_Pt); {Get latest mouse position}          IF (PtInRect(Strip_Pt, IconRect)) THEN {See if still over the Icon}            BEGIN {...yes, over the Icon}              IF NOT (InIcon) THEN {See if mouse was out of Icon}                BEGIN {...yes, so it is unhilighted}                  Icon_Handle := GetIcon(HilightIcon_ID); {Get Hilighted Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have a hilighted Icon}                    BEGIN {...yes, have hilighted Icon}                      eraseRect(IconRect); {Erase the unhilighted icon}                      PlotIcon(IconRect, Icon_Handle); {Draw the hilighted icon}                    END; {End of Draw the hilighted icon}                  InIcon := True; {Flag that we drew the hilighted icon}                END;            END          ELSE            IF InIcon THEN {Then draw unhilighted Icon}              BEGIN {Start drawing unhilighted Icon}                Icon_Handle := GetIcon(NormIcon_ID); {Get standard Icon into memory}                IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                  BEGIN {...yes, have hilighted Icon}                    eraseRect(IconRect); {Erase the hilighted icon}                    PlotIcon(IconRect, Icon_Handle); {Draw the standard icon}                  END; {End of Draw the icon}                InIcon := False; {Flag as showing the unhilighted icon}              END;        UNTIL NOT (StillDown); {Loop till mouse button is released}      END; {End of the track Icon procedure}	    BEGIN  { еееее PROCEDURE Do_Strip_Peak еееее }	        IF (Strip_PeakWindow <> NIL) THEN        BEGIN          code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}          IF (myEvent.what = MouseDown) AND (Strip_PeakWindow = whichWindow) THEN            BEGIN              Strip_Pt := myEvent.where;              WITH Strip_PeakWindow^.portBits.bounds DO {Make it relative}                BEGIN                  Strip_Pt.h := Strip_Pt.h + left;                  Strip_Pt.v := Strip_Pt.v + top;                END;              Setrect(TheIconRect, 378, 16, 410, 49); {Position of the Icon}              IF PtInRect(Strip_Pt, TheIconRect) THEN { In the icon ееScaleUpее }                BEGIN				  BackColor(WhiteColor);                  ForeColor(BlackColor);                  Track_the_Icon(314, 10314, TheIconRect); { Track the Icon }                  IF (PtInRect(Strip_Pt, TheIconRect)) THEN { See if released in the Icon }                    BEGIN {...yes, released in the Icon }                      V_Scale_Top := V_Scale_Top / 2;                      V_Scale_Bottom := V_Scale_Bottom / 2;					  Scale_Changed_Event := True;                      V_Scale_Top_Arrow := V_Scale_Top; { Holding variable for scrollbar use }                      V_Scale_Bottom_Arrow := V_Scale_Bottom; { Holding variable for scrollbar use }                      {SetControlValue(Peak_Control, 500); } {Put scroll thumb in middle}                      Update_Full;					  BackColor(WhiteColor);					  ForeColor(BlackColor);				                      END;                  SetPort(Strip_PeakWindow);                  Icon_Handle := GetIcon(314); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}										                      eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;              Setrect(TheIconRect, 378, 49, 410, 81); { Position of the Icon }              IF PtInRect(Strip_Pt, TheIconRect) THEN { In the icon ееScaleDownее}                BEGIN				  BackColor(WhiteColor);                  ForeColor(BlackColor);				                    Track_the_Icon(318, 10318, TheIconRect); {Track the Icon}                  IF (PtInRect(Strip_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                      V_Scale_Top := V_Scale_Top * 2;                      V_Scale_Bottom := V_Scale_Bottom * 2;					  Scale_Changed_Event := True;                      V_Scale_Top_Arrow := V_Scale_Top; { Holding variable for scrollbar use }                      V_Scale_Bottom_Arrow := V_Scale_Bottom; { Holding variable for scrollbar use }                      { SetControlValue(Peak_Control, 500);} {Put scroll thumb in middle}                      Update_Full;					  BackColor(WhiteColor);					  ForeColor(BlackColor);				                      END; {End of released in the Icon}                  SetPort(Strip_PeakWindow);                  Icon_Handle := GetIcon(318); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}                      eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;              Setrect(TheIconRect, 62, 52, 94, 85); {Position of the Icon}              IF PtInRect(Strip_Pt, TheIconRect) THEN {In the icon ееCursorLeftее }                BEGIN				  BackColor(WhiteColor);                  ForeColor(BlackColor);				                  Track_the_Icon(334, 10334, TheIconRect); {Track the Icon}                  IF (PtInRect(Strip_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                   {  BigScale := BigScale - 0.01;					 if BigScale < 0.001 then BigScale := 0.001; }			 IF not OptionKeyDown then             Fat_amount := Fat_amount - 0.5 			 ELSE Fat_amount := Fat_amount - 5; 			  {if Plt_Spec[10]^^.Expt_Info.Si_Resolution - Fat_amount < 123.0 then Fat_amount := Fat_amount + 1.0;}              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;			   			  The_Amplitude := BigScale * TheGlobal_LValue ;			  			  Read_Spectrum;  {10 into col_1, strip escapes}			  LoadPeaks;              FOR nn := ChannelMin TO ChannelMax DO                BEGIN                  Plt_spec[9]^^.S[nn] := col_6^[nn] - Gen_P^[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_spec[9]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_spec[9]^^.S[nn];              (*    IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_spec[10]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_spec[10]^^.S[nn];               *)   IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > col_1^[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := col_1^[nn];                END;              Update_Full;				  BackColor(WhiteColor);                  ForeColor(BlackColor);					 					                     END; {End of released in the Icon}                  SetPort(Strip_PeakWindow);                  Icon_Handle := GetIcon(334); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}				  BackColor(WhiteColor);                  ForeColor(BlackColor);					                      eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;              Setrect(TheIconRect, 95, 52, 128, 85); {Position of the Icon}              IF PtInRect(Strip_Pt, TheIconRect) THEN {In the icon ееCursorRightее }                BEGIN				  BackColor(WhiteColor);                  ForeColor(BlackColor);                  Track_the_Icon(335, 10335, TheIconRect); {Track the Icon}                  IF (PtInRect(Strip_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                    { BigScale := BigScale + 0.01;}					 			 IF not OptionKeyDown then             Fat_amount := Fat_amount + 0.5 			 ELSE Fat_amount := Fat_amount + 5;               Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;              Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30;			   			  The_Amplitude := BigScale * TheGlobal_LValue ;			  			  LoadPeaks;              FOR nn := ChannelMin TO ChannelMax DO                BEGIN                  Plt_spec[9]^^.S[nn] := col_6^[nn] - Gen_P^[nn];                  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts < Plt_spec[9]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_spec[9]^^.S[nn];               (*   IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > Plt_spec[10]^^.S[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_spec[10]^^.S[nn];               *)  IF Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts > col_1^[nn] THEN                    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := col_1^[nn];                END;              Update_Full;				  BackColor(WhiteColor);                  ForeColor(BlackColor);					 					 					                     END; {End of released in the Icon}                  SetPort(Strip_PeakWindow);                  Icon_Handle := GetIcon(335); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}				  BackColor(WhiteColor);                  ForeColor(BlackColor);					                      eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;            END;          {ееее}          IF (Strip_PeakWindow <> NIL) THEN            BEGIN			                ShowWindow(Strip_PeakWindow); { To make visible first time used, invisible in resource to clean up the                                             startup }              code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}               IF (myEvent.what = MouseDown) AND (Strip_PeakWindow = whichWindow) THEN                BEGIN                  Peak_Pt := myEvent.where;                  WITH Strip_PeakWindow^.portBits.bounds DO {Make it relative}                    BEGIN                      Peak_Pt.h := Peak_Pt.h + left;                      Peak_Pt.v := Peak_Pt.v + top;                    END;                END;              IF (Strip_PeakWindow = whichWindow) AND (code = inContent) THEN                BEGIN                  code := FindControl(Peak_Pt, whichWindow, Peak_Control); {Get type of control}                  IF (code <> 0) THEN code := TrackControl(Peak_Control, Peak_Pt, NIL); {Track the control}                  IF code = kControlButtonPart THEN Do_A_Button;                  IF code = kControlCheckBoxPart THEN Do_A_Checkbox;                  IF (code = kControlUpButtonPart) OR (code = kControlDownButtonPart) OR (code = kControlIndicatorPart) OR (code = kControlPageDownPart) OR (code =                     kControlPageUpPart) THEN                    Do_A_Scrollbar(code); {Do scrollbars}                END; {End for if (Strip_PeakWindow=whichWindow)}            END;        END;		SetFont('Chicago', 12, []); { The System Font }    END; {End of procedure}  {=================================}  PROCEDURE Init_My_Windows;    BEGIN      Strip_PeakWindow := NIL;	  Main_ID_Window := NIL;	  ROIWindow := NIL;    END; {End of procedure}  {=================================} (* PROCEDURE Init_Strip_Peak;    BEGIN      Strip_PeakWindow := NIL;    END; {End of procedure}*)  {=================================}  PROCEDURE Close_Strip_Peak(whichWindow: WindowPtr );    BEGIN      IF (Strip_PeakWindow <> NIL) AND (Strip_PeakWindow = whichWindow) THEN        BEGIN           DisposeWindow(Strip_PeakWindow);          Strip_PeakWindow := NIL;        END; {End for if (Strip_PeakWindow<>nil)}    END; {End of procedure}  {=================================}{$S SiLiWindow3}  PROCEDURE D_Spectrum_CopyW;    CONST	  I_Return  = 1;    VAR      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      DItem                         : Handle;      CItem			                : ControlHandle;      itemHit                       : Integer;	  olditemHit                    : Integer;                          Copy_ExitDialog               : Boolean;	      BEGIN      GetSelection := GetNewDialog(445, NIL, pointer( - 1));	  temprect := GetSelection^.portRect;   	  MoveWindow(GetSelection,MaxWindowRect.Left+8,MaxWindowRect.Bottom-123+7,TRUE ); 	  FillWhiteSpace(temprect);      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);	          GetDialogItem(GetSelection, I_Return, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      Copy_ExitDialog := False;      OlditemHit := 0;	   REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        IF (itemHit = I_Return) or ( OlditemHit = itemHit ) THEN          BEGIN            Copy_ExitDialog := True; {Exit the dialog}          END		  { for itemHit := 2 to 10 }        ELSE IF (itemHit < 11) and (itemHit > 1) THEN          BEGIN 			BlockMove(@Plt_spec[itemHit-1]^^,@Plt_spec[10]^^,SizeOf(Plt_spec[10]^^));            SpecWork_has_been_Changed := True;            Spectrum_Full[10] := True;            CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);			BeepBeep;          END        { for itemHit := 11 to 19 }        ELSE IF (itemHit > 10) AND (itemHit < 20) THEN          BEGIN 			BlockMove(@Plt_spec[10]^^,@Plt_spec[itemHit - 10]^^,SizeOf(Plt_spec[itemHit - 10]^^));            Spectrum_Full[itemHit - 10] := True;            CheckItem(FullMenu, A^.C_Full[itemHit - 10], Spectrum_Full[itemHit - 10]);			BeepBeep;          END;		OlditemHit := itemHit;		       UNTIL Copy_ExitDialog;      Update_Full;      Refresh_ROIs;      DisposeDialog(GetSelection);      Mouse_Active_Window;    END; {End of procedure}  {=================================}  PROCEDURE D_Spectrum_CopyR;    CONST   I_Return  = 1;       VAR      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      DItem                         : Handle;      CItem			                : ControlHandle;      itemHit                       : Integer;	  OlditemHit                    : Integer;      Copy_ExitDialog               : Boolean;	      BEGIN      GetSelection := GetNewDialog(1345, NIL, pointer( - 1));	  temprect := GetSelection^.portRect; 	  MoveWindow(GetSelection,MaxWindowRect.Left+8,MaxWindowRect.Bottom-123+7,TRUE ); 	  FillWhiteSpace(temprect);       ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);	          GetDialogItem(GetSelection, I_Return, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);	        OlditemHit := 0;      Copy_ExitDialog := False;      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := ControlHandle(DItem);        IF (itemHit = I_Return) or ( OlditemHit = itemHit ) THEN          BEGIN            Copy_ExitDialog := True; {Exit the dialog}          END		        { for itemHit := 2 to 10 right side}        ELSE IF (itemHit = 10) THEN          BEGIN 			BlockMove(@Plt_spec[10]^^,@Plt_spec[9]^^,SizeOf(Plt_spec[9]^^));            Spectrum_Full[9] := True;            CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);			BeepBeep;          END        ELSE          IF (itemHit < 10) and (itemHit > 1) THEN            BEGIN 			  BlockMove(@Plt_spec[itemHit-1]^^,@Plt_spec[9]^^,SizeOf(Plt_spec[9]^^));              Spectrum_Full[9] := True;              CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);			  BeepBeep;            END;        { for itemHit := 11 to 19 left side}        IF (itemHit = 19) THEN          BEGIN 			BlockMove(@Plt_spec[9]^^,@Plt_spec[10]^^,SizeOf(Plt_spec[10]^^));            SpecWork_has_been_Changed := True;            Spectrum_Full[10] := True;            CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);			BeepBeep;          END        ELSE          IF (itemHit >= 11) AND (itemHit < 19) THEN            BEGIN 			  BlockMove(@Plt_spec[9]^^,@Plt_spec[itemHit - 10]^^,SizeOf(Plt_spec[itemHit - 10]^^));              Spectrum_Full[itemHit - 10] := True;              CheckItem(FullMenu, A^.C_Full[itemHit - 10], Spectrum_Full[itemHit - 10]);			  BeepBeep;            END;		OlditemHit := itemHit;			UNTIL Copy_ExitDialog;      Update_Full;      Refresh_ROIs;		      DisposeDialog(GetSelection);      Mouse_Active_Window;    END; {End of procedure}   PROCEDURE Update_SiLi_Thumbs;    BEGIN      Delta := ChannelMax - ChannelMin + 1;	{number of chs being displayed}      IF ChannelMin < 1 THEN	  begin	  	ChannelMin := 1;      	ChannelMax := ChannelMin + Delta;	  end;	  IF ChannelMax > Spectrum_Size THEN		   BEGIN		 ChannelMax := Spectrum_Size;		 ChannelMin := ChannelMax - Delta;	   END;		 SiLi_Thumb_Position := rinttol(Delta/2 + ChannelMin - 1);		 SiLi_Thumb_Position := rinttol( 8192/Spectrum_Size * SiLi_Thumb_Position );          SiLi_Energy_Value := SiLi_Thumb_Position;         SetControlValue(Energy_SiLi_CtrlHandle, SiLi_Energy_Value  );       END;  {===========================================================}  PROCEDURE Do_SiLi_Window(myEvent: EventRecord );    CONST      SiLi_CopyW                    = 685;            {Button ID}      SiLi_CopyR                    = 686;            {Button ID}      SiLi_Rotate                   = 6685;           {Button ID}      SiLi_Review                   = 648;            {Button ID}      SiLi_Math                     = 647;            {Button ID}      SiLi_Calibrate                = 646;            {Button ID}      SiLi_Simplex                  = 1646;           {Button ID}      SiLi_ML_Lst_Sq                = 1647;           {Button ID}      SiLi_Do_Fit                   = 1648;           {Button ID}      SiLi_Add_Fit                  = 1649;           {Button ID}      SiLi_CLC                      = 548;            {Button ID}      SiLi_Fix                      = 339;            {Button ID}      SiLi_Pick                     = 3391;           {Button ID}      SiLi_MarkersOff               = 344;                    {SiLi_MarkersOn                = 516;  }                 SiLi_Peak_ID                  = 1595;           {Button ID}      SiLi_ROI                      = 610;            {Button ID}      {SiLi_Strip_Escapes            = 960;   }         {Button ID}      {SiLi_Strip_Peaks              = 1769;   }        {Button ID}      SiLi_Save_Work                = 1059;           {Button ID}      SiLi_Auto                     = 332;            {Checkbox ID}      SiLi_Expand_Energy            = 500;            {Radio ID}      SiLi_Contract_Energy          = 502;            {Radio ID}      SiLi_Expand_Vert              = 504;            {Radio ID}	  SiLi_Contract_Vert            = 506;            {Radio ID}      SiLi_Bipolar                  = 1024;           {Radio ID}      SiLi_Lin                      = 308;            {Radio ID}      SiLi_Sqrt                     = 309;            {Radio ID}      SiLi_Log                      = 310;            {Radio ID}      SiLi_Vertical                 = 652;            {Scroll bar ID}      SiLi_Energy                   = 650;            {Scroll bar ID}      SiLi_512                      = 131;            { button }      SiLi_1024                     = 132;      SiLi_2048                     = 133;      SiLi_4096                     = 134;      SiLi_8192                     = 135;    VAR      Icon_Handle                   : Handle;      TheIconRect                   : Rect;      InIcon                        : boolean;      RefCon                        : LongInt;      code                          : Integer;      whichWindow                   : WindowPtr;      errCode                       : Integer;      bytecount                     : LongInt;      Index			                : Integer;    PROCEDURE Do_A_Button;            VAR        Index		                : Integer;      BEGIN        {Hilitecontrol(SiLi_Control, 10);} {Darken the button}        RefCon := GetControlReference(SiLi_Control);        CASE RefCon OF {Select correct button}          SiLi_CopyW: {Copy}            BEGIN              D_Spectrum_CopyW;            END;          SiLi_CopyR: {Copy}            BEGIN              D_Spectrum_CopyR;            END;          SiLi_512:            BEGIN              Range_Keeper := 6;              Spectrum_Size := 512;              New_Range := 512;              ChannelMax := 512;              ChannelMin := 1;			  InValRect(SiLi_512CntHdl^^.ContrlRect);			  IF SiLi_1024CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_1024CntHdl^^.ContrlRect);			  IF SiLi_2048CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_2048CntHdl^^.ContrlRect);			  IF SiLi_4096CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_4096CntHdl^^.ContrlRect);			  IF SiLi_8192CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_8192CntHdl^^.ContrlRect);			                IF Det_Effic_P^[Spectrum_Size - 10] = 0 THEN{resp curve smaller or <>exist}                BEGIN                  SiLi_Response_Calculated := False; { Force a recalculation }                  Called_for_Generate := False;                  Called_for_Work_Spec := True;                END;              Update_Full; { еneeded }            END;          SiLi_1024:            BEGIN              Range_Keeper := 7;              Spectrum_Size := 1024;              New_Range := 1024;              ChannelMax := 1024;              ChannelMin := 1;			  IF SiLi_512CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_512CntHdl^^.ContrlRect);			  InValRect(SiLi_1024CntHdl^^.ContrlRect);			  IF SiLi_2048CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_2048CntHdl^^.ContrlRect);			  IF SiLi_4096CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_4096CntHdl^^.ContrlRect);			  IF SiLi_8192CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_8192CntHdl^^.ContrlRect);		                IF Det_Effic_P^[Spectrum_Size - 10] = 0 THEN                BEGIN                  SiLi_Response_Calculated := False; { Force a recalculation }                  Called_for_Generate := False;                  Called_for_Work_Spec := True;                END;              Update_Full; { еneeded }            END;          SiLi_2048:            BEGIN              Range_Keeper := 8;              Spectrum_Size := 2048;              New_Range := 2048;              ChannelMax := 2048;              ChannelMin := 1;			  IF SiLi_512CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_512CntHdl^^.ContrlRect);			  IF SiLi_1024CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_1024CntHdl^^.ContrlRect);			  InValRect(SiLi_2048CntHdl^^.ContrlRect);			  IF SiLi_4096CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_4096CntHdl^^.ContrlRect);			  IF SiLi_8192CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_8192CntHdl^^.ContrlRect);			                IF Det_Effic_P^[Spectrum_Size - 10] = 0 THEN                BEGIN                  SiLi_Response_Calculated := False; { Force a recalculation }                  Called_for_Generate := False;                  Called_for_Work_Spec := True;                END;              Update_Full; { еneeded }            END;          SiLi_4096:            BEGIN              Range_Keeper := 9;              Spectrum_Size := 4096;              New_Range := 4096;              ChannelMax := 4096;              ChannelMin := 1;			  IF SiLi_512CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_512CntHdl^^.ContrlRect);			  IF SiLi_1024CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_1024CntHdl^^.ContrlRect);			  IF SiLi_2048CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_2048CntHdl^^.ContrlRect);			  InValRect(SiLi_4096CntHdl^^.ContrlRect);			  IF SiLi_8192CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_8192CntHdl^^.ContrlRect);			                IF Det_Effic_P^[Spectrum_Size - 10] = 0 THEN                BEGIN                  SiLi_Response_Calculated := False; { Force a recalculation }                  Called_for_Generate := False;                  Called_for_Work_Spec := True;                END;               Update_Full; { еneeded }            END;          SiLi_8192:            BEGIN              Range_Keeper := 10;              Spectrum_Size := 8192;              New_Range := 8192;              ChannelMax := 8192;              ChannelMin := 1;			  IF SiLi_512CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_512CntHdl^^.ContrlRect);			  IF SiLi_1024CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_1024CntHdl^^.ContrlRect);			  IF SiLi_2048CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_2048CntHdl^^.ContrlRect);			  IF SiLi_4096CntHdl^^.contrlHilite=10 THEN InValRect(SiLi_4096CntHdl^^.ContrlRect);			  InValRect(SiLi_8192CntHdl^^.ContrlRect);			                IF Det_Effic_P^[Spectrum_Size - 10] = 0 THEN                BEGIN                  SiLi_Response_Calculated := False; { Force a recalculation }                  Called_for_Generate := False;                  Called_for_Work_Spec := True;                END;              Update_Full; { еneeded }            END;          SiLi_Rotate: {It was decided not to rotate the headers. Only the spectra get moved.}            BEGIN { To move header info the user must use one of the "copy" options }             Rotate_W_R;            END;          SiLi_Math: {Math}            BEGIN              D_Math_Window;              Mouse_Active_Window;            END;          SiLi_Review: {See Fit}            BEGIN			   See_A_Fit;             END;          SiLi_Calibrate: {Calibrate}            BEGIN              Open_Calibrate; {calls Mouse_Active_Window}            { Mouse_Active_Window; ...sets Calibrate_Window_Active := true;}			{ MCA.p calls Do_Calibrate, Update_Calibrate; etc}            END;          SiLi_Simplex: { there must be a spectrum in work }            BEGIN			if LLSQ_active then 			  BEGIN			    {Clear_the_Rois;}				LLSQ_active := False;			  END;			Refresh_ROIs;              D_Simplex;			  if not Quick_Exit then				begin				  Simplex_Start;				 (* Simplex_active := True;				  LLSQ_active := False;				  Hall_Active := False;   ...these are set inside Simplex_Start IF...*)				  Mouse_Active_Window;				end;			{Hilitecontrol(SiLi_DoFitCntlHdl, 0);}			{UpDate_SiLi_Window(SiLiWindow);}            END;          SiLi_ML_Lst_Sq:            BEGIN          (*    if (Calibrate_Energy_Scale) and (LLSQ_active) then               begin                putmessage('The "Calibrate the Energy Scale" feature is "on", LLSQ does not',			               'work under these conditions. I will turn calibration off and proceed.','','');			    Calibrate_Energy_Scale := FALSE;			   end;  *)               Fit_Invisibly := False;			if Simplex_active then 			  BEGIN			    {Clear_the_Rois;}				Simplex_active := False;			  END;				  Refresh_ROIs;              D_Ml_Dial;              Mouse_Active_Window;			  {Hilitecontrol(SiLi_DoFitCntlHdl, 0);}			  {UpDate_SiLi_Window(SiLiWindow);}            END;          SiLi_Do_Fit:            BEGIN			  If (Simplex_Active) then 			  Begin				  CompareGen_To_Work(theBGRec);	{in global_functions}				  IF (SiLi_Response_Calculated = False) { if a new spectrum in work...}				  THEN 				  BEGIN					GenFromWork(theBGRec);	{gets theGenRec values from Work }					Detector_efficiency(theBGRec,SiLi_Response_Calculated);				  END;			  End;			  is_batch := False; 			  Do_A_Fit; {sets Results_added to False}			 (* Hilitecontrol(SiLi_AddFitCntlHdl, 0);			  Hilitecontrol(SiLi_SeeFitCntlHdl, 0);			  UpDate_SiLi_Window(SiLiWindow);*)            END;            SiLi_Add_Fit:		  Begin			 IF (LLSQ_active) OR (Simplex_active) then begin			  { Hilitecontrol(SiLi_Control, 0);}			   If results_added then				   Putmessage('You have already appended these results to the output file', '', '', '')			   Else Add_A_Fit; {sets Results_added to True}			 END			 ELSE putmessage('There is no fit to ADD.','','','');		  		  		  END;	{SiLi_Add_Fit}           SiLi_CLC: {fst}            BEGIN				if ItsBeenAcquired then				    if not Answermessage('You are about to overwrite an unsaved spectrum in work!!!!!',			                    'If "It`s OK" I will do this, if "It`s NOT OK" then I wont.',								'','') then EXIT(Do_SiLi_Window);			   ItsBeenAcquired := FALSE;								errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;				IF errCode <> NoErr THEN				  BEGIN					BeepBeep;					Putmessage('A DTSA or Reference file must be selected (active) ',							   'to use the "Spectrum Number" controls.', '', '');				  END;              IF errCode = NoErr THEN              BEGIN                  For index := 1 to Maximum_Channels do Plt_spec[10]^^.S[index] := 0.0;				  Restore_Expt_Header( Hold_RefNum );                  Spectrum_Counter := Plt_spec[10]^^.Expt_Info.FirstSpec;                  IF (display_ref) THEN                    BEGIN                      PlotMLReference; { read bytecount = Ref_stuff...makes and disposes handle }                    END { IF (Display_Ref)...}                  ELSE                    BEGIN                      errCode := SetFPos_err(Hold_RefNum, fsFromStart, 0,'');                      bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts) + 					                      Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;                      errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[10]^^,'');                    END; { else begin...}                  Spec_Displayed := Spectrum_Counter;                  { always end with this set to the # of spectrum displayed }                  Spectrum_Full[10] := True;                  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                  Refresh_ROIs;                  UpDate_Max_Min(10);                  Update_Full;                  SpecWork_has_been_Changed := True;	              saved_displayed := true;                END; {ELSE...}              errCode := FSClose(Hold_RefNum);              errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);            END;          SiLi_Fix: {Lst}            BEGIN				if ItsBeenAcquired then				    if not Answermessage('You are about to overwrite an unsaved spectrum in work!!!!!',			                    'If "It`s OK" I will do this, if "It`s NOT OK" then I won`t.',								'','') then EXIT(Do_SiLi_Window);			   ItsBeenAcquired := FALSE;								errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;				IF errCode <> NoErr THEN				  BEGIN					BeepBeep;					Putmessage('A DTSA or Reference file must be selected (active) ',							   'to use the "Spectrum Number" controls.', '', '');				  END;              IF errCode = NoErr THEN              BEGIN                 For index := 1 to Maximum_Channels do Plt_Spec[10]^^.S[index] := 0.0;				  				  Restore_Expt_Header( Hold_RefNum );					                   Spectrum_Counter := Plt_spec[10]^^.Expt_Info.LastSpect;                  IF (display_ref) THEN                    BEGIN                      bytecount := sizeof(expt_infoRec) + (longint(Spectrum_Counter) - 1) * Longint(sizeof(References_Rec));                      errCode := SetFPos_err(Hold_RefNum, fsFromStart, bytecount,'');                      PlotMLReference; { read bytecount = Sizeof(References_Rec) }                    END                  ELSE                    BEGIN                      bytecount := sizeof(expt_infoRec) + sizeof(Plot_infoRec) + 					                     (longint(Spectrum_Counter) - 1) * (sizeof(Spectrum_Structure) + 										 Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4);                      errCode := SetFPos_err(Hold_RefNum, fsFromStart, bytecount,'');                      bytecount := sizeof(Spectrum_Structure);                      errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff,'');                      bytecount := Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;                      errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.S,'');                    END;                  Spec_Displayed := Spectrum_Counter;                  Spectrum_Full[10] := True;                  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                  Refresh_ROIs;                  UpDate_Max_Min(10);                  Update_Full;                  SpecWork_has_been_Changed := True;	              saved_displayed := true;                 END;              errCode := FSClose(Hold_RefNum);              errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);            END;          SiLi_Pick:            BEGIN			  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  RdBinaryName := Read_DTSA_Spec.name;              IF errCode <> NoErr THEN                BEGIN                  BeepBeep;                  Putmessage('A DTSA or Reference file must be selected (active) ', 'to use the Spectrum controls.', ''                             , '');                END              ELSE D_Spectrum_Picker;            END;          SiLi_MarkersOff:              BEGIN			  IF ShowMarkers = true Then			   begin				SetControlTitle(SiLi_CtrlHdl_Mark,'On');				ShowMarkers := False;			   end			  ELSE			   begin				SetControlTitle(SiLi_CtrlHdl_Mark,'Off');			    ShowMarkers := true;			   end;			   update_Full;            END;         (* SiLi_MarkersOn:              BEGIN             ShowMarkers := true;			 update_Full;            END;*)          SiLi_Peak_ID: {Peak ID}            BEGIN              Open_ID_Window;              Mouse_Active_Window;            END;          SiLi_ROI: {ROI}            BEGIN			  Refresh_ROIs;              Open_ROI_Window;             (* SelectWindow(ROIWindow);              ShowWindow(ROIWindow);              SetPort(ROIWindow);*)              Mouse_Active_Window;            END;         (* SiLi_Strip_Escapes: {Strip Escapes}            BEGIN              Escape_Peaks;            END;*)          (*SiLi_Strip_Peaks: {Strip Peaks}            BEGIN              Open_Strip_Peak;              Mouse_Active_Window;            END;*)          SiLi_Save_Work: {Save Work}            BEGIN {SiLi_Save_Work}             WorkSpectrum_To_Disk(10);	{Utilities}             END;            OTHERWISE { not case of...}            BEGIN              Putmessage('This message should not appear.', ' In trap location 3, in SiLi Window', '', '');            END;          END; {end of case}         Hilitecontrol(SiLi_Control, 0);  {Lighten the button}		      END;    PROCEDURE Do_A_Checkbox;      PROCEDURE Clear1radiogroup;                VAR          Index                         : Integer;        BEGIN          FOR Index := 1 TO 4 DO            SetControlValue(SiLi_R1Control[Index], 0);          Mouse_Function_Expand := False;          Mouse_Function_Contract := False;          Mouse_Vert_Expand := False;          Mouse_Vert_Contract := False;		          END;      PROCEDURE Clear3RadioGroup;                VAR          Index                         : Integer;        BEGIN          FOR Index := 1 TO 3 DO            SetControlValue(SiLi_R3Control[Index], 0);          Log_Scale_Display := False;          Square_Root_Display := False;          Linear_Display := False;        END;      BEGIN	{PROCEDURE Do_A_Checkbox;...}        RefCon := GetControlReference(SiLi_Control);        theValue := GetControlValue(SiLi_Control);        theValue := (theValue + 1) MOD 2;        CASE RefCon OF {Select correct button}          SiLi_Auto: {Auto, checkbox}            BEGIN			  ToggleAutoScale;            END;          SiLi_Expand_Energy: {Expand Energy }            BEGIN              Clear1radiogroup;              SetControlValue(SiLi_Control, 1);              Mouse_Function_Expand := True;              Update_Full;            END;          SiLi_Contract_Energy: {Contract Energy }            BEGIN              Clear1radiogroup;              SetControlValue(SiLi_Control, 1);              Mouse_Function_Contract := True;              Update_Full;            END;          SiLi_Expand_Vert:                                         BEGIN              Clear1radiogroup;                                     SetControlValue(SiLi_Control, 1);                         Mouse_Vert_Expand := True;            END;          SiLi_Contract_Vert:                                         BEGIN              Clear1radiogroup;                                     SetControlValue(SiLi_Control, 1);                         Mouse_Vert_Contract := True;            END;                     SiLi_Bipolar: {Bipolar }            BEGIN              SetControlValue(SiLi_Control, theValue);              Autovalue := GetControlValue(SiLi_Control);              IF Autovalue = 1 THEN Bipolar_Display := True;              IF Autovalue = 0 THEN Bipolar_Display := False;              Update_Full;            END;          SiLi_Lin: {Lin }            BEGIN              Clear3RadioGroup;              SetControlValue(SiLi_Control, 1);              Autovalue := GetControlValue(SiLi_Control);              IF Autovalue = 1 THEN Linear_Display := True;              IF Autovalue = 0 THEN Linear_Display := False;              Update_Full;            END;          SiLi_Sqrt: {Sqrt }            BEGIN              Clear3RadioGroup;              SetControlValue(SiLi_Control, 1);              Autovalue := GetControlValue(SiLi_Control);              IF Autovalue = 1 THEN Square_Root_Display := True;              IF Autovalue = 0 THEN Square_Root_Display := False;              Update_Full;            END;          SiLi_Log: {Log }            BEGIN              Clear3RadioGroup;              SetControlValue(SiLi_Control, 1);              Autovalue := GetControlValue(SiLi_Control);              IF Autovalue = 1 THEN Log_Scale_Display := True;              IF Autovalue = 0 THEN Log_Scale_Display := False;              Update_Full;            END;          OTHERWISE {allow other checkboxes and radios, trap for debug}            BEGIN              Putmessage('This message should not appear.', ' In trap location 1, in SiLi Window', '', '');            END;          END; {end of case}      END;    PROCEDURE Do_A_Scrollbar(code: Integer); {Handle a ScrollBar being pressed}      VAR        Start                         : Longint;        Stop                          : Longint;        Increment                     : Longint;        Lincrement                    : Longint;      BEGIN {Handle a ScrollBar being pressed}        RefCon := GetControlReference(SiLi_Control);        CASE RefCon OF {Select correct scrollbar}          SiLi_Vertical: {Vertical', scroll bar}            BEGIN              SiLi_Vert_Value := 1000 - GetControlValue(Vertical_SiLi_CtrlHandle); {Get current state}              Start := 0; { These are the endpoins of the scroll bar set in resource file }              Stop := 1000;              Increment := 5;              Lincrement := 50;              IF (code = kControlUpButtonPart) THEN {See if in the up/left arrow}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value + Increment; {Subtract the single decrement}                  IF (SiLi_Vert_Value < Start) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Start; {Bump at the start value}                END;              IF (code = kControlDownButtonPart) THEN {See if in the down/right arrow}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value - Increment; {Add the single increment}                  IF (SiLi_Vert_Value > Stop) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Stop; {Bump at the stop value}                END;              IF (code = kControlPageUpPart) THEN {See if in the up/left grey area}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value + Lincrement; {Subtract the page increment}                  IF (SiLi_Vert_Value < Start) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Start; {Bump at the Start value}                END;              IF (code = kControlPageDownPart) THEN {See if in the down/right grey area}                BEGIN                  SiLi_Vert_Value := SiLi_Vert_Value - Lincrement; {Add the page increment}                  IF (SiLi_Vert_Value > Stop) THEN {Check for boundary conditions}                    SiLi_Vert_Value := Stop; {Bump at the Stop value}                END;              IF (code = kControlIndicatorPart) THEN {See if in the drag box area}                BEGIN                  code := TrackControl(Vertical_SiLi_CtrlHandle, SiLi_Pt, NIL); {Let the OS drag it around}                  SiLi_Vert_Value := 1000 - GetControlValue(Vertical_SiLi_CtrlHandle); {Get current state}                END;              SetControlValue(Vertical_SiLi_CtrlHandle, 1000 - SiLi_Vert_Value); {Set new state}              { SiLi_Vert_Value is set in resource to go 0 to 1000 }              IF (Auto_Scale_Display = False) THEN { if auto scaling is on then skip this }                BEGIN                  V_Scale_Top := V_Scale_Top_Arrow * (2.001501502 - 1.501501502E-3 * SiLi_Vert_Value);                  V_Scale_Bottom := zero;				  Scale_Changed_Event := True;                END;              Update_Full;            END; {end for vertical scroll bar}          SiLi_Energy: { 'Energy', scroll bar}			{The scroll bar should work as follows: if the 2keV button is on, the scroll bar should			 carry from 0 keV to 2047 keV no matter what the expand button has done. So if expand			 has reduced the displayed segment to a 256 eV range, should be able to scroll that energy			 segment the full 2048 keV. The increment for moving changes with expand and			 contract. The scroll bar box shopuld go to middle of bar if I expand or contract			 around the center ch, to the left quarter if...}             BEGIN              Delta := ChannelMax - ChannelMin + 1;{...the num of chs showing}			 if Delta >= Spectrum_Size then			  begin			   putmessage('The Spectrum is already fully displayed, so I cannot shift it.',			              'To use the shift feature, expand the spectrum with the Expand button.',						  'The expanded energy range will be scrollable','through the full Spectrum channels.');			  end;              SiLi_Thumb_Position := rinttol( 8192/Spectrum_Size * (Delta/2 + ChannelMin-1));			  {...Spectrum_Size = 1024, Delta = 1024, ChannelMin = 1, then 			      SiLi_Thumb_Position = 4096 or the middle of the bar}              SiLi_Energy_Value := SiLi_Thumb_Position;              Start := 1;                 Stop := 8192 ;              Increment := 5;              Lincrement := 50;              IF (code = kControlUpButtonPart) THEN {See if in the left arrow}                BEGIN                  SiLi_Energy_Value := SiLi_Energy_Value - (Increment+ 5) ; {Subtract the single decrement}                  IF (SiLi_Energy_Value < Start) THEN {Check for boundary conditions}                    SiLi_Energy_Value := Start; {Bump at the start value}                 END;              IF (code = kControlDownButtonPart) THEN {See if in the right arrow}                BEGIN                  SiLi_Energy_Value := SiLi_Energy_Value + Increment; {Add the single increment}                  IF (SiLi_Energy_Value > Stop) THEN {Check for boundary conditions}                    SiLi_Energy_Value := Stop; {Bump at the stop value}                END;              IF (code = kControlPageUpPart) THEN {See if in the left grey area}                BEGIN                  SiLi_Energy_Value := SiLi_Energy_Value - Lincrement; {Subtract the page increment}                  IF (SiLi_Energy_Value < Start) THEN {Check for boundary conditions}                    SiLi_Energy_Value := Start; {Bump at the Start value}                END;              IF (code = kControlPageDownPart) THEN {See if in the right grey area}                BEGIN                  SiLi_Energy_Value := SiLi_Energy_Value + Lincrement; {Add the page increment}                  IF (SiLi_Energy_Value > Stop) THEN {Check for boundary conditions}                    SiLi_Energy_Value := Stop; {Bump at the Stop value}                END;              IF (code = kControlIndicatorPart) THEN {See if in the drag box area}                BEGIN                  code := TrackControl(Energy_SiLi_CtrlHandle, SiLi_Pt, NIL);                    SiLi_Energy_Value := GetControlValue(Energy_SiLi_CtrlHandle) ;                  END;                 SetControlValue(Energy_SiLi_CtrlHandle, SiLi_Energy_Value );                  SiLi_Thumb_Position := SiLi_Energy_Value;				                 ChannelMin := rinttol(SiLi_Thumb_Position * Spectrum_Size/8192 - Delta DIV 2); 				                                IF ChannelMin < 1 THEN ChannelMin := 1;              ChannelMax := ChannelMin + Delta;              IF ChannelMax > Spectrum_Size THEN               BEGIN                  ChannelMax := Spectrum_Size;                  ChannelMin := ChannelMax - Delta;               END;              Update_Full;            END; {end for this scroll bar}          OTHERWISE {allow other scrollbars (lists), trap for debug}            BEGIN {start}              Putmessage('This message should not appear.', ' In trap location 2, in SiLi Window', '', '');            END; {end of otherwise}          END; {end of case}      END; {Handle a ScrollBar being pressed}    PROCEDURE TrackIcon(NormIcon_ID, HilightIcon_ID: Integer; IconRect: Rect); {Track the Icon}      BEGIN {Start of Track the Icon}        Icon_Handle := GetIcon(HilightIcon_ID); {Get Hilighted Icon into memory}        IF (Icon_Handle <> NIL) THEN {Only do if we got the resource OK}          BEGIN {Get ready to plot the hilighted icon}            eraseRect(IconRect); {Erase the original icon}            PlotIcon(IconRect, Icon_Handle); {Draw the hilighted icon}          END; {End of drawing hilighted icon}        InIcon := True; {Flag as mouse in the Icon}        REPEAT {Start of mouse tracking routine}          GetMouse(SiLi_Pt); {Get latest mouse position}          IF (PtInRect(SiLi_Pt, IconRect)) THEN {See if still over the Icon}            BEGIN {...yes, over the Icon}              IF NOT (InIcon) THEN {See if mouse was out of Icon}                BEGIN {...yes, so it is unhilighted}                  Icon_Handle := GetIcon(HilightIcon_ID); {Get Hilighted Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have a hilighted Icon}                    BEGIN {...yes, have hilighted Icon}                      eraseRect(IconRect); {Erase the unhilighted icon}                      PlotIcon(IconRect, Icon_Handle); {Draw the hilighted icon}                    END; {End of Draw the hilighted icon}                  InIcon := True; {Flag that we drew the hilighted icon}                END;            END          ELSE            IF InIcon THEN {Then draw unhilighted Icon}              BEGIN {Start drawing unhilighted Icon}                Icon_Handle := GetIcon(NormIcon_ID); {Get standard Icon into memory}                IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                  BEGIN {...yes, have hilighted Icon}                    eraseRect(IconRect); {Erase the hilighted icon}                    PlotIcon(IconRect, Icon_Handle); {Draw the standard icon}                  END; {End of Draw the icon}                InIcon := False; {Flag as showing the unhilighted icon}              END;        UNTIL NOT (StillDown); {Loop till mouse button is released}      END; {End of the track Icon procedure}	    BEGIN      IF (SiLiWindow <> NIL) THEN        BEGIN          code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}          BackColor(WhiteColor);          ForeColor(BlackColor);          IF (myEvent.what = MouseDown) AND (SiLiWindow = whichWindow) THEN            BEGIN              SiLi_Pt := myEvent.where;              WITH SiLiWindow^.portBits.bounds DO {Make it relative}                BEGIN                  SiLi_Pt.h := SiLi_Pt.h + left;                  SiLi_Pt.v := SiLi_Pt.v + top;                END;               Setrect(tempRect, 364, 2, 464, 18);              IF PtInRect(SiLi_Pt, tempRect) THEN                BEGIN                  ChangedSelection := False;                  tempMenu := GetMenu(51);                  IF (tempMenu <> NIL) THEN                    BEGIN					 BackColor(WhiteColor);					  ForeColor(BlueColor); 					                      InsertMenu(tempMenu, - 1);                      tempRect.Right := 464;                      SiLi_Pt.v := -16 + (MarkerPopup - 1) * 16;	{this was 18}                      SiLi_Pt.h := 364;                      LocalToGlobal(SiLi_Pt);                      CheckItem(tempMenu, MarkerPopup, True);                      MemResult := PopUpMenuSelect(tempMenu, SiLi_Pt.v, SiLi_Pt.h, MarkerPopup);                      IF (MarkerPopup <> LoWord(MemResult)) AND (LoWord(MemResult) > 0) THEN                        BEGIN                          CheckItem(tempMenu, MarkerPopup, False);                          ChangedSelection := True;                          MarkerPopup := LoWord(MemResult);                        END                      ELSE CheckItem(tempMenu, MarkerPopup, False);                      DeleteMenu(51);                      IF ChangedSelection THEN                        BEGIN                          Setrect(tempRect, 364, 2, 464, 18);                          eraseRect(tempRect);                          MoveTo(tempRect.left + 4, tempRect.top + 12);                          CASE MarkerPopup OF { These labels appear in the little box before						                        a mouse down and sometime after startup, go to 												UpDate_SiLi_Window in Global_Functions.P for the 												list which is used at startup. The items which												are in the actual popup are in mca.r}                            1:                              BEGIN                                DrawString('Pks+Escs+Dbles');                                Marker_Sums := True;                                Marker_Escapes := True;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := False;                                Marker_WDS := False;                                Markers;                              END;                            2:                              BEGIN                                DrawString('+ Satellites');                                Marker_Sums := True;                                Marker_Escapes := True;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := True;                                Marker_WDS := False;                                Markers;                              END;                            3:                              BEGIN                                DrawString('Peaks Alone');                                Marker_Sums := False;                                Marker_Escapes := False;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := False;                                Marker_WDS := False;                                Markers;                              END;                            4:                              BEGIN                                DrawString('Excitation Edges');                                Marker_Sums := False;                                Marker_Escapes := False;                                Marker_Peaks := False;                                Marker_Edges := True;                                Marker_Satellites := False;                                Marker_WDS := False;                                Markers;                              END;                            5:                              BEGIN                                DrawString('WDS 2nd order');                                Marker_Sums := False;                                Marker_Escapes := False;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := False;                                Marker_WDS := True;                                WDS_Order := 2;                                Markers;                              END;                            6:                              BEGIN                                DrawString('WDS 3rd order');                                Marker_Sums := False;                                Marker_Escapes := False;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := False;                                Marker_WDS := True;                                WDS_Order := 3;                                Markers;                              END;                            7:                              BEGIN                                DrawString('WDS 4th order');                                Marker_Sums := False;                                Marker_Escapes := False;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := False;                                Marker_WDS := True;                                WDS_Order := 4;                                Markers;                              END;                            8:                              BEGIN                                DrawString('WDS 5th order');                                Marker_Sums := False;                                Marker_Escapes := False;                                Marker_Peaks := True;                                Marker_Edges := False;                                Marker_Satellites := False;                                Marker_WDS := True;                                WDS_Order := 5;                                Markers;                              END;                            OTHERWISE                              BEGIN                              END;                            END;							 Framerect(tempRect);							 BackColor(WhiteColor);                             ForeColor(BlackColor);                        END;                    END;                END; 				                    Setrect(TheIconRect, 475, 16, 507, 49); {Position of the Icon}                  IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {In the icon еееееееее ScaleUp еееееееее }                    BEGIN					  wait(10);					  IF StillDown THEN						BEGIN						  REPEAT							wait(2);							ScaleUp;						   UNTIL NOT StillDown;  						END;					                      TrackIcon(314, 10314, TheIconRect); {Track the Icon}                      IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {See if released in the Icon}                        BEGIN {...yes, released in the Icon}                          ForeColor(BlueColor);						  ScaleUp;						  Icon_Handle := GetIcon(314);                          IF Auto_Scale_Display THEN                            BEGIN							  UP_DowN := false;                              BackColor(WhiteColor);                              ForeColor(BlackColor);                            END                          ELSE                            BEGIN                              BackColor(WhiteColor);                              ForeColor(BlueColor);                            END;                          Setrect(tempRect, 475, 16, 507, 49); {left,top,right,bottom}                          IF (Icon_Handle <> NIL) THEN                            BEGIN                              PlotIcon(tempRect, Icon_Handle);                            END;                        END;                       SetPort(SiLiWindow);                      Icon_Handle := GetIcon(314); {Get standard Icon into memory}                      IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                        BEGIN {...yes, have hilighted Icon}                           ForeColor(BlueColor);                            eraseRect(TheIconRect); {Erase the hilighted icon}                          PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                        END; {End of Draw the icon}                    END;                  Setrect(TheIconRect, 475, 49, 507, 81); {Position of the Icon}				                    IF PtInRect(SiLi_Pt, TheIconRect) THEN {In the icon еееееееее ScaleDown ееееееее}                    BEGIN					 wait(10);					   IF StillDown THEN						 BEGIN						   REPEAT							 wait(2);							 ScaleDown;							UNTIL NOT StillDown;  						 END;										    TrackIcon(318, 10318, TheIconRect); {Track the Icon}                      IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {See if released in the Icon}                        BEGIN {...yes, released in the Icon}                          ForeColor(BlueColor);                            ScaleDown;                          Icon_Handle := GetIcon(318);                          IF Auto_Scale_Display THEN                            BEGIN							  UP_DowN := false;                              BackColor(WhiteColor);                              ForeColor(BlackColor);                            END                          ELSE                            BEGIN                              BackColor(WhiteColor);                              ForeColor(BlueColor);                            END;                          Setrect(tempRect, 475, 49, 507, 81); {left,top,right,bottom}                          IF (Icon_Handle <> NIL) THEN                            BEGIN                              PlotIcon(tempRect, Icon_Handle);                            END;                        END; {End of released in the Icon}                      SetPort(SiLiWindow);                      Icon_Handle := GetIcon(318); {Get standard Icon into memory}                      IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                        BEGIN {...yes, have hilighted Icon}                           ForeColor(BlueColor);                           eraseRect(TheIconRect); {Erase the hilighted icon}                          PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                        END; {End of Draw the icon}                     END;                               IF MCA_Spectrum_Active or display_ref THEN                BEGIN                  BackColor(WhiteColor);                 ForeColor(BlueColor); 				 ForeColor(BlackColor);                END              ELSE                BEGIN                  BackColor(WhiteColor);                  ForeColor(BlackColor);                END;              Setrect(TheIconRect, 364, 72, 396, 104); {Position of the Icon}              IF PtInRect(SiLi_Pt, TheIconRect) THEN {In the icon еееееееее CursorLeft еееееееее}                BEGIN                  IF (MCA_Spectrum_Active = False) AND (display_ref = False) THEN                    BEGIN                      BeepBeep;                      Putmessage('A DTSA or Reference file must be selected (active) ',                                 'to use the "Spectrum Number" controls.', '', '');                      exit(Do_SiLi_Window);                    END; { if MCA_Spectrum_Active = False...}				if ItsBeenAcquired then				    if not Answermessage('You are about to overwrite an unsaved spectrum in work!!!!!',			                    'If "It`s OK" I will do this, if "It`s NOT OK" then I wont.',								'','') then EXIT(Do_SiLi_Window);			   ItsBeenAcquired := FALSE;				                  TrackIcon(334, 10334, TheIconRect); {Track the Icon}                  IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                       ForeColor(BlueColor); 					  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  		RdBinaryName := Read_DTSA_Spec.name;                      IF errCode = NoErr THEN                        IF (Spec_Displayed > Displayed_Fst) THEN                          BEGIN                            For index := 1 to Maximum_Channels do Plt_Spec[10]^^.S[index] := 0.0;							                            Spectrum_Counter := Spec_Displayed - 1;							if Spectrum_Counter < 1 then Spectrum_Counter := 1;                            IF (display_ref) THEN                              BEGIN                                bytecount := sizeof(expt_infoRec) + (longint(Spectrum_Counter) - 1) *  sizeof(References_Rec);                                errCode := SetFPos_err(Hold_RefNum, fsFromStart, bytecount,'');                                PlotMLReference; { read bytecount = Sizeof(References_Rec) }                              END { If (Display_Ref)...}                            ELSE                              BEGIN							    Restore_Expt_Header( Hold_RefNum );                                bytecount := sizeof(expt_infoRec) + sizeof(Plot_infoRec) + 								             (longint(Spectrum_Counter) - 1) * ( sizeof(Spectrum_Structure) + 											 Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4);								{ to position mark at end of spectrum preceeding the spectrum of interest}                                errCode := SetFPos_err(Hold_RefNum, fsFromStart, bytecount,''); {end of preceeding spectrum }                                bytecount := sizeof(Spectrum_Structure); {ie SpectrumStuff}                                errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff,'');                                bytecount := Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;                                errCode := FSRead_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.S,'');                              END; { Else Begin...}                            Spec_Displayed := Spectrum_Counter;                            Spectrum_Full[10] := True;                            CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                            Refresh_ROIs;                            UpDate_Max_Min(10);                            Update_Full;                            SpecWork_has_been_Changed := True;	                        saved_displayed := true;                           END; { IF (Spec_Displayed > Displayed_Fst) then...}                      errCode := FSClose(Hold_RefNum);                      errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                    END; { IF (PtInRect(SiLi_Pt, TheIconRect))...}                  SetPort(SiLiWindow);				  BackColor(WhiteColor);			      ForeColor(BlueColor); 				                  Icon_Handle := GetIcon(334); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}					  ForeColor(BlueColor);                       eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;			 IF MCA_Spectrum_Active or display_ref THEN                BEGIN                  BackColor(WhiteColor);                  ForeColor(BlueColor);                 END              ELSE                BEGIN                  BackColor(WhiteColor);                  ForeColor(BlackColor);                END;              Setrect(TheIconRect, 396, 72, 428, 104); {Position of the Icon}              IF PtInRect(SiLi_Pt, TheIconRect) THEN {In the icon еееееееее CursorRight еееееееее}                BEGIN                  IF (NOT MCA_Spectrum_Active) AND (NOT display_ref) THEN                    BEGIN                      BeepBeep;                      Putmessage('A DTSA or Reference file must be selected (active) ',                                 'to use the "Spectrum Number" controls.', '', '');                      exit(Do_SiLi_Window);                    END;				if ItsBeenAcquired then				   if not Answermessage('You are about to overwrite an unsaved spectrum in work!!!!!',			                    'If "It`s OK" I will do this, if "It`s NOT OK" then I wont.',								'','') then EXIT(Do_SiLi_Window);				   ItsBeenAcquired := FALSE;				                  TrackIcon(335, 10335, TheIconRect); {Track the Icon}                  IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                      ForeColor(BlueColor);  					  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);				  		RdBinaryName := Read_DTSA_Spec.name;                      IF errCode <> NoErr THEN                        BEGIN                          BeepBeep;                          Putmessage('A FS Open error just occured', '', '', '');                        END {IF errCode <> NoErr...}                      ELSE                        IF (Spec_Displayed < Displayed_Lst) THEN                          BEGIN                           For index := 1 to Maximum_Channels do Plt_Spec[10]^^.S[index] := 0.0;                             Spectrum_Counter := Spec_Displayed + 1;							if Spectrum_Counter > Plt_spec[10]^^.Expt_Info.Lastspect then 							                Spectrum_Counter := Plt_spec[10]^^.Expt_Info.Lastspect;                            IF (display_ref) THEN                              BEGIN                                bytecount := sizeof(expt_infoRec) + (Spec_Displayed) * Longint( sizeof(References_Rec));                                errCode := SetFPos(Hold_RefNum, fsFromStart, bytecount);                                PlotMLReference;                              END { If (Display_Ref)...}                            ELSE                              BEGIN                                Restore_Expt_Header( Hold_RefNum );								{ this bytecount puts mark at end of spectrum currently displayed: }                                bytecount := sizeof(expt_infoRec) + sizeof(Plot_infoRec) + 								            (Spec_Displayed) * (sizeof( Spectrum_Structure) + 											Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4);                                errCode := SetFPos(Hold_RefNum, fsFromStart, bytecount); {end of preceeding spectrum }                                bytecount := sizeof(Spectrum_Structure); {ie SpectrumStuff}                                errCode := FSRead(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff);                                bytecount := Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;                                errCode := FSRead(Hold_RefNum, bytecount, @Plt_spec[10]^^.S);                              END; { Else Begin...}                            Spec_Displayed := Spec_Displayed + 1;                            Spectrum_Full[10] := True;                            CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                            Refresh_ROIs;                            UpDate_Max_Min(10);                            Update_Full;                            SpecWork_has_been_Changed := True;	                        saved_displayed := true;                           END; {IF ( Spec_Displayed < Displayed_Lst ) then...}                      errCode := FSClose(Hold_RefNum);                      errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                    END; { IF (PtInRect(SiLi_Pt, TheIconRect))... }                  SetPort(SiLiWindow);				  BackColor(WhiteColor);				  ForeColor(BlueColor);                    Icon_Handle := GetIcon(335); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}					 ForeColor(BlueColor);                        eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;              Setrect(TheIconRect, 364, 20, 396, 52); {Position of the Icon}			                IF PtInRect(SiLi_Pt, TheIconRect) THEN {In the icon ееееееееееееMarkerLeft ееееееееее}                BEGIN                  wait(10);                  IF StillDown THEN                    BEGIN                      REPEAT                        wait(2);                        LeftArrow := True;                        Markers;                      UNTIL NOT StillDown;                      SetPort(SiLiWindow);                    END;                  TrackIcon(336, 10336, TheIconRect); {Track the Icon}                  IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                      LeftArrow := True;                      Markers;                    END; {End of released in the Icon}                  SetPort(SiLiWindow);                  Icon_Handle := GetIcon(336); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}					  ForeColor(BlueColor);                      eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;              BackColor(WhiteColor);              ForeColor(BlueColor);              Setrect(TheIconRect, 396, 20, 428, 52); {Position of the Icon}              IF PtInRect(SiLi_Pt, TheIconRect) THEN {In the icon ееееееееееее MarkerRight ееееееее}                BEGIN                  wait(10);                  IF StillDown THEN                    BEGIN                      REPEAT                        wait(2);                        RightArrow := True;                        Markers;                      UNTIL NOT StillDown;                      SetPort(SiLiWindow);                    END;                  TrackIcon(337, 10337, TheIconRect); {Track the Icon}                  IF (PtInRect(SiLi_Pt, TheIconRect)) THEN {See if released in the Icon}                    BEGIN {...yes, released in the Icon}                      RightArrow := True;                      Markers;                    END; {End of released in the Icon}                  SetPort(SiLiWindow);                  Icon_Handle := GetIcon(337); {Get standard Icon into memory}                  IF (Icon_Handle <> NIL) THEN {Only do if we have the Icon}                    BEGIN {...yes, have hilighted Icon}					  ForeColor(BlueColor);                      eraseRect(TheIconRect); {Erase the hilighted icon}                      PlotIcon(TheIconRect, Icon_Handle); {Draw the standard icon}                    END; {End of Draw the icon}                END;            END;          IF (SiLiWindow = whichWindow) AND (code = inContent) THEN            BEGIN              code := FindControl(SiLi_Pt, whichWindow, SiLi_Control); {Get type of control}              IF (code <> 0) THEN code := TrackControl(SiLi_Control, SiLi_Pt, NIL); {Track the control}              IF code = kControlButtonPart THEN 			  	Do_A_Button			  ELSE IF code = kControlCheckBoxPart THEN Do_A_Checkbox              ELSE IF (code = kControlUpButtonPart) OR (code = kControlDownButtonPart) OR (code = kControlIndicatorPart) OR (code = kControlPageDownPart) OR (code =                 kControlPageUpPart) THEN                Do_A_Scrollbar(code); {Do scrollbars}				            END; {End for if (SiLiWindow=whichWindow)}			        END; {End for if (SiLiWindow<>nil)}		    END; {End of procedure}{$S SiLiWindow4}	procedure D_Auto_Peak_Options;	const		I_Accept = 1;		I_x = 2;		I_x3 = 3;		I_x5 = 4;		I_x7 = 5;		I_Bulk = 6; {radio button}		I_Thin = 7; {radio button}		var			GetSelection : DialogPtr;			tempRect : Rect;			DType : Integer;			Index : Integer;			CItem, DItem : Handle;			sTemp : Str255;			itemHit : Integer;			temp : Integer;		    ExitDialog : boolean;    	        str1,str2   : str255; 	 	begin			GetSelection := GetNewDialog(4255, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection); 			 			{Setup initial conditions}			IF (search_Range <= 1.0) then search_Range := 20.0;			realtostring(search_Range,5,2,str1);			GetDialogItem(GetSelection,I_x5,DType,DItem,tempRect);			SetDialogItemText(DItem,str1);						IF (sensi <= 0.5) then sensi := 2.5;			realtostring(sensi,5,2,str2);			GetDialogItem(GetSelection,I_x7,DType,DItem,tempRect);			SetDialogItemText(DItem,str2); 			   			IF Running_Thin_Mode THEN 			 BEGIN			   GetDialogItem(GetSelection, I_Bulk, DType, DItem, tempRect); 			   SetControlValue(ControlHandle(DItem), 0);			   GetDialogItem(GetSelection, I_Thin, DType, DItem, tempRect); 			   SetControlValue(ControlHandle(DItem), 1);			 END                                  			ELSE {IF Running_Bulk_Mode THEN } 			 BEGIN			   GetDialogItem(GetSelection, I_Bulk, DType, DItem, tempRect); 			   SetControlValue(ControlHandle(DItem), 1);			   GetDialogItem(GetSelection, I_Thin, DType, DItem, tempRect); 			   SetControlValue(ControlHandle(DItem), 0);			 END;			 				GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);				PenSize(3, 3);				InsetRect(tempRect, - 4, - 4);				FrameRoundRect(tempRect, 16, 16);				PenSize(1, 1);						ExitDialog:=FALSE;			 			repeat				ModalDialog(nil, itemHit);				GetDialogItem(GetSelection, itemHit, DType, CItem, tempRect);				 				if (ItemHit =I_Accept) then				begin					ExitDialog:=TRUE;				end;			   IF (itemHit >= I_Bulk) AND (itemHit <= I_Thin)				 THEN                                        				   BEGIN					 FOR Index := I_Bulk TO I_Thin DO {Clear all other radios}					   BEGIN						 GetDialogItem(GetSelection, Index, DType, DItem, tempRect); 						 SetControlValue(ControlHandle(DItem), 0);          					   END;                                  					 SetControlValue(ControlHandle(CItem), 1);                  				   END; 				 			until ExitDialog;			 			GetDialogItem(GetSelection,I_x5,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			search_Range :=  MyStr2Num(sTemp);						GetDialogItem(GetSelection,I_x7,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			sensi := MyStr2Num(sTemp);			Index := I_Bulk;                    			REPEAT                                          			  GetDialogItem(GetSelection, Index, DType, DItem, tempRect); 			  temp := GetControlValue(ControlHandle(DItem));                   			  Index := Index + 1;                           			UNTIL (temp <> 0) OR (Index > I_Thin); 						temp := Index - I_Bulk;             	            IF (temp = 1) THEN 	              begin	                Running_Bulk_Mode := True;      {**$$ change these $$**}	                Running_Thin_Mode := False;	              end;	            IF (temp = 2) THEN 	              begin	                Running_Thin_Mode := True;	                Running_Bulk_Mode := False;	              end;						DisposeDialog(GetSelection);					end;    (* PROCEDURE Init_ID_Window;    BEGIN      Main_ID_Window := NIL;    END; {End of procedure}*)  {=================================}  PROCEDURE Close_ID_Window(whichWindow: WindowPtr );    BEGIN      IF (Main_ID_Window <> NIL) AND (Main_ID_Window = whichWindow) THEN        BEGIN          DisposeWindow(Main_ID_Window);          Main_ID_Window := NIL;        END; {End for if (Main_ID_Window<>nil)}    END; {End of procedure}  {=================================}  PROCEDURE Update_ID_Window(whichWindow: WindowPtr);       BEGIN      IF (Main_ID_Window <> NIL) AND (Main_ID_Window = whichWindow) THEN        BEGIN          GetPort(GrafPtr(SavePort));          SetPort(Main_ID_Window);		  BeginUpdate(whichWindow);      {Set the clipping to the update area}          { Draw a line, Drawn line }          PenSize(3, 3);          MoveTo(122, 0); {Horz,vert, Move to starting position}          {   LINETO(122, 115);   } {Horz,vert, Draw to ending position}          PenSize(1, 1); {Restore the pen size to default}          { Draw a line, Drawn line }          PenSize(3, 3);          MoveTo(318, 0); {Horz,vert, Move to starting position}          {   LINETO(318, 115);   } {Horz,vert, Draw to ending position}          PenSize(1, 1); {Restore the pen size to default}          { Draw a line, Drawn line }          MoveTo( - 1, 15); {Horz,vert, Move to starting position}          {  LINETO(320, 15);  } {Horz,vert, Draw to ending position}          DrawControls(Main_ID_Window);		  EndUpdate(whichWindow);        {Return to normal clipping area}          SetPort(GrafPtr(SavePort));		          END; {End for if (Main_ID_Window<>nil)}    END; {End of procedure}  {=================================}  PROCEDURE Open_ID_Window;        CONST      ID_Return                     = 582;            {Button }	  ID_Save_Label_Set             = 583;            {Button }	  ID_Load_Label_Set             = 584;            {Button }	        ID_Clear_All                  = 843;            {Button }      {ID_Clear_Last                 = 844;}            {Button }      ID_Nearest_K                  = 587;            {Radio }      ID_Nearest_L                  = 588;            {Radio }      ID_Nearest_M                  = 589;            {Radio }      ID_Clear_Nearest              = 590;            {Radio }      {ID_Move_Nearest               = 591;}            {Radio }      ID_Clr_Family                 = 591;            {Radio }      ID_Majors_only                = 593;            {Radio }      ID_Minors_too                 = 594;            {Radio }      ID_Trace_too                  = 595;            {Radio }	  ID_Auto_Label                 = 596;            {Button }	  ID_Auto_Label_Options         = 597;            {Button }      ID_Shift_Limit                = 793;            {CheckBox}	  ID_text1						= 795;			  {CheckBox used as label}	  ID_text2						= 796;			  {CheckBox used as label}	  ID_text3						= 797;			  {CheckBox used as label}	  ID_text4						= 798;			  {CheckBox used as label}	  ID_text5						= 799;			  {CheckBox used as label}	  ID_text6						= 800;			  {CheckBox used as label}	      VAR    BEGIN      IF (Main_ID_Window = NIL) THEN        BEGIN          Main_ID_Window := GetNewWindow(338, NIL, pointer( - 1));		  MoveWindow(Main_ID_Window,MaxWindowRect.Left,MaxWindowRect.Bottom-123,TRUE );           SelectWindow(Main_ID_Window);          ShowWindow(Main_ID_Window);          SetPort(Main_ID_Window);          ID_CtrlHandle   := GetNewControl( ID_Return,        Main_ID_Window);		  ID_CtrlHandle   := GetNewControl( ID_Load_Label_Set, Main_ID_Window); 		  ID_CtrlHandle   := GetNewControl( ID_Save_Label_Set, Main_ID_Window);          ID_CtrlHandle   := GetNewControl( ID_Clear_All,     Main_ID_Window);          {ID_CtrlHandle   := GetNewControl( ID_Clear_Last,    Main_ID_Window);}		  ID_CtrlHandle   := GetNewControl( ID_Auto_Label,    Main_ID_Window);		  ID_CtrlHandle   := GetNewControl( ID_Auto_Label_Options, Main_ID_Window);		            ID_R2Control[1] := GetNewControl( ID_Nearest_K,     Main_ID_Window);			ReserveMem(SizeOf(ID_R2Control[1])); { Reserve memory near the beginning of heap }			HLock(Handle(ID_R2Control[1]));          ID_R2Control[2] := GetNewControl( ID_Nearest_L,     Main_ID_Window);			ReserveMem(SizeOf(ID_R2Control[2]));			HLock(Handle(ID_R2Control[2]));          ID_R2Control[3] := GetNewControl( ID_Nearest_M,     Main_ID_Window);			ReserveMem(SizeOf(ID_R2Control[3]));			HLock(Handle(ID_R2Control[3]));          ID_R2Control[4] := GetNewControl( ID_Clear_Nearest, Main_ID_Window);			ReserveMem(SizeOf(ID_R2Control[4]));			HLock(Handle(ID_R2Control[4]));          (*ID_R2Control[5] := GetNewControl( ID_Move_Nearest,  Main_ID_Window);			ReserveMem(SizeOf(ID_R2Control[5]));			HLock(Handle(ID_R2Control[5]));*)          ID_R2Control[5] := GetNewControl( ID_Clr_Family,    Main_ID_Window);			ReserveMem(SizeOf(ID_R2Control[5]));			HLock(Handle(ID_R2Control[5]));          ID_R3Control[1] := GetNewControl( ID_Majors_only,   Main_ID_Window);			ReserveMem(SizeOf(ID_R3Control[1]));			HLock(Handle(ID_R3Control[1]));          ID_R3Control[2] := GetNewControl( ID_Minors_too,    Main_ID_Window);		  	ReserveMem(SizeOf(ID_R3Control[2]));			HLock(Handle(ID_R3Control[2]));          ID_R3Control[3] := GetNewControl( ID_Trace_too,     Main_ID_Window);		  	ReserveMem(SizeOf(ID_R3Control[3]));			HLock(Handle(ID_R3Control[3]));		  ID_CtrlHandle   := GetNewControl( ID_Shift_Limit,   Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle));			HLock(Handle(ID_CtrlHandle));		  ID_CtrlHandle1[1]   := GetNewControl( ID_text1,    Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle1[1]));			HLock(Handle(ID_CtrlHandle1[1]));		  ID_CtrlHandle1[2]   := GetNewControl( ID_text2,    Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle1[2]));			HLock(Handle(ID_CtrlHandle1[2]));		  ID_CtrlHandle1[3]   := GetNewControl( ID_text3,    Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle1[3]));			HLock(Handle(ID_CtrlHandle1[3]));		  ID_CtrlHandle1[4]   := GetNewControl( ID_text4,    Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle1[4]));			HLock(Handle(ID_CtrlHandle1[4]));		  ID_CtrlHandle1[5]   := GetNewControl( ID_text5,    Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle1[5]));			HLock(Handle(ID_CtrlHandle1[5]));		  ID_CtrlHandle1[6]   := GetNewControl( ID_text6,    Main_ID_Window);			ReserveMem(SizeOf(ID_CtrlHandle1[6]));			HLock(Handle(ID_CtrlHandle1[6]));		            SelectWindow(Main_ID_Window);          Mouse_Active_Window;        END      ELSE        BEGIN          SelectWindow(Main_ID_Window);          Mouse_Active_Window;        END;    END;  {=================================}  PROCEDURE Do_ID_Window(myEvent: EventRecord );        CONST      ID_Return                     = 582;            {Button }	  ID_Save_Label_Set             = 583;            {Button }	  ID_Load_Label_Set             = 584;            {Button }      ID_Clear_All                  = 843;            {Button }      {ID_Clear_Last                 = 844;}            {Button }	  ID_Auto_Label                 = 596;            {Button }	  ID_Auto_Label_Options         = 597;            {Button }      ID_Nearest_K                  = 587;            {Radio }      ID_Nearest_L                  = 588;            {Radio }      ID_Nearest_M                  = 589;            {Radio }      ID_Clear_Nearest              = 590;            {Radio }      {ID_Move_Nearest               = 591;}            {Radio }      ID_Clr_Family                 = 591;            {Radio }      ID_Majors_only                = 593;            {Radio }      ID_Minors_too                 = 594;            {Radio }      ID_Trace_too                  = 595;            {Radio }      ID_Shift_Limit                = 793;            {CheckBox}	  ID_text1						= 795;			  {CheckBox used as label}	  ID_text2						= 796;			  {CheckBox used as label}	  ID_text3						= 797;			  {CheckBox used as label}	  ID_text4						= 798;			  {CheckBox used as label}	  ID_text5						= 799;			  {CheckBox used as label}	  ID_text6						= 800;			  {CheckBox used as label}	      VAR      RefCon                        : Integer;      code                          : Integer;      theValue                      : Integer;      whichWindow                   : WindowPtr;      myPt                          : Point;                theControl                    : ControlHandle;      refnum                        : integer;	  bytecount                     : longint;	        PROCEDURE Clear2radiogroup;                VAR          Index                         : Integer;        BEGIN          FOR Index := 1 TO 5 DO            SetControlValue(ID_R2Control[Index], 0);        END;            PROCEDURE Clear3RadioGroup;                VAR          Index                         : Integer;        BEGIN          FOR Index := 1 TO 3 DO            SetControlValue(ID_R3Control[Index], 0);        END;    PROCEDURE Do_A_Button;            VAR		nn                            : Integer;        {LABEL 100;}      BEGIN        Hilitecontrol(theControl, 10); {Darken the button}        RefCon := GetControlReference(theControl);        CASE RefCon OF {Select correct button}		          ID_Save_Label_Set:             BEGIN			  The_File_name := 'Peak_Labels_Setup';   { the user's choice replaces this }			  if (CreateFile(The_File_name, 'Save Set of Labels:') = True) OR							  (File_Cancel_Button = False) then;			  IF (File_Cancel_Button) THEN			  begin					 setup_vol := Out_VolRefNum;					 errCode := Create(The_File_name, setup_vol, 'DTSA', 'MCAk');					 save_setup := TRUE; 			  end;			  If (save_setup) then begin				  errCode := FSOpen_err(The_File_name, setup_vol, refnum,'save_setup');				  IF errCode = NoErr THEN 				  BEGIN					 errCode := SetEof(refnum,0);	{ in case using old filename}					 errCode := SetFPos_err(refnum, fsFromStart,0,'');					 bytecount := Sizeof(Labels); 					 errCode := FSWrite(refnum, bytecount, @Lab^^);					 errCode := FSClose(refnum);					 errCode := FlushVol(NIL, setup_vol);				  END				  ELSE					 putmessage('The file did not open','','', '');			  End;	{ If (save_setup)...}            END;          ID_Load_Label_Set:             BEGIN					mytype := 'MCAk';					myprompt := 'Load a Label Set';					   IF (GetFileName(The_File_name, mytype, mytype, myprompt)) then					   BEGIN					     setup_vol := 0; { for now force the default volume }					     errcode := FSOpen_err(The_File_name,setup_vol,RefNum,'ID_Load_Label_Set');					    IF errCode = NoErr then begin						   errcode := SetFPos_err(refnum,fsFromstart,0,'');						   bytecount := sizeof(Labels);						   errcode := FSRead_err(refnum,bytecount,@Lab^^,'');						   errcode := FSClose(refNum);						   errcode := FlushVol(nil,setup_vol);				  Label_Counter := 0;				  FOR nn := 0 TO MaxLabels DO					  if Lab^^.S[nn].Exists THEN Label_Counter := Label_Counter + 1;				  Update_Full;					   END;					   END;			END;          ID_Return:             BEGIN              Nearest_K := True;              Nearest_L := False;              Nearest_M := False;              Clr_One := False;              Clr_Family := False;              Clear2radiogroup;              SetControlValue(ID_R2Control[1], 1);			  HiliteControl(ID_CtrlHandle,0);			  HiliteControl(ID_CtrlHandle1[6],0);			  			                Open_Sili_Window;              Mouse_Active_Window;            END;          ID_Clear_All:             BEGIN              Label_Counter := 0;              Active_Peak_Label := 0;              FOR nn := 0 TO MaxLabels DO                BEGIN                  Lab^^.S[nn].Box.top := 10;                  Lab^^.S[nn].Box.Bottom := 20;                  Lab^^.S[nn].Box.left := 10;                  Lab^^.S[nn].Box.Right := 30;                  Lab^^.S[nn].Channel := 100;                  Lab^^.S[nn].XCenter := 200;                  Lab^^.S[nn].YCenter := 200;                  Lab^^.S[nn].Element := '';                  Lab^^.S[nn].Family := '';                  Lab^^.S[nn].Greek := '';                  Lab^^.S[nn].Exists := False;                  Lab^^.S[nn].Active := False;                END;              Update_Full;            END;         (* ID_Clear_Last:            BEGIN			  100 : FOR nn := 0 TO Label_Counter DO				BEGIN				  IF (Lab^^.S[nn].Element = Last_Label_Element) AND 					 (Lab^^.S[nn].Family[1] = Last_Label_Family[1]) THEN					BEGIN					  Lab^^.S[nn].Exists := False;					  Lab^^.S[nn].Active := False;					  FOR ii := nn TO Label_Counter-1 DO						Lab^^.S[ii] := Lab^^.S[ii + 1]; {shuffle down one}						Label_Counter := Label_Counter - 1;					  GOTO 100;					END; { IF (Lab^^.S[nn].Element =... }				END; { FOR nn := 0 to Label_Counter DO...}			  Update_Full;			  Last_Label_Element := '';			  Last_Label_Family := '';            END;		*)		ID_Auto_Label:		BEGIN		  Fit_Invisibly := false; 		  Main_Qual(Spec_Displayed);;		END;				ID_Auto_Label_Options:		BEGIN		  D_Auto_Peak_Options;		END;			          OTHERWISE;		            END; {end of case}		  		IF ((SiLi_512CntHdl<>theControl) or (SiLi_1024CntHdl<>theControl) or			(SiLi_2048CntHdl<>theControl) or (SiLi_4096CntHdl<>theControl) or			(SiLi_8192CntHdl<>theControl)) 			THEN Hilitecontrol(theControl, 0); 					{Lighten the button}      END;        PROCEDURE Do_A_Checkbox;      	  CONST		  ID_text6						= 800;			  {CheckBox used as label}      VAR        nn                         		  : Integer;		Text1, Text2					  : str255;            BEGIN	    Text1 := 'Move Labels by Dragging Vertically';		Text2 := 'Move Labels by Dragging';	          RefCon := GetControlReference(theControl);        theValue := GetControlValue(theControl);        theValue := (theValue + 1) MOD 2;        CASE RefCon OF          ID_Nearest_K: {Nearest K }            BEGIN              Nearest_K := True;              Nearest_L := False;              Nearest_M := False;              Clr_One := False;              Clr_Family := False;              Clear2radiogroup;              SetControlValue(theControl, 1);			  HiliteControl(ID_CtrlHandle,0);			  HiliteControl(ID_CtrlHandle1[6],0);			              END;          ID_Nearest_L: {Nearest L }            BEGIN              Nearest_L := True;              Nearest_K := False;              Nearest_M := False;              Clr_One := False;              Clr_Family := False;              Clear2radiogroup;              SetControlValue(theControl, 1);			  HiliteControl(ID_CtrlHandle,0);			  HiliteControl(ID_CtrlHandle1[6],0);			              END;          ID_Nearest_M: {Nearest M }            BEGIN              Nearest_M := True;              Nearest_L := False;              Nearest_K := False;              Clr_One := False;              Clr_Family := False;              Clear2radiogroup;              SetControlValue(theControl, 1);			  HiliteControl(ID_CtrlHandle,0);			  HiliteControl(ID_CtrlHandle1[6],0);            END;          ID_Clear_Nearest: {clear id pointed to }            BEGIN              Nearest_M := False;              Nearest_L := False;              Nearest_K := False;              Clr_One := True;              Clr_Family := False;              Clear2radiogroup;              SetControlValue(theControl, 1);			  HiliteControl(ID_CtrlHandle,255);			  HiliteControl(ID_CtrlHandle1[6],255);            END;        (*  ID_Move_Nearest: {move id pointed to }            BEGIN              Nearest_M := False;              Nearest_L := False;              Nearest_K := False;              Clr_One := False;              Clr_Family := False;              Clear2radiogroup;              SetControlValue(theControl, 1);            END;			*)          ID_Clr_Family: {clear family pointed to }            BEGIN              Nearest_M := False;              Nearest_L := False;              Nearest_K := False;              Clr_One := False;              Clr_Family := True;              Clear2radiogroup;              SetControlValue(theControl, 1);			  HiliteControl(ID_CtrlHandle,255);			  HiliteControl(ID_CtrlHandle1[6],255);            END;          ID_Majors_only:            BEGIN              One_Label := True;              Some_Labels := False;              All_Labels := False;              Clear3RadioGroup;              SetControlValue(theControl, 1);            END;          ID_Minors_too:            BEGIN              One_Label := False;              Some_Labels := True;              All_Labels := False;              Clear3RadioGroup;              SetControlValue(theControl, 1);            END;          ID_Trace_too:            BEGIN              One_Label := False;              Some_Labels := False;              All_Labels := True;              Clear3RadioGroup;              SetControlValue(theControl, 1);            END;          ID_Shift_Limit:			            BEGIN			  slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen );              IF theValue = 0 THEN 				 BEGIN				   Lab_Left_Limit     := 50;				   Lab_right_Limit    := 35;				   SetControlTitle(ID_CtrlHandle1[6],Text2);				 END;              IF theValue = 1 THEN				 BEGIN				   Lab_Left_Limit     := 0;				   Lab_right_Limit    := 0;				   SetControlTitle(ID_CtrlHandle1[6],Text1);				 END;				 FOR nn := 1 TO Label_Counter DO				 IF (Lab^^.S[nn].Exists) THEN Lab^^.S[nn].XCenter := 							   rinttol(( Lab^^.S[nn].Channel - ChannelMin + slopeX * 13) / slopeX);				               SetControlValue(theControl, theValue);			  Update_Full;			END;			          OTHERWISE            BEGIN            END;          END;      END;    BEGIN      IF (Main_ID_Window <> NIL) AND (ID_Window_Active) THEN        BEGIN          ShowWindow(Main_ID_Window);          code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}          IF (myEvent.what = MouseDown) AND (Main_ID_Window = whichWindow) THEN            BEGIN              myPt := myEvent.where;              WITH Main_ID_Window^.portBits.bounds DO {Make it relative}                BEGIN                  myPt.h := myPt.h + left;                  myPt.v := myPt.v + top;                END;            END;          IF (Main_ID_Window = whichWindow) AND (code = inContent) THEN            BEGIN              code := FindControl(myPt, whichWindow, theControl); {Get type of control}              IF (code <> 0) THEN code := TrackControl(theControl, myPt, NIL); {Track the control}              IF code = kControlButtonPart THEN Do_A_Button;              IF code = kControlCheckBoxPart THEN Do_A_Checkbox;            END; {End for if (Main_ID_Window=whichWindow)}        END; {End for if (Main_ID_Window<>nil)}    END; {End of procedure}  PROCEDURE Get_Nearest_Peak;    VAR       diff                         : Integer;      index1                        : Integer;      nn,j                          : Integer;      ii                            : Integer;      Y_Intercept, Y_Slope          : Real;      Place_it                      : Point;      LABEL 100;	      PROCEDURE Stuff_Label(Bump, Chan_num, x, y        : Integer; 	                      symb                        : Str_2; 						  Family                      : Str_4; { K,L,M, M2N4 etc.}                          Greek                       : Str_4 { 'alpha'1,2 etc}                          );      {ее "x" not used it can be jerked }		VAR 		  jj,kk : integer;		  pt : point;      BEGIN        Label_Counter := Bump + 1;        IF Label_Counter > MaxLabels THEN          BEGIN            Putmessage('You have exceeded the limit for the number of labels', '', '', '');			Label_Counter := MaxLabels;            exit(Stuff_Label);          END;        slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen );		Lab^^.S[Label_Counter].Channel := Chan_num;		Lab^^.S[Label_Counter].ShiftedChannel := Chan_num;		Lab^^.S[Label_Counter].V_Scale_Top      := V_Scale_Top;    { еREAL, at the time of creation }		Lab^^.S[Label_Counter].V_Scale_Bottom   := V_Scale_Bottom; { еREAL, at the time of creation }		if y > Full_Bottom_Screen - 5 then y := Full_Bottom_Screen - 5 ;        		j := rinttol(( Chan_num - ChannelMin + slopeX * 13) / slopeX);						for kk := 1 to Label_Counter-1 do		for jj := 1 to Label_Counter-1 do		  begin		     pt.v := y;		     pt.h := j;		    if PtInRect(pt, Lab^^.S[jj].Box) then y := y - 8;			if y < Full_Top_Screen + 5 then y := Full_Top_Screen + 5;		  end;		          Lab^^.S[Label_Counter].XCenter := j;		IF (Lab^^.s[Label_Counter].XCenter <= Full_Left_Screen + 20) then Lab^^.s[Label_Counter].XCenter := Full_Left_Screen + 20;		Lab^^.S[Label_Counter].YCenter := y;		Lab^^.S[Label_Counter].Box.Left  := Lab^^.S[Label_Counter].XCenter - 20;		{if (Lab^^.S[Label_Counter].Box.Left < -10) then Lab^^.S[Label_Counter].Box.Left := -10;}		Lab^^.S[Label_Counter].Box.Top   := Lab^^.S[Label_Counter].YCenter - 6;		SetRect(Lab^^.S[Label_Counter].Box, Lab^^.S[Label_Counter].Box.Left, 								 Lab^^.S[Label_Counter].Box.Top, 								 Lab^^.S[Label_Counter].Box.Left + 35, 								 Lab^^.S[Label_Counter].Box.Top + 12);        Lab^^.S[Label_Counter].Element := symb;        Lab^^.S[Label_Counter].Family := Family;        Lab^^.S[Label_Counter].Greek := Greek;        Lab^^.S[Label_Counter].Exists := True;	    Last_Label_Element := symb;        Last_Label_Family := Family;      END;	{PROCEDURE Stuff_Label}    BEGIN	{PROCEDURE Get_Nearest_Peak}      GetMouse(Place_it); {use the local coordinates since that is what moveto uses }      MoveTo(Place_it.h, Place_it.v); { Move to where the mouse is }      Y_Slope := (Full_Top_Screen - Full_Bottom_Screen) / 100;      Y_Intercept := Full_Bottom_Screen;          {  slopeY := (Pix_Y_Max - Pix_Y_Min) / (DataMax - DataMin);            InterceptY := Pix_Y_Min - slopeY * DataMin;           }      diff := 5; { Number of channels + and - about each mouse click channel to search from }      IF (Clr_One) {AND (NOT F1Down)} THEN        FOR index1 := 0 TO Label_Counter DO          IF PtInRect(Place_it, Lab^^.S[index1].Box) THEN { we are in the box }            BEGIN            (*  Lab^^.S[index1].Exists := False;              Lab^^.S[index1].Active := False; *){ Active means the mouse is in the rect }              FOR nn := index1 TO Label_Counter-1 DO                Lab^^.S[nn] := Lab^^.S[nn + 1]; { shuffle down one }				Label_Counter := Label_Counter - 1;			  FOR nn := Label_Counter+1 to MaxLabels DO Lab^^.S[nn].Exists := False; { paranoia }              Update_Full;            END;      IF (Clr_Family) {AND (NOT F1Down)} THEN        FOR index1 := 0 TO Label_Counter DO          IF PtInRect(Place_it, Lab^^.S[index1].Box) THEN { we are in a box }            BEGIN              Last_Label_Element := Lab^^.S[index1].Element;              Last_Label_Family := Lab^^.S[index1].Family;              100 : FOR nn := 0 TO Label_Counter DO                BEGIN                  IF (Lab^^.S[nn].Element = Last_Label_Element) AND 				     (Lab^^.S[nn].Family[1] = Last_Label_Family[1]) THEN                    BEGIN                      Lab^^.S[nn].Exists := False;                      Lab^^.S[nn].Active := False;                      FOR ii := nn TO Label_Counter-1 DO                        Lab^^.S[ii] := Lab^^.S[ii + 1]; {shuffle down one}						Label_Counter := Label_Counter - 1;						FOR ii := Label_Counter+1 to MaxLabels DO Lab^^.S[ii].Exists := False; { paranoia }					  GOTO 100;                    END; { IF (Lab^^.S[nn].Element =... }                END; { FOR nn := 0 to Label_Counter DO...}              Update_Full;              Last_Label_Element := '';              Last_Label_Family := '';              Leave;            END; { FOR index1 := 0 TO Label_Counter DO if PtInRect(Place_it,...} OneShot := False; 					   { As soon as the mouse button is up reset the boolean } IF OneShot = False THEN   BEGIN If (Nearest_K) OR (Nearest_L) OR (Nearest_M) {AND ( NOT F1Down)} THEN   BEGIN      FOR index1 := 1 TO 95 DO        BEGIN			Get_Energies(index1);              IF (eV_Line[1] >= (Chan_num - diff) * Plt_spec[10]^^.Expt_Info.dE) AND 			     (eV_Line[1] <= (Chan_num + diff) * Plt_spec[10]^^.Expt_Info.dE) THEN                BEGIN                  IF (Nearest_K = True) THEN                    BEGIN					 IF (index1 < 55) THEN                      Stuff_Label(Label_Counter, 					              Chan_num, 								  Place_it.h, 								  Place_it.v, 								  A^.Sym[index1], 								  'K', 								  'a')					 else begin								                        Stuff_Label(Label_Counter, 					              Chan_num, 								  Place_it.h, 								  Place_it.v, 								  A^.Sym[index1], 								  'K', 								  'a1');                      Stuff_Label(Label_Counter, 					              rinttol(eV_Line[2] / Plt_spec[10]^^.Expt_Info.dE), 								  Place_it.h,                            		  rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[2] ), 									  A^.Sym[index1], 								  'K', 								  'a2');					  end;                      IF ((Some_Labels) OR (All_Labels)) AND (eV_Line[3] > 0.0) THEN begin                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[3] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'K', 									'b1');						if index1 > 55 then begin                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[4] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'K', 									'b2');                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[5] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'K', 									'b3');                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[6] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'K', 									'b4');                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[7] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'K', 									'b5');						end;					  end;			                      IF (All_Labels) AND (2*eV_Line[1] > 0.0)  AND (not WDS_Active ) THEN                        Stuff_Label(Label_Counter, 						            rinttol(2*eV_Line[1] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'Kdbl', 									'');									                      IF (All_Labels) AND ( eV_Line[1]-1740.0 > 0.0)  AND (not WDS_Active ) THEN                        Stuff_Label(Label_Counter, 						            rinttol( (eV_Line[1] -1740.0) / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'Kesc', 									'');																		                    END;                  OneShot := True; { Dont allow back in until the mouse button goes up }                END;                              IF (eV_Line[42] >= (Chan_num - diff) * Plt_spec[10]^^.Expt_Info.dE) AND 			     (eV_Line[42] <= (Chan_num + diff) * Plt_spec[10]^^.Expt_Info.dE) THEN                BEGIN                  IF (Nearest_L = True) AND (Button = True) THEN                    BEGIN                      Stuff_Label(Label_Counter, 					              Chan_num, 								  Place_it.h, 								  Place_it.v, 								  A^.Sym[index1], 								  'L', 								  'a1');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[29] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[29] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[29] ), 									A^.Sym[index1], 									'L', 									'b1');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[31] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[31] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[31] ),  									A^.Sym[index1], 									'L', 									'g1');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[49] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[49] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[49] ), 									A^.Sym[index1], 									'L', 									'i');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[45] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[45] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[45] ), 									A^.Sym[index1], 									'L', 									'b2');                      IF ((All_Labels) {OR (Some_Labels)}) AND (eV_Line[14] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[14] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[14] ), 									A^.Sym[index1], 									'L', 									'b3');                      IF ((All_Labels) {OR (Some_Labels)}) AND (eV_Line[15] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[15] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[15] ),									A^.Sym[index1], 									'L', 									'b4');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[18] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[18] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[18] ), 									A^.Sym[index1], 									'L', 									'g3');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[35] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[35] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[35] ), 									A^.Sym[index1], 									'L', 									'h');                      IF ((All_Labels) {OR (Some_Labels)}) AND (eV_Line[43] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[43] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[43] ), 									A^.Sym[index1], 									'L', 									'a2');									                      IF (All_Labels) AND (eV_Line[32] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[32] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[32] ), 									A^.Sym[index1], 									'L', 									'g5');                      IF (All_Labels) AND (eV_Line[16] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[16] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[16] ), 									A^.Sym[index1], 									'L', 									'b9');                      IF (All_Labels) AND (eV_Line[48] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[48] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[48] ), 									A^.Sym[index1], 									'L', 									'b7');                      IF (All_Labels) AND (eV_Line[46] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[46] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[46] ), 									A^.Sym[index1], 									'L', 									'b5');                      IF (All_Labels) AND (eV_Line[13] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[13] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[13] ), 									A^.Sym[index1], 									'L', 									'b10');                      IF (All_Labels) AND (eV_Line[24] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[24] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[24] ), 									A^.Sym[index1], 									'L2N3', 									'');                      IF (All_Labels) AND (eV_Line[12] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[12] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[12] ), 									A^.Sym[index1], 									'L1O4', 									'');                      IF (All_Labels) AND (eV_Line[11] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[11] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[11] ), 									A^.Sym[index1], 									'L1O1', 									'');									                      IF (All_Labels) AND (2*eV_Line[42] > 0.0) AND (not WDS_Active ) THEN                        Stuff_Label(Label_Counter, 						            rinttol(2*eV_Line[42] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'Ldbl', 									'');									                      IF (All_Labels) AND ( eV_Line[42]-1740.0 > 0.0)  AND (not WDS_Active ) THEN                        Stuff_Label(Label_Counter, 						            rinttol( (eV_Line[42] -1740.0) / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'Lesc', 									'');																		                      OneShot := True; { Dont allow back in until the mouse button goes up }                    END;                END;              IF (eV_Line[72] >= (Chan_num - diff) * Plt_spec[10]^^.Expt_Info.dE) AND 			                  (eV_Line[72] <= (Chan_num + diff) * Plt_spec[10]^^.Expt_Info.dE) THEN                BEGIN                  IF (Nearest_M = True) AND (Button = True) THEN                    BEGIN                      Stuff_Label(Label_Counter, 					             Chan_num, 								 Place_it.h, 								 Place_it.v, 								 A^.Sym[index1], 								 'M', 								 'a');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[69] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[69] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                     rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[69] ), 									A^.Sym[index1], 									'M', 									'b');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[66] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[66] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                     rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[66] ), 									A^.Sym[index1], 									'M', 									'g');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[74] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[74] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                     rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[74] ), 									A^.Sym[index1], 									'M', 									'z1');                      IF ((All_Labels) OR (Some_Labels)) AND (eV_Line[57] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[57] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                     rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[57] ),									A^.Sym[index1], 									'M2N4', 									'');                      IF (All_Labels) AND (eV_Line[70] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[70] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[70] ), 									A^.Sym[index1], 									'M', 									'z2');                      IF (All_Labels) AND (eV_Line[61] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[61] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[61] ), 									A^.Sym[index1], 									'M3N1', 									'');                      IF (All_Labels) AND (eV_Line[56] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[56] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[56] ),									A^.Sym[index1], 									'M2N1', 									'');                      IF (All_Labels) AND (eV_Line[54] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[54] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[54] ), 									A^.Sym[index1], 									'M1N3', 									'');                      IF (All_Labels) AND (eV_Line[53] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[53] / Plt_spec[10]^^.Expt_Info.dE),									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[53] ),									A^.Sym[index1], 									'M1N2', 									'');                      IF (All_Labels) AND (eV_Line[63] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[63] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[63] ),									A^.Sym[index1], 									'M3O1', 									'');                      IF (All_Labels) AND (eV_Line[64] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[64] / Plt_spec[10]^^.Expt_Info.dE),									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[64] ), 									A^.Sym[index1], 									'M3O4',									'');                      IF (All_Labels) AND (eV_Line[65] > 0.0) THEN                        Stuff_Label(Label_Counter, 						            rinttol(eV_Line[65] / Plt_spec[10]^^.Expt_Info.dE),									Place_it.h,                                    rinttol( Full_Bottom_Screen - 									     (Full_Bottom_Screen - Place_it.v) * Wt_Line[65] ), 									A^.Sym[index1], 									'M3O5', 									'');                      IF (All_Labels) AND (2*eV_Line[72] > 0.0)  AND (not WDS_Active ) THEN                        Stuff_Label(Label_Counter, 						            rinttol(2*eV_Line[72] / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'Mdbl', 									'');									                      IF (All_Labels) AND ( eV_Line[72]-1740.0 > 0.0)  AND (not WDS_Active ) THEN                        Stuff_Label(Label_Counter, 						            rinttol( (eV_Line[72] -1740.0) / Plt_spec[10]^^.Expt_Info.dE), 									Place_it.h,                                    Full_Bottom_Screen - 30, 									A^.Sym[index1], 									'Mesc', 									'');                       OneShot := True; { Dont allow back in until the mouse button goes up }                    END;                 END;                END;            END; { for index1:=... }        END; { if OneShot = False then... }    END; { PROCEDURE Get_Nearest_Peak }  PROCEDURE Escape_Peaks;    VAR      K, ndown, ndown1, ndown2, ndown3  : Integer;      ESCMAG                        : real {double_t};      Re                            : real {double_t};      E                             : real {double_t};      M                             : real {double_t};      B                             : real {double_t};    BEGIN     IF Ge_Active then	   BEGIN		 Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;		 Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30; 		 BlockMove(@Plt_spec[10]^^, @Plt_spec[9]^^, Sizeof(Plt_spec[9]^^));		 WITH Plt_spec[9]^^ DO		   BEGIN            { Peter Statham's equation }			 M := 0.01517 * Cos((90 - Geom.Beta_Angle) / 57.295779) - 0.000803; 			 B := 0.0455 * Cos((90 - Geom.Beta_Angle) / 57.295779) + 0.01238;			  ndown := {Num2Integer} rinttol(9885.0 / Expt_Info.dE);	{ Ge K-alpha}			  ndown1 := {Num2Integer} rinttol(10980.0 / Expt_Info.dE);	{ Ge K-beta}			  ndown2 := {Num2Integer} rinttol(1188.0 / Expt_Info.dE);	{ Ge L-alpha1}			  ndown3 := {Num2Integer} rinttol(1218.0 / Expt_Info.dE);	{ Ge L-beta1}(*			 FOR K := Spectrum_Size DOWNTO rinttol(1217 / Expt_Info.dE) DO	*)			 FOR K := Expt_info.number_of_channels DOWNTO rinttol(1217 / Expt_Info.dE) DO			   BEGIN				 E := K * Plt_spec[10]^^.Expt_Info.dE;				 E := E * 0.001;				 Re := 0.0202 / (1 + (M * E + B) * E * E);				 ESCMAG := Re * S[K];				 S[K - ndown2] := S[K - ndown2] - ESCMAG;	{L-alpha1}			  IF (K > {Num2Integer} rinttol(1248 / Expt_Info.dE)) then 			  	S[K - ndown3] := S[K - ndown3] - ESCMAG;	{L-beta1}			  IF (K > {Num2Integer} rinttol(11103 / Expt_Info.dE)) then begin			  	S[K - ndown] := S[K - ndown] - ESCMAG;	{K-alpha}			  	S[K - ndown1] := S[K - ndown1] - ESCMAG;	{K-beta}				S[K] := S[K] + ESCMAG;			  end;			  				 IF SpectrumStuff.Spectrum_Info.Maximum_Counts < S[K] THEN				   SpectrumStuff.Spectrum_Info.Maximum_Counts := S[K];				 IF SpectrumStuff.Spectrum_Info.Minimum_Counts > S[K] THEN				   SpectrumStuff.Spectrum_Info.Minimum_Counts := S[K];			   END;		   END; { with...}		 END     ELSE IF WDS_Active then	   BEGIN         exit(Escape_Peaks);	   END     ELSE {IF Si_Active then}	   BEGIN		 Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E30;		 Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E30; 		 BlockMove(@Plt_spec[10]^^, @Plt_spec[9]^^, Sizeof(Plt_spec[9]^^)); 		 		 WITH Plt_spec[9]^^ DO		   BEGIN            { Peter Statham's equation }			 M := 0.01517 * Cos((90 - Geom.Beta_Angle) / 57.295779) - 0.000803; 			 B := 0.0455 * Cos((90 - Geom.Beta_Angle) / 57.295779) + 0.01238;			 FOR K := Spectrum_Size DOWNTO rinttol(1840 / Expt_Info.dE) DO			   BEGIN				 E := K * Plt_spec[10]^^.Expt_Info.dE;				 E := E * 0.001;				 Re := 0.0202 / (1 + (M * E + B) * E * E);				 ESCMAG := Re * S[K];				 S[K - rinttol(1740 / Expt_Info.dE)] := S[K - rinttol(1740 / Expt_Info.dE)] - ESCMAG;				 IF SpectrumStuff.Spectrum_Info.Maximum_Counts < S[K] THEN				   SpectrumStuff.Spectrum_Info.Maximum_Counts := S[K];				 IF SpectrumStuff.Spectrum_Info.Minimum_Counts > S[K] THEN				   SpectrumStuff.Spectrum_Info.Minimum_Counts := S[K];				 S[K] := S[K] + ESCMAG;			   END;		   END; { with...}		 END;				      Spectrum_Full[10] := True;      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);      Spectrum_Full[9] := True;      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);      Update_Full;    END; (* PROCEDURE Init_ROI_Window;    BEGIN      ROIWindow := NIL;    END; {End of procedure}*)  {=================================}  PROCEDURE Close_ROI_Window(whichWindow: WindowPtr );    BEGIN      IF (ROIWindow <> NIL) AND (ROIWindow = whichWindow) THEN        BEGIN          DisposeWindow(ROIWindow);          ROIWindow := NIL;        END; {End for if (ROIWindow<>nil)}    END; {End of procedure}  {=================================}	{$S SiLiWin5}  PROCEDURE Open_ROI_Window;        CONST      ROI_Return                    = 635;            {Button ID}      Normalize_ROIs                = 848;            {Checkbox ID}	  ROI_Use_Manual_ROIs           = 849;            {Checkbox ID}      ROI_QuantBkg                  = 641;            {Radio ID}      ROI_Peak_Wipe                 = 644;            {Radio ID}      ROI_Background_wipe           = 645;            {Radio ID}      ROI_Clear_Rg_pointed_to       = 727;            {Radio ID}      ROI_Scale_ROI                 = 991;            {Radio ID}      Clr_P_ROIs                    = 20754;          {Button ID}      Clr_ALL_ROIs                  = 20755;          {Button ID}	  Auto_ROIs                     = 20756;          {Button ID}      Clr_B_ROIs                    = 31677;          {Button ID}    VAR      Index                         : Integer;      ROICtrlHandle                : ControlHandle;   	      BEGIN      IF (ROIWindow = NIL) THEN        BEGIN          ROIWindow := GetNewWindow(343, NIL, pointer( - 1));		  MoveWindow(ROIWindow,MaxWindowRect.Left,MaxWindowRect.Bottom-123,TRUE );           SelectWindow(ROIWindow);          ShowWindow(ROIWindow);          SetPort(ROIWindow);          ROICtrlHandle := GetNewControl(ROI_Return, ROIWindow);           ROICtrlHandle := GetNewControl(Clr_P_ROIs, ROIWindow);           ROICtrlHandle := GetNewControl(Clr_ALL_ROIs, ROIWindow);  		  ROICtrlHandle := GetNewControl(Auto_ROIs, ROIWindow);            ROICtrlHandle := GetNewControl(Clr_B_ROIs, ROIWindow);           ROICtrlHandle := GetNewControl(Normalize_ROIs, ROIWindow);         (*! MBGCtrlHandle := GetNewControl(ROI_Use_Manual_ROIs, ROIWindow);*)          ROI_R1Control[1] := GetNewControl(ROI_QuantBkg, ROIWindow);		  ROI_R1Control[2] := GetNewControl(ROI_Peak_Wipe, ROIWindow); 		  ROI_R1Control[3] := GetNewControl(ROI_Background_wipe, ROIWindow); 		  ROI_R1Control[4] := GetNewControl(ROI_Clear_Rg_pointed_to, ROIWindow);		  ROI_R1Control[5] := GetNewControl(ROI_Scale_ROI, ROIWindow);         (*!        IF Use_Manual_ROIs THEN SetControlValue(MBGCtrlHandle, 1) else			  SetControlValue(MBGCtrlHandle, 0);*)           FOR Index := 1 TO 5 DO { these steps pick an initial button }            BEGIN              SetControlValue(ROI_R1Control[Index], 0); {Set each one to off}            END;          SetControlValue(ROI_R1Control[2], 1); {Select peak wipe and turn it on}          Peak_12 := False;          Peak_Wipe := True; {Select peak wipe boolean and set others false}          BackGround_Wipe := False;          Quant_BackGround_Wipe := False;          Clear_ROI := False;          Scale_ROI := False;		  DisplayROI := 1;          SelectWindow(ROIWindow);          Mouse_Active_Window;        END {End for if (ROIWindow<>nil)}      ELSE        BEGIN          SelectWindow(ROIWindow);          Mouse_Active_Window;		 (*! IF Use_Manual_ROIs THEN SetControlValue(MBGCtrlHandle, 1) else		  SetControlValue(MBGCtrlHandle, 0);*)		            FOR Index := 1 TO 5 DO { these steps pick an initial button }            BEGIN              SetControlValue(ROI_R1Control[Index], 0); {Set each one to off}            END;          SetControlValue(ROI_R1Control[2], 1); {Select peak wipe and turn it on}          Peak_Wipe := True; {Select peak wipe and set others false}          BackGround_Wipe := False;          Quant_BackGround_Wipe := False;          Clear_ROI := False;          Scale_ROI := False;		  DisplayROI := 1;        END;    END; { End of procedure }  {=================================}  PROCEDURE Do_ROI_Window(myEvent: EventRecord );    CONST      ROI_Return                    = 635;            {Button ID}      Normalize_ROIs                = 848;            {Checkbox ID}	  ROI_Use_Manual_ROIs           = 849;            {Checkbox ID}      ROI_Peak_Wipe                 = 644;            {Radio ID}      ROI_QuantBkg                  = 641;            {Radio ID}      ROI_Background_wipe           = 645;            {Radio ID}      ROI_Clear_Rg_pointed_to       = 727;            {Radio ID}      ROI_Scale_ROI                 = 991;            {Radio ID}      Clr_P_ROIs                    = 20754;          {Button ID}      Clr_ALL_ROIs                  = 20755;          {Button ID}	  Auto_ROIs                     = 20756;          {Button ID}      Clr_B_ROIs                    = 31677;          {Button ID}    VAR      RefCon                        : Integer;      code                          : Integer;      theValue                      : Integer;      whichWindow                   : WindowPtr;      myPt                          : Point;          {Point where event happened}      theControl                    : ControlHandle;     PROCEDURE Do_A_Button;      VAR        nn                            : Integer;      BEGIN        Hilitecontrol(theControl, 10); {Darken the button}        RefCon := GetControlReference(theControl);        CASE RefCon OF {Select correct button}          ROI_Return: {Return}            BEGIN              Refresh_ROIs;              Update_Full;              Peak_Wipe := False;              BackGround_Wipe := False;              Quant_BackGround_Wipe := False;              Clear_ROI := False;              Scale_ROI := False;			              Open_Sili_Window; { Return to the SiLi window }              Mouse_Active_Window;            END;          Clr_P_ROIs:             BEGIN              FOR nn := 1 TO Max_Rois DO                BEGIN                  ROI^^.Peak[nn].Lo := 1;                  ROI^^.Peak[nn].Hi := 1;                  ROI^^.Peak[nn].Value := zero;                  ROI^^.Peak[nn].Exists := False;                  ROI^^.Peak[nn].ROI := nn;                END;              Number_of_PeakRois := 1;			  Use_Manual_ROIs := false;   (* 9/20/95 CRT...Once set up, the fitting and quant routines don't depend on ROIS so                    why shut these down??? 			  Kill_Quants;			  Simplex_active := False;			  LLSQ_active := False;	*)              Refresh_ROIs;              Update_Full;				GetPort(GrafPtr(SavePort));				SetPort(ROIWindow);				InvalRect(ROIWindow^.portRect);				SetPort(GrafPtr(SavePort));            END;          Clr_ALL_ROIs:              BEGIN             Clear_the_Rois; { in utilities }			 Use_Manual_ROIs := false;			END;			          Auto_ROIs:              BEGIN			  Use_Manual_ROIs := false;              AutoROI_Chooser;              If ROI^^.Peak[1].Exists = True then				  Use_Manual_ROIs := true;			  Refresh_ROIs;			  Update_Full;			  GetPort(GrafPtr(SavePort));{the autoroi dialog port}			  SetPort(ROIWindow);			  InvalRect(ROIWindow^.portRect);			  SetPort(GrafPtr(SavePort)); 			END;			          Clr_B_ROIs: {Clr_B_ROIs}            BEGIN              FOR nn := 1 TO Max_Rois DO                BEGIN                  ROI^^.BackGround[nn].Lo := 1;                  ROI^^.BackGround[nn].Hi := 1;                  ROI^^.BackGround[nn].Value := zero;                  ROI^^.BackGround[nn].Exists := False;                  ROI^^.BackGround[nn].ROI := nn;                END;              Number_of_BackGrounds := 1;              Refresh_ROIs;              Update_Full;					GetPort(GrafPtr(SavePort));					SetPort(ROIWindow);					InvalRect(ROIWindow^.portRect);					SetPort(GrafPtr(SavePort));            END;          OTHERWISE            BEGIN              Putmessage('In CASE RefCon of "Otherwise" in ROI event loop', 'I should not be here', '', '');            END;          END; {end of case}        Hilitecontrol(theControl, 0); {Lighten the button}      END; { Proc DO_A_Button:Handle a button being pressed}    PROCEDURE Do_A_Checkbox;      PROCEDURE Clear1radiogroup;        VAR          Index                         : Integer;        BEGIN          FOR Index := 1 TO 5 DO            BEGIN              SetControlValue(ROI_R1Control[Index], 0);            END;          Peak_Wipe := False;          BackGround_Wipe := False;          Quant_BackGround_Wipe := False;          Clear_ROI := False;          Scale_ROI := False;         END;      BEGIN        RefCon := GetControlReference(theControl);        theValue := GetControlValue(theControl);        theValue := (theValue + 1) MOD 2;        CASE RefCon OF		          Normalize_ROIs:             BEGIN              IF theValue = 0 THEN SHow_ROI := False;              IF theValue = 1 THEN SHow_ROI := True;              SetControlValue(theControl, theValue);			 			  GetPort(GrafPtr(SavePort));			  SetPort(ROIWindow);			  InvalRect(ROIWindow^.portRect);			  SetPort(GrafPtr(SavePort));              END;       (*   ROI_Use_Manual_ROIs:             BEGIN              IF theValue = 0 THEN Use_Manual_ROIs := False;              IF theValue = 1 THEN Use_Manual_ROIs := True;              SetControlValue(MBGCtrlHandle, theValue);			 			  GetPort(GrafPtr(SavePort));			  SetPort(ROIWindow);			  InvalRect(ROIWindow^.portRect);			  SetPort(GrafPtr(SavePort));              END;*)          ROI_Peak_Wipe: {Peak Wipe}            BEGIN              Clear1radiogroup;              SetControlValue(theControl, 1);              Peak_Wipe := True;            END;          ROI_Background_wipe: {Background wipe}            BEGIN			              Clear1radiogroup;              SetControlValue(theControl, 1);              BackGround_Wipe := True;            END;          ROI_Clear_Rg_pointed_to: {Clear ROI pointed to}            BEGIN              Clear1radiogroup;              SetControlValue(theControl, 1);              Clear_ROI := True;            END;          ROI_Scale_ROI: {Scale ROI }            BEGIN              Clear1radiogroup;              SetControlValue(theControl, 1);              Scale_ROI := True;            END;          ROI_QuantBkg: {Chosen Background wipe}            BEGIN              Clear1radiogroup;              SetControlValue(theControl, 1);              Quant_BackGround_Wipe := True;            END;          OTHERWISE            BEGIN            END;          END; {end of case}      END;    BEGIN {PROCEDURE Do_ROI_Window}      IF (ROIWindow <> NIL) THEN        BEGIN          code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}			          IF (myEvent.what = MouseDown) AND (ROIWindow = whichWindow) THEN            BEGIN              myPt := myEvent.where;              WITH ROIWindow^.portBits.bounds DO {Make it relative}                BEGIN                  myPt.h := myPt.h + left;                  myPt.v := myPt.v + top;                END;            END;              Setrect(tempRect, 149, 19, 274, 39);              IF PtInRect(myPt, tempRect) THEN                BEGIN                  ChangedSelection := False;                  tempMenu := GetMenu(52);                  IF (tempMenu <> NIL) THEN                    BEGIN					  BackColor(YellowColor);					  ForeColor(RedColor); 					                      InsertMenu(tempMenu, - 1);                      tempRect.Right := 274;                      myPt.v := -48 + (DisplayROI -1) * 16;	{was 18}                      myPt.h := 149;                      LocalToGlobal(myPt);                      CheckItem(tempMenu, DisplayROI, True);                      MemResult := PopUpMenuSelect(tempMenu, myPt.v, myPt.h, DisplayROI);                      IF (DisplayROI <> LoWord(MemResult)) AND (LoWord(MemResult) > 0) THEN                        BEGIN                          CheckItem(tempMenu, DisplayROI, False);                          ChangedSelection := True;                          DisplayROI := LoWord(MemResult);                        END                      ELSE CheckItem(tempMenu, DisplayROI, False);                      DeleteMenu(52);                      IF ChangedSelection THEN                        BEGIN						  SetFont('Chicago', 14, []);                          Setrect(tempRect, 149, 19, 274, 39);                          eraseRect(tempRect);                          MoveTo(tempRect.left + 2, tempRect.top + 15);							                          CASE DisplayROI OF { These labels appear in the little box before						                        a mouse down and sometime after startup, go to 												UpDate_SiLi_Window in Global_Functions.P for the 												list which is used at startup. The items which												are in the actual popup are in mca.r}                            1:                              BEGIN                                DrawString('Work  ->');								Reset_ROIs;                              END;                            2:                              BEGIN                                DrawString('Results  ->');								Reset_ROIs;                              END;                            3:                              BEGIN                                DrawString('Spectrum 1 ->');								Reset_ROIs;                              END;                            4:                              BEGIN                                DrawString('Spectrum 2 ->');								Reset_ROIs;                              END;                            5:                              BEGIN                                DrawString('Spectrum 3 ->');								Reset_ROIs;                              END;                            6:                              BEGIN                                DrawString('Spectrum 4 ->');								Reset_ROIs;                              END;                            7:                              BEGIN                                DrawString('Spectrum 5 ->');								Reset_ROIs;                              END;                            8:                              BEGIN                                DrawString('Spectrum 6 ->');								Reset_ROIs;                              END;                            9:                              BEGIN                                DrawString('Spectrum 7 ->');								Reset_ROIs;                              END;                            10:                              BEGIN                                DrawString('Spectrum 8 ->');								Reset_ROIs;                              END;                            OTHERWISE                              BEGIN                              END;                            END;							  Framerect(tempRect);							  BackColor(YellowColor);							  ForeColor(RedColor);		  							  MoveTo(tempRect.Left + 1, tempRect.Bottom);							  LINETO(tempRect.Right, tempRect.Bottom);							  LINETO(tempRect.Right, tempRect.Top + 1);							  							Update_Full;							GetPort(GrafPtr(SavePort));							SetPort(ROIWindow);							InvalRect(ROIWindow^.portRect);							SetPort(GrafPtr(SavePort));                        END;					END;				END;          IF (ROIWindow = whichWindow) AND (code = inContent) THEN            BEGIN              code := FindControl(myPt, whichWindow, theControl); {Get type of control}              IF (code <> 0) THEN code := TrackControl(theControl, myPt, NIL); {Track the control}              IF code = kControlButtonPart THEN Do_A_Button;              IF code = kControlCheckBoxPart THEN Do_A_Checkbox;            END; {End for if (ROIWindow=whichWindow)}        END; {End for if (ROIWindow<>nil)}    END; { PROCEDURE Do_ROI_Window}PROCEDURE SetUp_ROIs; {еееThis procedure is called in the main event loop }VAR	n, nn                         : Integer;	Roi_Choice, ThisRoi, ThatRoi  : ^Roi_Data_Structure;	A_Peak_Was_Changed            : boolean;	A_BG_Was_Changed, do_refresh  : boolean;	Changed_ROI                   : Integer;     str                           : str255;	BEGIN { Procedure SetUp_Rois }	A_Peak_Was_Changed := False;	A_BG_Was_Changed := False;	do_refresh := false;		IF (Scale_ROI) OR (Peak_Wipe) OR (BackGround_Wipe) OR (Quant_BackGround_Wipe) THEN BEGIN		ThatRoi := @ROI^^.BackGround[Number_of_BackGrounds];	{last bkg roi}		ThisRoi := @ROI^^.Peak[Number_of_PeakRois];				{last pk roi}		IF (Scale_ROI = True) AND (ROI^^.Scale.Exists = False) THEN BEGIN			Roi_Choice := @ROI^^.Scale;		END ELSE IF (Peak_Wipe = True) AND (ROI^^.Peak[Number_of_PeakRois].Exists = False) THEN BEGIN			Roi_Choice := @ROI^^.Peak[Number_of_PeakRois];		END ELSE IF (BackGround_Wipe = True) AND (ROI^^.BackGround[Number_of_BackGrounds].Exists = False) THEN BEGIN			Roi_Choice := @ROI^^.BackGround[Number_of_BackGrounds];		END ELSE IF (Quant_BackGround_Wipe = True) AND (ROI^^.Quant.Exists = False) THEN BEGIN			Roi_Choice := @ROI^^.Quant;		END ELSE BEGIN			Roi_Choice := @ROI^^.Quant;		END;		IF (Button = True) AND (Begin_End = 0) THEN BEGIN			Roi_Choice^.Lo := Chan_num;			Begin_End := 1;		END ELSE IF (Button = False) AND (Begin_End = 1) AND (Chan_num > Roi_Choice^.Lo) THEN BEGIN			Roi_Choice^.Hi := Chan_num;			Roi_Choice^.Exists := True;			Begin_End := 0;		    do_refresh := true;			IF (Roi_Choice = ThisRoi) THEN BEGIN				IF (Roi_Choice^.Hi - Roi_Choice^.Lo > Max_Fitting_Chans - 40) AND (Peak_Wipe) THEN BEGIN					numToString(Max_Fitting_Chans - 40, str);					BeepBeep;					str := CONCAT('Sorry, you can not use a PEAK fitting region greater than: ', str,' Channels.');					Putmessage(str,'','Any of the other ROI types will allow up to 8192 channels' ,					           'Please try again using fewer channels');					Roi_Choice^.Exists := False;					Roi_Choice^.Lo := 0;					Begin_End := 0;					do_refresh := true;				END; { if( Hi - Lo >...}				IF (Number_of_PeakRois < Max_Rois) THEN BEGIN					Number_of_PeakRois := Number_of_PeakRois + 1;					Use_Manual_ROIs := true	(* 9/20/95 *)			  	END ELSE BEGIN					Putmessage(' You already have the maximum number, 50, of Peak ROI`s.', '', '', '');				END;			END;	{IF (Roi_Choice = ThisRoi) ...}			IF (Roi_Choice = ThatRoi) THEN BEGIN				IF (Number_of_BackGrounds < Max_Rois) THEN BEGIN					Number_of_BackGrounds := Number_of_BackGrounds + 1				END ELSE BEGIN					Putmessage('You have the maximum number, 50, of Background ROI`s.', '', '', '');				END;			END;		END ELSE IF (Button = False) AND (Begin_End = 1) AND (Chan_num <= Roi_Choice^.Lo) THEN BEGIN			BeepBeep;			Putmessage('You must choose a ROI from left to right only! ', 'Try it again!', '', '');			Roi_Choice^.Lo := 1;			Begin_End := 0;			do_refresh := true;		END;	END; {IF...} ;	IF (Clear_ROI) AND (Button) THEN	BEGIN		IF (Chan_num >= ROI^^.Scale.Lo) AND (Chan_num <= ROI^^.Scale.Hi) THEN BEGIN			ROI^^.Scale.Exists := False;			ROI^^.Scale.Hi := 1;			ROI^^.Scale.Value := zero;			do_refresh := true;		END;		IF (Chan_num >= ROI^^.Quant.Lo) AND (Chan_num <= ROI^^.Quant.Hi) THEN BEGIN			ROI^^.Quant.Exists := False;			ROI^^.Quant.Hi := 1;			ROI^^.Quant.Value := 0;			do_refresh := true;		END;(*      			IF (Chan_num >= ROI^^.Peak[n].Lo) AND (Chan_num <= ROI^^.Peak[n].Hi) THEN			BEGIN				ROI^^.Peak[n].Exists := False;				ROI^^.Peak[n].Lo := 1;				ROI^^.Peak[n].Hi := 1;				ROI^^.Peak[n].Value := zero;				ROI^^.Peak[n].ROI := n;				Number_of_PeakRois := Number_of_PeakRois - 1;				A_Peak_Was_Changed := True;				Changed_ROI := n;			END;			IF (Chan_num >= ROI^^.BackGround[n].Lo) AND (Chan_num <= ROI^^.BackGround[n].Hi) THEN			BEGIN				ROI^^.BackGround[n].Exists := False;				ROI^^.BackGround[n].Lo := 1;				ROI^^.BackGround[n].Hi := 1;				ROI^^.BackGround[n].Value := zero;				ROI^^.BackGround[n].ROI := n;				Number_of_BackGrounds := Number_of_BackGrounds - 1;				A_BG_Was_Changed := True;				Changed_ROI := n;			END;		END; {FOR n := 1 TO Max_Rois...}9/27/95  *)          n := 1;		  REPEAT	{remember that Number_of_PeakRois is always 1 > the number set up, ie,		             ROI^^.Peak[Number_of_PeakRois].Exists := False }			IF (Chan_num >= ROI^^.Peak[n].Lo) AND (Chan_num <= ROI^^.Peak[n].Hi) THEN			BEGIN				Changed_ROI := n;				FOR nn := Changed_ROI TO Number_of_PeakRois - 1 DO BEGIN					ROI^^.Peak[nn] := ROI^^.Peak[nn + 1];	{get values from next higher ROI}					ROI^^.Peak[nn].ROI := nn;	{nothing changes here}				END;	{make sure the values of the new last ROI, Number_of_PeakRois - 1, are cleared...}				ROI^^.Peak[nn].Exists := False;				ROI^^.Peak[nn].Lo := 1;				ROI^^.Peak[nn].Hi := 1;				ROI^^.Peak[nn].Value := zero;				ROI^^.Peak[nn].ROI := nn;				Number_of_PeakRois := Number_of_PeakRois - 1;				A_Peak_Was_Changed := True;				if Number_of_PeakRois = 1 then use_manual_rois := false;			END	{ IF (Chan_num >= ROI^^.Peak...}			ELSE IF (Chan_num >= ROI^^.BackGround[n].Lo) AND (Chan_num <= ROI^^.BackGround[n].Hi) THEN BEGIN				ROI^^.BackGround[n].Exists := False;				ROI^^.BackGround[n].Lo := 1;				ROI^^.BackGround[n].Hi := 1;				ROI^^.BackGround[n].Value := zero;				ROI^^.BackGround[n].ROI := n;				Number_of_BackGrounds := Number_of_BackGrounds - 1;				A_BG_Was_Changed := True;				Changed_ROI := n;		    END	{ELSE IF (Chan_num >= ROI^^.BackGround...}					ELSE n := n+1; 	{ROI^^.Peak[Number_of_PeakRois].Exists is always False}		  UNTIL (A_Peak_Was_Changed or A_BG_Was_Changed or (n = Max_Rois));		 IF A_Peak_Was_Changed THEN BEGIN(*			FOR nn := Changed_ROI TO Number_of_PeakRois - 1 DO BEGINdelete			ROI^^.Peak[nn] := ROI^^.Peak[nn + 1];9/27/95			ROI^^.Peak[nn].ROI := nn;			END; *)		{there is no reason to do the next three...}			Kill_Quants;			Simplex_active := False;			LLSQ_active := False;			A_Peak_Was_Changed := False;			do_refresh := true;		END;	{IF A_Peak_Was_Changed...}		IF A_BG_Was_Changed THEN BEGIN			FOR nn := Changed_ROI TO Max_Rois - 1 DO BEGIN				ROI^^.BackGround[nn] := ROI^^.BackGround[nn + 1];				ROI^^.BackGround[nn].ROI := nn;			END;			A_BG_Was_Changed := False;			do_refresh := true;		END;	{ IF A_BG_Was_Changed...}			END; {IF (Clear_ROI...}	If do_refresh then	begin	   Refresh_ROIs;	   Update_Full;	   GetPort(GrafPtr(SavePort));	   SetPort(ROIWindow);	   InvalRect(ROIWindow^.portRect);	   SetPort(GrafPtr(SavePort));	end;END; { PROCEDURE SetUp_ROIs }END.