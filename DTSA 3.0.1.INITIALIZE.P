 {[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+,d-]}  {*********************************} UNIT Initialize ; {*********************************}{************************************} INTERFACE {*********************************}USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Windows, Timer, Errors, Menus, Files, Lists, Memory, Resources, Packages, Printing, Fonts, Retrace, Events, TextUtils, Dialogs, Palettes, SegLoad, fenv, fp {SANE}, TextEdit, Spectrum_Structures, XRay, Declarations;    PROCEDURE RealToString(Val: real; width, fwidth: integer; VAR Str_x: Str255);    PROCEDURE ChangeCursor(C: Ptr);  {Change cursor. Current cursor pointer is always in CurrentC}    PROCEDURE ProtoInits;    PROCEDURE Physics_Initialize;    PROCEDURE Default_WorkSpectrum_Fields;	PROCEDURE PutEarlyMessage(S1, S2, S3, S4: Str255);    PROCEDURE AssignMemory;	    PROCEDURE CheckBits;    PROCEDURE Out_of_Memory_Warning;	    PROCEDURE Bag_the_Program; 	    PROCEDURE H_UnLock_Dispose( VAR A_Handle : Handle ; message : str255 );	{PROCEDURE MyNum2Str(x : double_t; indigs, outdigs : integer; VAR st : Str255);}	Function  MyStr2Num(st : Str255): real {double_t}; 	    {*************************************} IMPLEMENTATION {*************************************}{$S INITIALIZE}VAR	refNum_xx  : integer;(*PROCEDURE MyNum2Str{(x : double_t; indigs, outdigs : integer; VAR st : Str255)};  TYPE  	ststr = Str255;  	stptr = ^ststr;  VAR  	instrC		: CStringPtr;	dx			: decimal;	ix			: integer;	infmt		: decform;	outfmt		: decform;	sptr		: StringPtr;	myst		: ststr;	{mystptr		: stptr;}	BEGIN		if indigs <= 0 then indigs := 7;		if outdigs <= 0 then outdigs := 4;		infmt.style := FLOATDECIMAL;		infmt.digits := indigs;		num2dec(infmt, x, dx);		outfmt.style := FIXEDDECIMAL;		outfmt.digits := outdigs;		dec2str(outfmt, dx, instrC);		sptr := C2PStr(instrC);		myst := sptr^;		st := myst;	END;*)	FUNCTION MyStr2Num(theStr : Str255): real {double_t};  VAR	dx			: decimal;	ix, vp		: integer;  BEGIN  	ix := 0;  	str2dec(ConstCStringPtr(P2CStr(@theStr)), ix, dx, vp);  	MyStr2Num := dec2num(dx);  END;		   PROCEDURE RealToString    ( Val: real; fwidth, width: Integer; VAR Str_x: Str255 ) ;  {Does real to string conversion equivalent to write(val:width:fwidth).  RealToString(27.1200,4,2); will produce a string of 27.12.   If fwidth=-1 THEN the number of digits to the right of the decimal point   is determined by value of "width". If fwidth=-2 THEN floating point(scientific)   notation is used. "width" is the digits to right of decimal point.}	{ the usual val for width is 3 and for fwidth is -1 }      VAR        {form		: DecForm;}		extval		: real {double_t};      BEGIN	  	extval := Val;		{Str_x := ' ';}        {extVal := Val;} { Because Num2Str below is very, very picky }        (*form.digits := fwidth;	{-1}        form.style := FixedDecimal;        IF fwidth = - 2 THEN BEGIN          form.style := FloatDecimal;          form.digits := width { digits to right of decimal point } ;{3}        END        ELSE IF fwidth = - 1 THEN	{form.style := FixedDecimal and...}          form.digits := width { width is the digits to right of decimal point } ;		 width := form.digits; 	*)			{Num2Str(form, extval, Str_x);}		Str_x := StringOf(extval:fwidth:width);		{MyNum2Str(extval, fwidth, width, Str_x);}      END;    {=================================}    PROCEDURE PutMessage (s1,s2,s3,s4:str255) ;      VAR        mylog                        : DialogPtr;        item                         : integer;        itemType                     : Integer;        itemBox                      : Rect;        itemHdl                      : Handle;		      BEGIN	           UseResFile(MCA_Home_Res_RefNum);        mylog := GetNewDialog(11035, NIL, POINTER( - 1));         ChangeCursor(ArrowC);        ShowWindow(mylog);                            {Open a dialog box}        SelectWindow(mylog);                          {Lets see it}        SetPort(mylog);                               {Prepare to add conditional text}        GetDialogItem(mylog, 1, itemType, itemHdl, itemBox);        PenSize(3, 3);        InSetRect(itemBox, - 4, - 4);        FrameRoundRect(itemBox, 16, 16);        REPEAT          MoveTo(25, 15);                              { Leave these inside the repeat loop, }          DrawString(S1);                             { to avoid buffer problem }          MoveTo(25, 30);          DrawString(S2);          MoveTo(25, 45);          DrawString(S3);          MoveTo(25, 60);		  DrawString(S4);          ModalDialog(NIL, item);        UNTIL (item = 1);		         DisposeDialog(mylog);		       END;	  PROCEDURE Bag_the_Program;		  begin			SysBeep(1);			putmessage('Not enough memory available to run DTSA.',			'The program must quit, please  do a "get info" under the Finder`s FILE menu item',			'and assign more memory to DTSA.','DTSA generally runs well with about 3500 to 4000 k bytes');			Halt;		  end;			PROCEDURE Out_of_Memory_Warning;		  begin			SysBeep(1);			putmessage('Not enough memory available to do the requsted operation.',			'The program must quit, please  do a "get info" under the Finder`s FILE menu item',			'and assign more memory to DTSA.','DTSA generally runs well with about 3500 to 4000 k bytes'); 		  end;			   PROCEDURE H_UnLock_Dispose {( VAR A_Handle : Handle ; message : str255 )} ;        BEGIN      IF A_Handle = NIL THEN        BEGIN          PutMessage('Attempt to dispose of a dead Handle', message, '', '');          Exit(H_UnLock_Dispose);        END;      HunLock(A_Handle);      DisposeHandle(A_Handle);      A_Handle := NIL;     { grow := 4000000;      PurgeMem(grow);      grow := CompactMem(grow);      IF MemError <> 0 THEN PutMessage('Error in attempting to CompactMem', 'after a H_UnLock_Dispose', message, '');}    END;                                     PROCEDURE PutEarlyMessage { (s1,s2,s3,s4:str255) };		var			ignore: integer;	begin		InitCursor;		ParamText(s1, s2, s3, s4);		Ignore := Alert(300, nil);	end;    FUNCTION  AnswerMessage(S1, S2, S3, S4: Str255): Boolean;      VAR        mylog                        : DialogPtr;        item                         : integer;        itemType                     : Integer;        itemBox                      : Rect;        itemHdl                      : Handle;      BEGIN        UseResFile(MCA_Home_Res_RefNum);        mylog := GetNewDialog(8603, NIL, POINTER( - 1));        ShowWindow(mylog);                            {Open a dialog box}        SelectWindow(mylog);                          {Lets see it}        SetPort(mylog);                               {Prepare to add conditional text}        GetDialogItem(mylog, 1, itemType, itemHdl, itemBox);        PenSize(3, 3);        InSetRect(itemBox, - 4, - 4);        FrameRoundRect(itemBox, 16, 16);        REPEAT          MoveTo(25, 15);                             { Leave these inside the repeat loop, }          DrawString(S1);                             { to avoid buffer problem }          MoveTo(25, 30);          DrawString(S2);          MoveTo(25, 45);          DrawString(S3);          MoveTo(25, 60);		  DrawString(S4);          ModalDialog(NIL, item);        UNTIL (item = 1) or (item = 2);		if item = 1 then AnswerMessage := True; { It's OK }		if item = 2 then AnswerMessage := False; { It's NOT OK }        DisposeDialog(mylog);      END;    PROCEDURE Load_Symbols;      BEGIN	    A^.Sym[0] := '  ';        A^.Sym[1] := 'H ';        A^.Sym[2] := 'He';        A^.Sym[3] := 'Li';        A^.Sym[4] := 'Be';        A^.Sym[5] := 'B ';        A^.Sym[6] := 'C ';        A^.Sym[7] := 'N ';        A^.Sym[8] := 'O ';        A^.Sym[9] := 'F ';        A^.Sym[10] := 'Ne';        A^.Sym[11] := 'Na';        A^.Sym[12] := 'Mg';        A^.Sym[13] := 'Al';        A^.Sym[14] := 'Si';        A^.Sym[15] := 'P ';        A^.Sym[16] := 'S ';        A^.Sym[17] := 'Cl';        A^.Sym[18] := 'Ar';        A^.Sym[19] := 'K ';        A^.Sym[20] := 'Ca';        A^.Sym[21] := 'Sc';        A^.Sym[22] := 'Ti';        A^.Sym[23] := 'V ';        A^.Sym[24] := 'Cr';        A^.Sym[25] := 'Mn';        A^.Sym[26] := 'Fe';        A^.Sym[27] := 'Co';        A^.Sym[28] := 'Ni';        A^.Sym[29] := 'Cu';        A^.Sym[30] := 'Zn';        A^.Sym[31] := 'Ga';        A^.Sym[32] := 'Ge';        A^.Sym[33] := 'As';        A^.Sym[34] := 'Se';        A^.Sym[35] := 'Br';        A^.Sym[36] := 'Kr';        A^.Sym[37] := 'Rb';        A^.Sym[38] := 'Sr';        A^.Sym[39] := 'Y ';        A^.Sym[40] := 'Zr';        A^.Sym[41] := 'Nb';        A^.Sym[42] := 'Mo';        A^.Sym[43] := 'Tc';        A^.Sym[44] := 'Ru';        A^.Sym[45] := 'Rh';        A^.Sym[46] := 'Pd';        A^.Sym[47] := 'Ag';        A^.Sym[48] := 'Cd';        A^.Sym[49] := 'In';        A^.Sym[50] := 'Sn';        A^.Sym[51] := 'Sb';        A^.Sym[52] := 'Te';        A^.Sym[53] := 'I ';        A^.Sym[54] := 'Xe';        A^.Sym[55] := 'Cs';        A^.Sym[56] := 'Ba';        A^.Sym[57] := 'La';        A^.Sym[58] := 'Ce';        A^.Sym[59] := 'Pr';        A^.Sym[60] := 'Nd';        A^.Sym[61] := 'Pm';        A^.Sym[62] := 'Sm';        A^.Sym[63] := 'Eu';        A^.Sym[64] := 'Gd';        A^.Sym[65] := 'Tb';        A^.Sym[66] := 'Dy';        A^.Sym[67] := 'Ho';        A^.Sym[68] := 'Er';        A^.Sym[69] := 'Tm';        A^.Sym[70] := 'Yb';        A^.Sym[71] := 'Lu';        A^.Sym[72] := 'Hf';        A^.Sym[73] := 'Ta';        A^.Sym[74] := 'W ';        A^.Sym[75] := 'Re';        A^.Sym[76] := 'Os';        A^.Sym[77] := 'Ir';        A^.Sym[78] := 'Pt';        A^.Sym[79] := 'Au';        A^.Sym[80] := 'Hg';        A^.Sym[81] := 'Tl';        A^.Sym[82] := 'Pb';        A^.Sym[83] := 'Bi';        A^.Sym[84] := 'Po';        A^.Sym[85] := 'At';        A^.Sym[86] := 'Rn';        A^.Sym[87] := 'Fr';        A^.Sym[88] := 'Ra';        A^.Sym[89] := 'Ac';        A^.Sym[90] := 'Th';        A^.Sym[91] := 'Pa';        A^.Sym[92] := 'U ';        A^.Sym[93] := 'Np';        A^.Sym[94] := 'Pu';        A^.Sym[95] := 'Am';      END;    PROCEDURE Make_Element_Symbols;      BEGIN        A^.ElementSymbolList[0] := '  ';        A^.ElementSymbolList[1] := 'H ';        A^.ElementSymbolList[2] := 'HE';        A^.ElementSymbolList[3] := 'LI';        A^.ElementSymbolList[4] := 'BE';        A^.ElementSymbolList[5] := 'B ';        A^.ElementSymbolList[6] := 'C ';        A^.ElementSymbolList[7] := 'N ';        A^.ElementSymbolList[8] := 'O ';        A^.ElementSymbolList[9] := 'F ';        A^.ElementSymbolList[10] := 'NE';        A^.ElementSymbolList[11] := 'NA';        A^.ElementSymbolList[12] := 'MG';        A^.ElementSymbolList[13] := 'AL';        A^.ElementSymbolList[14] := 'SI';        A^.ElementSymbolList[15] := 'P ';        A^.ElementSymbolList[16] := 'S ';        A^.ElementSymbolList[17] := 'CL';        A^.ElementSymbolList[18] := 'AR';        A^.ElementSymbolList[19] := 'K ';        A^.ElementSymbolList[20] := 'CA';        A^.ElementSymbolList[21] := 'SC';        A^.ElementSymbolList[22] := 'TI';        A^.ElementSymbolList[23] := 'V ';        A^.ElementSymbolList[24] := 'CR';        A^.ElementSymbolList[25] := 'MN';        A^.ElementSymbolList[26] := 'FE';        A^.ElementSymbolList[27] := 'CO';        A^.ElementSymbolList[28] := 'NI';        A^.ElementSymbolList[29] := 'CU';        A^.ElementSymbolList[30] := 'ZN';        A^.ElementSymbolList[31] := 'GA';        A^.ElementSymbolList[32] := 'GE';        A^.ElementSymbolList[33] := 'AS';        A^.ElementSymbolList[34] := 'SE';        A^.ElementSymbolList[35] := 'BR';        A^.ElementSymbolList[36] := 'KR';        A^.ElementSymbolList[37] := 'RB';        A^.ElementSymbolList[38] := 'SR';        A^.ElementSymbolList[39] := 'Y ';        A^.ElementSymbolList[40] := 'ZR';        A^.ElementSymbolList[41] := 'NB';        A^.ElementSymbolList[42] := 'MO';        A^.ElementSymbolList[43] := 'TC';        A^.ElementSymbolList[44] := 'RU';        A^.ElementSymbolList[45] := 'RH';        A^.ElementSymbolList[46] := 'PD';        A^.ElementSymbolList[47] := 'AG';        A^.ElementSymbolList[48] := 'CD';        A^.ElementSymbolList[49] := 'IN';        A^.ElementSymbolList[50] := 'SN';        A^.ElementSymbolList[51] := 'SB';        A^.ElementSymbolList[52] := 'TE';        A^.ElementSymbolList[53] := 'I ';        A^.ElementSymbolList[54] := 'XE';        A^.ElementSymbolList[55] := 'CS';        A^.ElementSymbolList[56] := 'BA';        A^.ElementSymbolList[57] := 'LA';        A^.ElementSymbolList[58] := 'CE';        A^.ElementSymbolList[59] := 'PR';        A^.ElementSymbolList[60] := 'ND';        A^.ElementSymbolList[61] := 'PM';        A^.ElementSymbolList[62] := 'SM';        A^.ElementSymbolList[63] := 'EU';        A^.ElementSymbolList[64] := 'GD';        A^.ElementSymbolList[65] := 'TB';        A^.ElementSymbolList[66] := 'DY';        A^.ElementSymbolList[67] := 'HO';        A^.ElementSymbolList[68] := 'ER';        A^.ElementSymbolList[69] := 'TM';        A^.ElementSymbolList[70] := 'YB';        A^.ElementSymbolList[71] := 'LU';        A^.ElementSymbolList[72] := 'HF';        A^.ElementSymbolList[73] := 'TA';        A^.ElementSymbolList[74] := 'W ';        A^.ElementSymbolList[75] := 'RE';        A^.ElementSymbolList[76] := 'OS';        A^.ElementSymbolList[77] := 'IR';        A^.ElementSymbolList[78] := 'PT';        A^.ElementSymbolList[79] := 'AU';        A^.ElementSymbolList[80] := 'HG';        A^.ElementSymbolList[81] := 'TL';        A^.ElementSymbolList[82] := 'PB';        A^.ElementSymbolList[83] := 'BI';        A^.ElementSymbolList[84] := 'PO';        A^.ElementSymbolList[85] := 'AT';        A^.ElementSymbolList[86] := 'RN';        A^.ElementSymbolList[87] := 'FR';        A^.ElementSymbolList[88] := 'RA';        A^.ElementSymbolList[89] := 'AC';        A^.ElementSymbolList[90] := 'TH';        A^.ElementSymbolList[91] := 'PA';        A^.ElementSymbolList[92] := 'U ';        A^.ElementSymbolList[93] := 'NP';        A^.ElementSymbolList[94] := 'PU';        A^.ElementSymbolList[95] := 'AM';      END;                                            { Make_Element_Symbols; } {$S INITIALIZE2}Procedure over_flow_1;var test : Real;bytecount : Longint;errCode, nn   : integer;str : str255;	begin	  			errCode := FSOpen('XRayData', 0,refNum_xx);  		if errCode<>0 then		begin		 putearlymessage('A Fatal error occured while opening the XRayData file, please check to make',		             ' sure this file is present in the same folder as the DTSA program. ',					 ' The spelling is important. ',					 ' The program must terminate. ');		 Halt;		end;		bytecount := 4;		errCode := FSRead(refNum_xx,bytecount,@test);				Realtostring(test,5,4,str); 		         if  test  < 1.069 then {본본본본 VERSION NUMBER HERE }	    begin		 putearlymessage('The XRayData file is incorrect for this version of DTSA. ',					 ' Please find the correct version number or contact NIST. ',					 ' The program must terminate. Looking for version:1.07, but found:',str);		 Halt;		end;         	        ReserveMem(SizeOf(RHO)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        RHO_Handle := RHOHndl(NewHandle(SizeOf(RHO)));		HLock(Handle(RHO_Handle));		byteCount := SizeOf(RHO); 				errCode := FSRead(refNum_xx,byteCount,@RHO_Handle^^);  	          ReserveMem(SizeOf(ATWT)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        At_Wt := ATWTHndl(NewHandle(SizeOf(ATWT)));		HLock(Handle(At_Wt));		byteCount := Sizeof(ATWT);		errCode := FSRead(refNum_xx,byteCount,@At_Wt^^);     	        ReserveMem(SizeOf(KA1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KA1_Handle := KA1Hndl(NewHandle(SizeOf(KA1)));		HLock(Handle(KA1_Handle));		byteCount := Sizeof(KA1);		errCode := FSRead(refNum_xx,byteCount,@KA1_Handle^^);	        ReserveMem(SizeOf(KA2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KA2_Handle := KA2Hndl(NewHandle(SizeOf(KA2)));		HLock(Handle(KA2_Handle));		byteCount := Sizeof(KA2);		errCode := FSRead(refNum_xx,byteCount,@KA2_Handle^^);	        ReserveMem(SizeOf(KB1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KB1_Handle := KB1Hndl(NewHandle(SizeOf(KB1)));		HLock(Handle(KB1_Handle));		byteCount := Sizeof(KB1);		errCode := FSRead(refNum_xx,byteCount,@KB1_Handle^^); 	        ReserveMem(SizeOf(KB2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KB2_Handle := KB2Hndl(NewHandle(SizeOf(KB2)));		HLock(Handle(KB2_Handle));		byteCount := Sizeof(KB2);		errCode := FSRead(refNum_xx,byteCount,@KB2_Handle^^);	        ReserveMem(SizeOf(KB3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KB3_Handle := KB3Hndl(NewHandle(SizeOf(KB3)));		HLock(Handle(KB3_Handle));		byteCount := Sizeof(KB3);		errCode := FSRead(refNum_xx,byteCount,@KB3_Handle^^);	        ReserveMem(SizeOf(KB4)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KB4_Handle := KB4Hndl(NewHandle(SizeOf(KB4)));		HLock(Handle(KB4_Handle));		byteCount := Sizeof(KB4);		errCode := FSRead(refNum_xx,byteCount,@KB4_Handle^^);	        ReserveMem(SizeOf(KB5)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        KB5_Handle := KB5Hndl(NewHandle(SizeOf(KB5)));		HLock(Handle(KB5_Handle));		byteCount := Sizeof(KB5);		errCode := FSRead(refNum_xx,byteCount,@KB5_Handle^^);	        ReserveMem(SizeOf(L1M1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L1M1_Handle := L1M1Hndl(NewHandle(SizeOf(L1M1)));		HLock(Handle(L1M1_Handle));		byteCount := Sizeof(L1M1);		errCode := FSRead(refNum_xx,byteCount,@L1M1_Handle^^);	        ReserveMem(SizeOf(L1N1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L1N1_Handle := L1N1Hndl(NewHandle(SizeOf(L1N1)));		HLock(Handle(L1N1_Handle));		byteCount := Sizeof(L1N1);		errCode := FSRead(refNum_xx,byteCount,@L1N1_Handle^^);	        ReserveMem(SizeOf(L1N4)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L1N4_Handle := L1N4Hndl(NewHandle(SizeOf(L1N4)));		HLock(Handle(L1N4_Handle));		byteCount := Sizeof(L1N4);		errCode := FSRead(refNum_xx,byteCount,@L1N4_Handle^^);	        ReserveMem(SizeOf(L1O1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L1O1_Handle := L1O1Hndl(NewHandle(SizeOf(L1O1)));		HLock(Handle(L1O1_Handle));		byteCount := Sizeof(L1O1);		errCode := FSRead(refNum_xx,byteCount,@L1O1_Handle^^);	        ReserveMem(SizeOf(L1O4)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L1O4_Handle := L1O4Hndl(NewHandle(SizeOf(L1O4)));		HLock(Handle(L1O4_Handle));		byteCount := Sizeof(L1O4);		errCode := FSRead(refNum_xx,byteCount,@L1O4_Handle^^);        ReserveMem(SizeOf(L2M2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2M2_Handle := L2M2Hndl(NewHandle(SizeOf(L2M2)));		HLock(Handle(L2M2_Handle));		byteCount := Sizeof(L2M2);		errCode := FSRead(refNum_xx,byteCount,@L2M2_Handle^^);	        ReserveMem(SizeOf(L2M5)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2M5_Handle := L2M5Hndl(NewHandle(SizeOf(L2M5)));		HLock(Handle(L2M5_Handle));		byteCount := Sizeof(L2M5);		errCode := FSRead(refNum_xx,byteCount,@L2M5_Handle^^);	        ReserveMem(SizeOf(L2N2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2N2_Handle := L2N2Hndl(NewHandle(SizeOf(L2N2)));		HLock(Handle(L2N2_Handle));		byteCount := Sizeof(L2N2);		errCode := FSRead(refNum_xx,byteCount,@L2N2_Handle^^);	        ReserveMem(SizeOf(L2N3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2N3_Handle := L2N3Hndl(NewHandle(SizeOf(L2N3)));		HLock(Handle(L2N3_Handle));		byteCount := Sizeof(L2N3);		errCode := FSRead(refNum_xx,byteCount,@L2N3_Handle^^);	        ReserveMem(SizeOf(L2N5)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2N5_Handle := L2N5Hndl(NewHandle(SizeOf(L2N5)));		HLock(Handle(L2N5_Handle));		byteCount := Sizeof(L2N5);		errCode := FSRead(refNum_xx,byteCount,@L2N5_Handle^^);	        ReserveMem(SizeOf(L2O2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2O2_Handle := L2O2Hndl(NewHandle(SizeOf(L2O2)));		HLock(Handle(L2O2_Handle));		byteCount := Sizeof(L2O2);		errCode := FSRead(refNum_xx,byteCount,@L2O2_Handle^^);	        ReserveMem(SizeOf(L2O3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2O3_Handle := L2O3Hndl(NewHandle(SizeOf(L2O3)));		HLock(Handle(L2O3_Handle));		byteCount := Sizeof(L2O3);		errCode := FSRead(refNum_xx,byteCount,@L2O3_Handle^^);	        ReserveMem(SizeOf(L2P2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L2P2_Handle := L2P2Hndl(NewHandle(SizeOf(L2P2)));		HLock(Handle(L2P2_Handle));		byteCount := Sizeof(L2P2);		errCode := FSRead(refNum_xx,byteCount,@L2P2_Handle^^);	        ReserveMem(SizeOf(L3N2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L3N2_Handle := L3N2Hndl(NewHandle(SizeOf(L3N2)));		HLock(Handle(L3N2_Handle));		byteCount := Sizeof(L3N2);		errCode := FSRead(refNum_xx,byteCount,@L3N2_Handle^^);	        ReserveMem(SizeOf(L3N3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L3N3_Handle := L3N3Hndl(NewHandle(SizeOf(L3N3)));		HLock(Handle(L3N3_Handle));		byteCount := Sizeof(L3N3);		errCode := FSRead(refNum_xx,byteCount,@L3N3_Handle^^);	        ReserveMem(SizeOf(L3O2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L3O2_Handle := L3O2Hndl(NewHandle(SizeOf(L3O2)));		HLock(Handle(L3O2_Handle));		byteCount := Sizeof(L3O2);		errCode := FSRead(refNum_xx,byteCount,@L3O2_Handle^^);	        ReserveMem(SizeOf(L3O3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L3O3_Handle := L3O3Hndl(NewHandle(SizeOf(L3O3)));		HLock(Handle(L3O3_Handle));		byteCount := Sizeof(L3O3);		errCode := FSRead(refNum_xx,byteCount,@L3O3_Handle^^);	        ReserveMem(SizeOf(L3P1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        L3P1_Handle := L3P1Hndl(NewHandle(SizeOf(L3P1)));		HLock(Handle(L3P1_Handle));		byteCount := Sizeof(L3P1);		errCode := FSRead(refNum_xx,byteCount,@L3P1_Handle^^);	        ReserveMem(SizeOf(LA1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LA1_Handle := LA1Hndl(NewHandle(SizeOf(LA1)));		HLock(Handle(LA1_Handle));		byteCount := Sizeof(LA1);		errCode := FSRead(refNum_xx,byteCount,@LA1_Handle^^);	        ReserveMem(SizeOf(LA2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LA2_Handle := LA2Hndl(NewHandle(SizeOf(LA2)));		HLock(Handle(LA2_Handle));		byteCount := Sizeof(LA2);		errCode := FSRead(refNum_xx,byteCount,@LA2_Handle^^);	        ReserveMem(SizeOf(LB1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB1_Handle := LB1Hndl(NewHandle(SizeOf(LB1)));		HLock(Handle(LB1_Handle));		byteCount := Sizeof(LB1);		errCode := FSRead(refNum_xx,byteCount,@LB1_Handle^^);	        ReserveMem(SizeOf(LB10)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB10_Handle := LB10Hndl(NewHandle(SizeOf(LB10)));		HLock(Handle(LB10_Handle));		byteCount := Sizeof(LB10);		errCode := FSRead(refNum_xx,byteCount,@LB10_Handle^^);	        ReserveMem(SizeOf(LB15)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB15_Handle := LB15Hndl(NewHandle(SizeOf(LB15)));		HLock(Handle(LB15_Handle));		byteCount := Sizeof(LB15);		errCode := FSRead(refNum_xx,byteCount,@LB15_Handle^^);	        ReserveMem(SizeOf(LB17)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB17_Handle := LB17Hndl(NewHandle(SizeOf(LB17)));		HLock(Handle(LB17_Handle));		byteCount := Sizeof(LB17);		errCode := FSRead(refNum_xx,byteCount,@LB17_Handle^^);	        ReserveMem(SizeOf(LB2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB2_Handle := LB2Hndl(NewHandle(SizeOf(LB2)));		HLock(Handle(LB2_Handle));		byteCount := Sizeof(LB2);		errCode := FSRead(refNum_xx,byteCount,@LB2_Handle^^);	        ReserveMem(SizeOf(LB3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB3_Handle := LB3Hndl(NewHandle(SizeOf(LB3)));		HLock(Handle(LB3_Handle));		byteCount := Sizeof(LB3);		errCode := FSRead(refNum_xx,byteCount,@LB3_Handle^^);	        ReserveMem(SizeOf(LB4)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB4_Handle := LB4Hndl(NewHandle(SizeOf(LB4)));		HLock(Handle(LB4_Handle));		byteCount := Sizeof(LB4);		errCode := FSRead(refNum_xx,byteCount,@LB4_Handle^^);	        ReserveMem(SizeOf(LB5)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB5_Handle := LB5Hndl(NewHandle(SizeOf(LB5)));		HLock(Handle(LB5_Handle));		byteCount := Sizeof(LB5);		errCode := FSRead(refNum_xx,byteCount,@LB5_Handle^^);	        ReserveMem(SizeOf(LB6)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB6_Handle := LB6Hndl(NewHandle(SizeOf(LB6)));		HLock(Handle(LB6_Handle));		byteCount := Sizeof(LB6);		errCode := FSRead(refNum_xx,byteCount,@LB6_Handle^^);	        ReserveMem(SizeOf(LB7)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB7_Handle := LB7Hndl(NewHandle(SizeOf(LB7)));		HLock(Handle(LB7_Handle));		byteCount := Sizeof(LB7);		errCode := FSRead(refNum_xx,byteCount,@LB7_Handle^^);	        ReserveMem(SizeOf(LB9)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LB9_Handle := LB9Hndl(NewHandle(SizeOf(LB9)));		HLock(Handle(LB9_Handle));		byteCount := Sizeof(LB9);		errCode := FSRead(refNum_xx,byteCount,@LB9_Handle^^);	        ReserveMem(SizeOf(LG1)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG1_Handle := LG1Hndl(NewHandle(SizeOf(LG1)));		HLock(Handle(LG1_Handle));		byteCount := Sizeof(LG1);		errCode := FSRead(refNum_xx,byteCount,@LG1_Handle^^);	        ReserveMem(SizeOf(LG2)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG2_Handle := LG2Hndl(NewHandle(SizeOf(LG2)));		HLock(Handle(LG2_Handle));		byteCount := Sizeof(LG2);		errCode := FSRead(refNum_xx,byteCount,@LG2_Handle^^);	        ReserveMem(SizeOf(LG11)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG11_Handle := LG11Hndl(NewHandle(SizeOf(LG11)));		HLock(Handle(LG11_Handle));		byteCount := Sizeof(LG11);		errCode := FSRead(refNum_xx,byteCount,@LG11_Handle^^);	        ReserveMem(SizeOf(LG3)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG3_Handle := LG3Hndl(NewHandle(SizeOf(LG3)));		HLock(Handle(LG3_Handle));		byteCount := Sizeof(LG3);		errCode := FSRead(refNum_xx,byteCount,@LG3_Handle^^);	        ReserveMem(SizeOf(LG4)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG4_Handle := LG4Hndl(NewHandle(SizeOf(LG4)));		HLock(Handle(LG4_Handle));		byteCount := Sizeof(LG4);		errCode := FSRead(refNum_xx,byteCount,@LG4_Handle^^);	        ReserveMem(SizeOf(LG4p)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;        LG4p_Handle := LG4pHndl(NewHandle(SizeOf(LG4p)));		HLock(Handle(LG4p_Handle));		byteCount := Sizeof(LG4p);		errCode := FSRead(refNum_xx,byteCount,@LG4p_Handle^^);	        ReserveMem(SizeOf(LG5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;        LG5_Handle := LG5Hndl(NewHandle(SizeOf(LG5)));		HLock(Handle(LG5_Handle));		byteCount := Sizeof(LG5);		errCode := FSRead(refNum_xx,byteCount,@LG5_Handle^^);	        ReserveMem(SizeOf(LG6)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG6_Handle := LG6Hndl(NewHandle(SizeOf(LG6)));		HLock(Handle(LG6_Handle));		byteCount := Sizeof(LG6);		errCode := FSRead(refNum_xx,byteCount,@LG6_Handle^^);	        ReserveMem(SizeOf(LG8)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        LG8_Handle := LG8Hndl(NewHandle(SizeOf(LG8)));		HLock(Handle(LG8_Handle));		byteCount := Sizeof(LG8);		errCode := FSRead(refNum_xx,byteCount,@LG8_Handle^^);	        ReserveMem(SizeOf(Ll)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;        Ll_Handle := LlHndl(NewHandle(SizeOf(Ll)));		HLock(Handle(Ll_Handle));		byteCount := Sizeof(Ll);		errCode := FSRead(refNum_xx,byteCount,@Ll_Handle^^);	        ReserveMem(SizeOf(Leta)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;        Leta_Handle := LetaHndl(NewHandle(SizeOf(Leta)));		HLock(Handle(Leta_Handle));		byteCount := Sizeof(Leta);		errCode := FSRead(refNum_xx,byteCount,@Leta_Handle^^);	        ReserveMem(SizeOf(Ls)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          Ls_Handle := LsHndl(NewHandle(SizeOf(Ls)));		HLock(Handle(Ls_Handle));		byteCount := Sizeof(Ls);		errCode := FSRead(refNum_xx,byteCount,@Ls_Handle^^);	        ReserveMem(SizeOf(Lt)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          Lt_Handle := LtHndl(NewHandle(SizeOf(Lt)));		HLock(Handle(Lt_Handle));		byteCount := Sizeof(Lt);		errCode := FSRead(refNum_xx,byteCount,@Lt_Handle^^);	        ReserveMem(SizeOf(Lu)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          Lu_Handle := LuHndl(NewHandle(SizeOf(Lu)));		HLock(Handle(Lu_Handle));		byteCount := Sizeof(Lu);		errCode := FSRead(refNum_xx,byteCount,@Lu_Handle^^);	        ReserveMem(SizeOf(Lv)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          Lv_Handle := LvHndl(NewHandle(SizeOf(Lv)));		HLock(Handle(Lv_Handle));		byteCount := Sizeof(Lv);		errCode := FSRead(refNum_xx,byteCount,@Lv_Handle^^);	        ReserveMem(SizeOf(M1N2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M1N2_Handle := M1N2Hndl(NewHandle(SizeOf(M1N2)));		HLock(Handle(M1N2_Handle));		byteCount := Sizeof(M1N2);		errCode := FSRead(refNum_xx,byteCount,@M1N2_Handle^^);	        ReserveMem(SizeOf(M1N3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M1N3_Handle := M1N3Hndl(NewHandle(SizeOf(M1N3)));		HLock(Handle(M1N3_Handle));		byteCount := Sizeof(M1N3);		errCode := FSRead(refNum_xx,byteCount,@M1N3_Handle^^);	        ReserveMem(SizeOf(M2M4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M2M4_Handle := M2M4Hndl(NewHandle(SizeOf(M2M4)));		HLock(Handle(M2M4_Handle));		byteCount := Sizeof(M2M4);		errCode := FSRead(refNum_xx,byteCount,@M2M4_Handle^^);	        ReserveMem(SizeOf(M2N1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M2N1_Handle := M2N1Hndl(NewHandle(SizeOf(M2N1)));		HLock(Handle(M2N1_Handle));		byteCount := Sizeof(M2N1);		errCode := FSRead(refNum_xx,byteCount,@M2N1_Handle^^);	        ReserveMem(SizeOf(M2N4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M2N4_Handle := M2N4Hndl(NewHandle(SizeOf(M2N4)));		HLock(Handle(M2N4_Handle));		byteCount := Sizeof(M2N4);		errCode := FSRead(refNum_xx,byteCount,@M2N4_Handle^^);	        ReserveMem(SizeOf(M3M4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3M4_Handle := M3M4Hndl(NewHandle(SizeOf(M3M4)));		HLock(Handle(M3M4_Handle));		byteCount := Sizeof(M3M4);		errCode := FSRead(refNum_xx,byteCount,@M3M4_Handle^^);	        ReserveMem(SizeOf(M3M5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3M5_Handle := M3M5Hndl(NewHandle(SizeOf(M3M5)));		HLock(Handle(M3M5_Handle));		byteCount := Sizeof(M3M5);		errCode := FSRead(refNum_xx,byteCount,@M3M5_Handle^^);	        ReserveMem(SizeOf(M3N1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3N1_Handle := M3N1Hndl(NewHandle(SizeOf(M3N1)));		HLock(Handle(M3N1_Handle));		byteCount := Sizeof(M3N1);		errCode := FSRead(refNum_xx,byteCount,@M3N1_Handle^^);	        ReserveMem(SizeOf(M3N4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3N4_Handle := M3N4Hndl(NewHandle(SizeOf(M3N4)));		HLock(Handle(M3N4_Handle));		byteCount := Sizeof(M3N4);		errCode := FSRead(refNum_xx,byteCount,@M3N4_Handle^^);	        ReserveMem(SizeOf(M3O1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3O1_Handle := M3O1Hndl(NewHandle(SizeOf(M3O1)));		HLock(Handle(M3O1_Handle));		byteCount := Sizeof(M3O1);		errCode := FSRead(refNum_xx,byteCount,@M3O1_Handle^^);	        ReserveMem(SizeOf(M3O4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3O4_Handle := M3O4Hndl(NewHandle(SizeOf(M3O4)));		HLock(Handle(M3O4_Handle));		byteCount := Sizeof(M3O4);		errCode := FSRead(refNum_xx,byteCount,@M3O4_Handle^^);	        ReserveMem(SizeOf(M3O5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M3O5_Handle := M3O5Hndl(NewHandle(SizeOf(M3O5)));		HLock(Handle(M3O5_Handle));		byteCount := Sizeof(M3O5);		errCode := FSRead(refNum_xx,byteCount,@M3O5_Handle^^);	        ReserveMem(SizeOf(M4N3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M4N3_Handle := M4N3Hndl(NewHandle(SizeOf(M4N3)));		HLock(Handle(M4N3_Handle));		byteCount := Sizeof(M4N3);		errCode := FSRead(refNum_xx,byteCount,@M4N3_Handle^^);	        ReserveMem(SizeOf(M4O2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M4O2_Handle := M4O2Hndl(NewHandle(SizeOf(M4O2)));		HLock(Handle(M4O2_Handle));		byteCount := Sizeof(M4O2);		errCode := FSRead(refNum_xx,byteCount,@M4O2_Handle^^);	        ReserveMem(SizeOf(M5O3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M5O3_Handle := M5O3Hndl(NewHandle(SizeOf(M5O3)));		HLock(Handle(M5O3_Handle));		byteCount := Sizeof(M5O3);		errCode := FSRead(refNum_xx,byteCount,@M5O3_Handle^^);	        ReserveMem(SizeOf(MA1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MA1_Handle := MA1Hndl(NewHandle(SizeOf(MA1)));		HLock(Handle(MA1_Handle));		byteCount := Sizeof(MA1);		errCode := FSRead(refNum_xx,byteCount,@MA1_Handle^^);	        ReserveMem(SizeOf(MA2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MA2_Handle := MA2Hndl(NewHandle(SizeOf(MA2)));		HLock(Handle(MA2_Handle));		byteCount := Sizeof(MA2);		errCode := FSRead(refNum_xx,byteCount,@MA2_Handle^^);        ReserveMem(SizeOf(MA1_2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MA1_2Handle := MA1_2_Hndl(NewHandle(SizeOf(MA1_2)));		HLock(Handle(MA1_2Handle)); 	        for nn := 57 to 95 do		  begin		  MA1_2Handle^^.Data[nn].Lamda :=  (MA1_Handle^^.Data[nn].Lamda +		                                   MA2_Handle^^.Data[nn].Lamda)/2.0;										    		  MA1_2Handle^^.Data[nn].Weight := (MA1_Handle^^.Data[nn].Weight + 		                                    MA2_Handle^^.Data[nn].Weight)/2;		  end;		          ReserveMem(SizeOf(MB)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MB_Handle := MBHndl(NewHandle(SizeOf(MB)));		HLock(Handle(MB_Handle));		byteCount := Sizeof(MB);		errCode := FSRead(refNum_xx,byteCount,@MB_Handle^^);	        ReserveMem(SizeOf(M2O4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          M2O4_Handle := M2O4Hndl(NewHandle(SizeOf(M2O4)));		HLock(Handle(M2O4_Handle));		byteCount := Sizeof(M2O4);		errCode := FSRead(refNum_xx,byteCount,@M2O4_Handle^^);	        ReserveMem(SizeOf(MG)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MG_Handle := MGHndl(NewHandle(SizeOf(MG)));		HLock(Handle(MG_Handle));		byteCount := Sizeof(MG);		errCode := FSRead(refNum_xx,byteCount,@MG_Handle^^);	        ReserveMem(SizeOf(MZ1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MZ1_Handle := MZ1Hndl(NewHandle(SizeOf(MZ1)));		HLock(Handle(MZ1_Handle));		byteCount := Sizeof(MZ1);		errCode := FSRead(refNum_xx,byteCount,@MZ1_Handle^^);	        ReserveMem(SizeOf(MZ2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MZ2_Handle := MZ2Hndl(NewHandle(SizeOf(MZ2)));		HLock(Handle(MZ2_Handle));		byteCount := Sizeof(MZ2);		errCode := FSRead(refNum_xx,byteCount,@MZ2_Handle^^);	        ReserveMem(SizeOf(N4N6)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          N4N6_Handle := N4N6Hndl(NewHandle(SizeOf(N4N6)));		HLock(Handle(N4N6_Handle));		byteCount := Sizeof(N4N6);		errCode := FSRead(refNum_xx,byteCount,@N4N6_Handle^^);	        ReserveMem(SizeOf(N5N6)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          N5N6_Handle := N5N6Hndl(NewHandle(SizeOf(N5N6)));		HLock(Handle(N5N6_Handle));		byteCount := Sizeof(N5N6);		errCode := FSRead(refNum_xx,byteCount,@N5N6_Handle^^);		(*   Start Satellite lines   *)	        ReserveMem(SizeOf(SKA)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA_Handle := SKAHndl(NewHandle(SizeOf(SKA)));		HLock(Handle(SKA_Handle));		byteCount := Sizeof(SKA);		errCode := FSRead(refNum_xx,byteCount,@SKA_Handle^^);	        ReserveMem(SizeOf(SKA3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA3_Handle := SKA3Hndl(NewHandle(SizeOf(SKA3)));		HLock(Handle(SKA3_Handle));		byteCount := Sizeof(SKA3);		errCode := FSRead(refNum_xx,byteCount,@SKA3_Handle^^);	        ReserveMem(SizeOf(SKA3p)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA3p_Handle := SKA3pHndl(NewHandle(SizeOf(SKA3p)));		HLock(Handle(SKA3p_Handle));		byteCount := Sizeof(SKA3p);		errCode := FSRead(refNum_xx,byteCount,@SKA3p_Handle^^);	        ReserveMem(SizeOf(SKA3pp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA3pp_Handle := SKA3ppHndl(NewHandle(SizeOf(SKA3pp)));		HLock(Handle(SKA3pp_Handle));		byteCount := Sizeof(SKA3pp);		errCode := FSRead(refNum_xx,byteCount,@SKA3pp_Handle^^);	        ReserveMem(SizeOf(SKA4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA4_Handle := SKA4Hndl(NewHandle(SizeOf(SKA4)));		HLock(Handle(SKA4_Handle));		byteCount := Sizeof(SKA4);		errCode := FSRead(refNum_xx,byteCount,@SKA4_Handle^^);	        ReserveMem(SizeOf(SKA5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA5_Handle := SKA5Hndl(NewHandle(SizeOf(SKA5)));		HLock(Handle(SKA5_Handle));		byteCount := Sizeof(SKA5);		errCode := FSRead(refNum_xx,byteCount,@SKA5_Handle^^);	        ReserveMem(SizeOf(SKA6)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA6_Handle := SKA6Hndl(NewHandle(SizeOf(SKA6)));		HLock(Handle(SKA6_Handle));		byteCount := Sizeof(SKA6);		errCode := FSRead(refNum_xx,byteCount,@SKA6_Handle^^);	        ReserveMem(SizeOf(SKA7)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA7_Handle := SKA7Hndl(NewHandle(SizeOf(SKA7)));		HLock(Handle(SKA7_Handle));		byteCount := Sizeof(SKA7);		errCode := FSRead(refNum_xx,byteCount,@SKA7_Handle^^);	        ReserveMem(SizeOf(SKA8)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA8_Handle := SKA8Hndl(NewHandle(SizeOf(SKA8)));		HLock(Handle(SKA8_Handle));		byteCount := Sizeof(SKA8);		errCode := FSRead(refNum_xx,byteCount,@SKA8_Handle^^);	        ReserveMem(SizeOf(SKA9)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKA9_Handle := SKA9Hndl(NewHandle(SizeOf(SKA9)));		HLock(Handle(SKA9_Handle));		byteCount := Sizeof(SKA9);		errCode := FSRead(refNum_xx,byteCount,@SKA9_Handle^^);	        ReserveMem(SizeOf(SKAp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKAp_Handle := SKApHndl(NewHandle(SizeOf(SKAp)));		HLock(Handle(SKAp_Handle));		byteCount := Sizeof(SKAp);		errCode := FSRead(refNum_xx,byteCount,@SKAp_Handle^^);	        ReserveMem(SizeOf(SKApp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKApp_Handle := SKAppHndl(NewHandle(SizeOf(SKApp)));		HLock(Handle(SKApp_Handle));		byteCount := Sizeof(SKApp);		errCode := FSRead(refNum_xx,byteCount,@SKApp_Handle^^);	        ReserveMem(SizeOf(SKB)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKB_Handle := SKBHndl(NewHandle(SizeOf(SKB)));		HLock(Handle(SKB_Handle));		byteCount := Sizeof(SKB);		errCode := FSRead(refNum_xx,byteCount,@SKB_Handle^^);	        ReserveMem(SizeOf(SKB10)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKB10_Handle := SKB10Hndl(NewHandle(SizeOf(SKB10)));		HLock(Handle(SKB10_Handle));		byteCount := Sizeof(SKB10);		errCode := FSRead(refNum_xx,byteCount,@SKB10_Handle^^);	        ReserveMem(SizeOf(SKB6)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKB6_Handle := SKB6Hndl(NewHandle(SizeOf(SKB6)));		HLock(Handle(SKB6_Handle));		byteCount := Sizeof(SKB6);		errCode := FSRead(refNum_xx,byteCount,@SKB6_Handle^^);	        ReserveMem(SizeOf(SKB7)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKB7_Handle := SKB7Hndl(NewHandle(SizeOf(SKB7)));		HLock(Handle(SKB7_Handle));		byteCount := Sizeof(SKB7);		errCode := FSRead(refNum_xx,byteCount,@SKB7_Handle^^);	        ReserveMem(SizeOf(SKB8)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKB8_Handle := SKB8Hndl(NewHandle(SizeOf(SKB8)));		HLock(Handle(SKB8_Handle));		byteCount := Sizeof(SKB8);		errCode := FSRead(refNum_xx,byteCount,@SKB8_Handle^^);	        ReserveMem(SizeOf(SKB9)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKB9_Handle := SKB9Hndl(NewHandle(SizeOf(SKB9)));		HLock(Handle(SKB9_Handle));		byteCount := Sizeof(SKB9);		errCode := FSRead(refNum_xx,byteCount,@SKB9_Handle^^);	        ReserveMem(SizeOf(SKBp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKBp_Handle := SKBpHndl(NewHandle(SizeOf(SKBp)));		HLock(Handle(SKBp_Handle));		byteCount := Sizeof(SKBp);		errCode := FSRead(refNum_xx,byteCount,@SKBp_Handle^^);	        ReserveMem(SizeOf(SKBpp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKBpp_Handle := SKBppHndl(NewHandle(SizeOf(SKBpp)));		HLock(Handle(SKBpp_Handle));		byteCount := Sizeof(SKBpp);		errCode := FSRead(refNum_xx,byteCount,@SKBpp_Handle^^);	        ReserveMem(SizeOf(SKBN)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKBN_Handle := SKBNHndl(NewHandle(SizeOf(SKBN)));		HLock(Handle(SKBN_Handle));		byteCount := Sizeof(SKBN);		errCode := FSRead(refNum_xx,byteCount,@SKBN_Handle^^);	        ReserveMem(SizeOf(SKBX)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKBX_Handle := SKBXHndl(NewHandle(SizeOf(SKBX)));		HLock(Handle(SKBX_Handle));		byteCount := Sizeof(SKBX);		errCode := FSRead(refNum_xx,byteCount,@SKBX_Handle^^);	        ReserveMem(SizeOf(SKBc4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKBc4_Handle := SKBc4Hndl(NewHandle(SizeOf(SKBc4)));		HLock(Handle(SKBc4_Handle));		byteCount := Sizeof(SKBc4);		errCode := FSRead(refNum_xx,byteCount,@SKBc4_Handle^^);	        ReserveMem(SizeOf(SKBc5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SKBc5_Handle := SKBc5Hndl(NewHandle(SizeOf(SKBc5)));		HLock(Handle(SKBc5_Handle));		byteCount := Sizeof(SKBc5);		errCode := FSRead(refNum_xx,byteCount,@SKBc5_Handle^^);	        ReserveMem(SizeOf(SLA1cZ)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA1cZ_Handle := SLA1cZHndl(NewHandle(SizeOf(SLA1cZ)));		HLock(Handle(SLA1cZ_Handle));		byteCount := Sizeof(SLA1cZ);		errCode := FSRead(refNum_xx,byteCount,@SLA1cZ_Handle^^);	end;		{ over_flow } Procedure over_flow_2;var byteCount : longint;errCode  : integer;	begin        ReserveMem(SizeOf(SLA2p)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA2p_Handle := SLA2pHndl(NewHandle(SizeOf(SLA2p)));		HLock(Handle(SLA2p_Handle));		byteCount := Sizeof(SLA2p);		errCode := FSRead(refNum_xx,byteCount,@SLA2p_Handle^^);	        ReserveMem(SizeOf(SLA3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA3_Handle := SLA3Hndl(NewHandle(SizeOf(SLA3)));		HLock(Handle(SLA3_Handle));		byteCount := Sizeof(SLA3);		errCode := FSRead(refNum_xx,byteCount,@SLA3_Handle^^);	        ReserveMem(SizeOf(SLA3cZ)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA3cZ_Handle := SLA3cZHndl(NewHandle(SizeOf(SLA3cZ)));		HLock(Handle(SLA3cZ_Handle));		byteCount := Sizeof(SLA3cZ);		errCode := FSRead(refNum_xx,byteCount,@SLA3cZ_Handle^^);	        ReserveMem(SizeOf(SLA4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA4_Handle := SLA4Hndl(NewHandle(SizeOf(SLA4)));		HLock(Handle(SLA4_Handle));		byteCount := Sizeof(SLA4);		errCode := FSRead(refNum_xx,byteCount,@SLA4_Handle^^);	        ReserveMem(SizeOf(SLA5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA5_Handle := SLA5Hndl(NewHandle(SizeOf(SLA5)));		HLock(Handle(SLA5_Handle));		byteCount := Sizeof(SLA5);		errCode := FSRead(refNum_xx,byteCount,@SLA5_Handle^^);	        ReserveMem(SizeOf(SLA6)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA6_Handle := SLA6Hndl(NewHandle(SizeOf(SLA6)));		HLock(Handle(SLA6_Handle));		byteCount := Sizeof(SLA6);		errCode := FSRead(refNum_xx,byteCount,@SLA6_Handle^^);	        ReserveMem(SizeOf(SLA7)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA7_Handle := SLA7Hndl(NewHandle(SizeOf(SLA7)));		HLock(Handle(SLA7_Handle));		byteCount := Sizeof(SLA7);		errCode := FSRead(refNum_xx,byteCount,@SLA7_Handle^^);	        ReserveMem(SizeOf(SLA8)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA8_Handle := SLA8Hndl(NewHandle(SizeOf(SLA8)));		HLock(Handle(SLA8_Handle));		byteCount := Sizeof(SLA8);		errCode := FSRead(refNum_xx,byteCount,@SLA8_Handle^^);	        ReserveMem(SizeOf(SLA9)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLA9_Handle := SLA9Hndl(NewHandle(SizeOf(SLA9)));		HLock(Handle(SLA9_Handle));		byteCount := Sizeof(SLA9);		errCode := FSRead(refNum_xx,byteCount,@SLA9_Handle^^);	        ReserveMem(SizeOf(SLAA)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLAA_Handle := SLAAHndl(NewHandle(SizeOf(SLAA)));		HLock(Handle(SLAA_Handle));		byteCount := Sizeof(SLAA);		errCode := FSRead(refNum_xx,byteCount,@SLAA_Handle^^);	        ReserveMem(SizeOf(SLAp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLAp_Handle := SLApHndl(NewHandle(SizeOf(SLAp)));		HLock(Handle(SLAp_Handle));		byteCount := Sizeof(SLAp);		errCode := FSRead(refNum_xx,byteCount,@SLAp_Handle^^);	        ReserveMem(SizeOf(SLAS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLAS_Handle := SLASHndl(NewHandle(SizeOf(SLAS)));		HLock(Handle(SLAS_Handle));		byteCount := Sizeof(SLAS);		errCode := FSRead(refNum_xx,byteCount,@SLAS_Handle^^);	        ReserveMem(SizeOf(SLAcIX)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLAcIX_Handle := SLAcIXHndl(NewHandle(SizeOf(SLAcIX)));		HLock(Handle(SLAcIX_Handle));		byteCount := Sizeof(SLAcIX);		errCode := FSRead(refNum_xx,byteCount,@SLAcIX_Handle^^);	        ReserveMem(SizeOf(SLAcX)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLAcX_Handle := SLAcXHndl(NewHandle(SizeOf(SLAcX)));		HLock(Handle(SLAcX_Handle));		byteCount := Sizeof(SLAcX);		errCode := FSRead(refNum_xx,byteCount,@SLAcX_Handle^^);	        ReserveMem(SizeOf(SLAcY)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLAcY_Handle := SLAcYHndl(NewHandle(SizeOf(SLAcY)));		HLock(Handle(SLAcY_Handle));		byteCount := Sizeof(SLAcY);		errCode := FSRead(refNum_xx,byteCount,@SLAcY_Handle^^);	        ReserveMem(SizeOf(SLB14)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB14_Handle := SLB14Hndl(NewHandle(SizeOf(SLB14)));		HLock(Handle(SLB14_Handle));		byteCount := Sizeof(SLB14);		errCode := FSRead(refNum_xx,byteCount,@SLB14_Handle^^);	        ReserveMem(SizeOf(SLB1pp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB1pp_Handle := SLB1ppHndl(NewHandle(SizeOf(SLB1pp)));		HLock(Handle(SLB1pp_Handle));		byteCount := Sizeof(SLB1pp);		errCode := FSRead(refNum_xx,byteCount,@SLB1pp_Handle^^);	        ReserveMem(SizeOf(SLB1c4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB1c4_Handle := SLB1c4Hndl(NewHandle(SizeOf(SLB1c4)));		HLock(Handle(SLB1c4_Handle));		byteCount := Sizeof(SLB1c4);		errCode := FSRead(refNum_xx,byteCount,@SLB1c4_Handle^^);	        ReserveMem(SizeOf(SLB2c1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2c1_Handle := SLB2c1Hndl(NewHandle(SizeOf(SLB2c1)));		HLock(Handle(SLB2c1_Handle));		byteCount := Sizeof(SLB2c1);		errCode := FSRead(refNum_xx,byteCount,@SLB2c1_Handle^^);	        ReserveMem(SizeOf(SLB2c2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2c2_Handle := SLB2c2Hndl(NewHandle(SizeOf(SLB2c2)));		HLock(Handle(SLB2c2_Handle));		byteCount := Sizeof(SLB2c2);		errCode := FSRead(refNum_xx,byteCount,@SLB2c2_Handle^^);	        ReserveMem(SizeOf(SLB2c3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2c3_Handle := SLB2c3Hndl(NewHandle(SizeOf(SLB2c3)));		HLock(Handle(SLB2c3_Handle));		byteCount := Sizeof(SLB2c3);		errCode := FSRead(refNum_xx,byteCount,@SLB2c3_Handle^^);	        ReserveMem(SizeOf(SLB2c4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2c4_Handle := SLB2c4Hndl(NewHandle(SizeOf(SLB2c4)));		HLock(Handle(SLB2c4_Handle));		byteCount := Sizeof(SLB2c4);		errCode := FSRead(refNum_xx,byteCount,@SLB2c4_Handle^^);	        ReserveMem(SizeOf(SLB2c5)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2c5_Handle := SLB2c5Hndl(NewHandle(SizeOf(SLB2c5)));		HLock(Handle(SLB2c5_Handle));		byteCount := Sizeof(SLB2c5);		errCode := FSRead(refNum_xx,byteCount,@SLB2c5_Handle^^);	        ReserveMem(SizeOf(SLB2c7)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2c7_Handle := SLB2c7Hndl(NewHandle(SizeOf(SLB2c7)));		HLock(Handle(SLB2c7_Handle));		byteCount := Sizeof(SLB2c7);		errCode := FSRead(refNum_xx,byteCount,@SLB2c7_Handle^^);	        ReserveMem(SizeOf(SLB2cA)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2cA_Handle := SLB2cAHndl(NewHandle(SizeOf(SLB2cA)));		HLock(Handle(SLB2cA_Handle));		byteCount := Sizeof(SLB2cA);		errCode := FSRead(refNum_xx,byteCount,@SLB2cA_Handle^^);	        ReserveMem(SizeOf(SLB2cB)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2cB_Handle := SLB2cBHndl(NewHandle(SizeOf(SLB2cB)));		HLock(Handle(SLB2cB_Handle));		byteCount := Sizeof(SLB2cB);		errCode := FSRead(refNum_xx,byteCount,@SLB2cB_Handle^^);	        ReserveMem(SizeOf(SLB2cC)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB2cC_Handle := SLB2cCHndl(NewHandle(SizeOf(SLB2cC)));		HLock(Handle(SLB2cC_Handle));		byteCount := Sizeof(SLB2cC);		errCode := FSRead(refNum_xx,byteCount,@SLB2cC_Handle^^);	        ReserveMem(SizeOf(SLB5c1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB5c1_Handle := SLB5c1Hndl(NewHandle(SizeOf(SLB5c1)));		HLock(Handle(SLB5c1_Handle));		byteCount := Sizeof(SLB5c1);		errCode := FSRead(refNum_xx,byteCount,@SLB5c1_Handle^^);	        ReserveMem(SizeOf(SLB5c2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLB5c2_Handle := SLB5c2Hndl(NewHandle(SizeOf(SLB5c2)));		HLock(Handle(SLB5c2_Handle));		byteCount := Sizeof(SLB5c2);		errCode := FSRead(refNum_xx,byteCount,@SLB5c2_Handle^^);	        ReserveMem(SizeOf(SLG10)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLG10_Handle := SLG10Hndl(NewHandle(SizeOf(SLG10)));		HLock(Handle(SLG10_Handle));		byteCount := Sizeof(SLG10);		errCode := FSRead(refNum_xx,byteCount,@SLG10_Handle^^);	        ReserveMem(SizeOf(SLG1p)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLG1p_Handle := SLG1pHndl(NewHandle(SizeOf(SLG1p)));		HLock(Handle(SLG1p_Handle));		byteCount := Sizeof(SLG1p);		errCode := FSRead(refNum_xx,byteCount,@SLG1p_Handle^^);	        ReserveMem(SizeOf(SLG2p)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLG2p_Handle := SLG2pHndl(NewHandle(SizeOf(SLG2p)));		HLock(Handle(SLG2p_Handle));		byteCount := Sizeof(SLG2p);		errCode := FSRead(refNum_xx,byteCount,@SLG2p_Handle^^);	        ReserveMem(SizeOf(SLG2pp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLG2pp_Handle := SLG2ppHndl(NewHandle(SizeOf(SLG2pp)));		HLock(Handle(SLG2pp_Handle));		byteCount := Sizeof(SLG2pp);		errCode := FSRead(refNum_xx,byteCount,@SLG2pp_Handle^^);	        ReserveMem(SizeOf(SLG9)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SLG9_Handle := SLG9Hndl(NewHandle(SizeOf(SLG9)));		HLock(Handle(SLG9_Handle));		byteCount := Sizeof(SLG9);		errCode := FSRead(refNum_xx,byteCount,@SLG9_Handle^^);	        ReserveMem(SizeOf(SMAc1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMAc1_Handle := SMAc1Hndl(NewHandle(SizeOf(SMAc1)));		HLock(Handle(SMAc1_Handle));		byteCount := Sizeof(SMAc1);		errCode := FSRead(refNum_xx,byteCount,@SMAc1_Handle^^);	        ReserveMem(SizeOf(SMAc2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMAc2_Handle := SMAc2Hndl(NewHandle(SizeOf(SMAc2)));		HLock(Handle(SMAc2_Handle));		byteCount := Sizeof(SMAc2);		errCode := FSRead(refNum_xx,byteCount,@SMAc2_Handle^^);	        ReserveMem(SizeOf(SMAc3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMAc3_Handle := SMAc3Hndl(NewHandle(SizeOf(SMAc3)));		HLock(Handle(SMAc3_Handle));		byteCount := Sizeof(SMAc3);		errCode := FSRead(refNum_xx,byteCount,@SMAc3_Handle^^);	        ReserveMem(SizeOf(SMAc4)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMAc4_Handle := SMAc4Hndl(NewHandle(SizeOf(SMAc4)));		HLock(Handle(SMAc4_Handle));		byteCount := Sizeof(SMAc4);		errCode := FSRead(refNum_xx,byteCount,@SMAc4_Handle^^);	        ReserveMem(SizeOf(SMB1)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMB1_Handle := SMB1Hndl(NewHandle(SizeOf(SMB1)));		HLock(Handle(SMB1_Handle));		byteCount := Sizeof(SMB1);		errCode := FSRead(refNum_xx,byteCount,@SMB1_Handle^^);	        ReserveMem(SizeOf(SMB2)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMB2_Handle := SMB2Hndl(NewHandle(SizeOf(SMB2)));		HLock(Handle(SMB2_Handle));		byteCount := Sizeof(SMB2);		errCode := FSRead(refNum_xx,byteCount,@SMB2_Handle^^);	        ReserveMem(SizeOf(SMB3)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMB3_Handle := SMB3Hndl(NewHandle(SizeOf(SMB3)));		HLock(Handle(SMB3_Handle));		byteCount := Sizeof(SMB3);		errCode := FSRead(refNum_xx,byteCount,@SMB3_Handle^^);	        ReserveMem(SizeOf(SMGp)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          SMGp_Handle := SMGpHndl(NewHandle(SizeOf(SMGp)));		HLock(Handle(SMGp_Handle));		byteCount := Sizeof(SMGp);		errCode := FSRead(refNum_xx,byteCount,@SMGp_Handle^^);	(*   Now the Absorption Edges   *)		        ReserveMem(SizeOf(K_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          K_ABS_Handle := K_ABSHndl(NewHandle(SizeOf(K_ABS)));		HLock(Handle(K_ABS_Handle));		byteCount := Sizeof(K_ABS);		errCode := FSRead(refNum_xx,byteCount,@K_ABS_Handle^^);		        ReserveMem(SizeOf(LI_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          LI_ABS_Handle := LI_ABSHndl(NewHandle(SizeOf(LI_ABS)));		HLock(Handle(LI_ABS_Handle));		byteCount := Sizeof(LI_ABS);		errCode := FSRead(refNum_xx,byteCount,@LI_ABS_Handle^^);	        ReserveMem(SizeOf(LII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          LII_ABS_Handle := LII_ABSHndl(NewHandle(SizeOf(LII_ABS)));		HLock(Handle(LII_ABS_Handle));		byteCount := Sizeof(LII_ABS);		errCode := FSRead(refNum_xx,byteCount,@LII_ABS_Handle^^);	        ReserveMem(SizeOf(LIII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          LIII_ABS_Handle := LIII_ABSHndl(NewHandle(SizeOf(LIII_ABS)));		HLock(Handle(LIII_ABS_Handle));		byteCount := Sizeof(LIII_ABS);		errCode := FSRead(refNum_xx,byteCount,@LIII_ABS_Handle^^);		        ReserveMem(SizeOf(MI_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MI_ABS_Handle := MI_ABSHndl(NewHandle(SizeOf(MI_ABS)));		HLock(Handle(MI_ABS_Handle));		byteCount := Sizeof(MI_ABS);		errCode := FSRead(refNum_xx,byteCount,@MI_ABS_Handle^^);	        ReserveMem(SizeOf(MII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MII_ABS_Handle := MII_ABSHndl(NewHandle(SizeOf(MII_ABS)));		HLock(Handle(MII_ABS_Handle));		byteCount := Sizeof(MII_ABS);		errCode := FSRead(refNum_xx,byteCount,@MII_ABS_Handle^^);	        ReserveMem(SizeOf(MIII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MIII_ABS_Handle := MIII_ABSHndl(NewHandle(SizeOf(MIII_ABS)));		HLock(Handle(MIII_ABS_Handle));		byteCount := Sizeof(MIII_ABS);		errCode := FSRead(refNum_xx,byteCount,@MIII_ABS_Handle^^);	        ReserveMem(SizeOf(MIV_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MIV_ABS_Handle := MIV_ABSHndl(NewHandle(SizeOf(MIV_ABS)));		HLock(Handle(MIV_ABS_Handle));		byteCount := Sizeof(MIV_ABS);		errCode := FSRead(refNum_xx,byteCount,@MIV_ABS_Handle^^);	        ReserveMem(SizeOf(MV_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          MV_ABS_Handle := MV_ABSHndl(NewHandle(SizeOf(MV_ABS)));		HLock(Handle(MV_ABS_Handle));		byteCount := Sizeof(MV_ABS);		errCode := FSRead(refNum_xx,byteCount,@MV_ABS_Handle^^);	        ReserveMem(SizeOf(NI_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NI_ABS_Handle := NI_ABSHndl(NewHandle(SizeOf(NI_ABS)));		HLock(Handle(NI_ABS_Handle));		byteCount := Sizeof(NI_ABS);		errCode := FSRead(refNum_xx,byteCount,@NI_ABS_Handle^^);	        ReserveMem(SizeOf(NII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NII_ABS_Handle := NII_ABSHndl(NewHandle(SizeOf(NII_ABS)));		HLock(Handle(NII_ABS_Handle));		byteCount := Sizeof(NII_ABS);		errCode := FSRead(refNum_xx,byteCount,@NII_ABS_Handle^^);	        ReserveMem(SizeOf(NIII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NIII_ABS_Handle := NIII_ABSHndl(NewHandle(SizeOf(NIII_ABS)));		HLock(Handle(NIII_ABS_Handle));		byteCount := Sizeof(NIII_ABS);		errCode := FSRead(refNum_xx,byteCount,@NIII_ABS_Handle^^);	        ReserveMem(SizeOf(NIV_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NIV_ABS_Handle := NIV_ABSHndl(NewHandle(SizeOf(NIV_ABS)));		HLock(Handle(NIV_ABS_Handle));		byteCount := Sizeof(NIV_ABS);		errCode := FSRead(refNum_xx,byteCount,@NIV_ABS_Handle^^);	        ReserveMem(SizeOf(NV_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NV_ABS_Handle := NV_ABSHndl(NewHandle(SizeOf(NV_ABS)));		HLock(Handle(NV_ABS_Handle));		byteCount := Sizeof(NV_ABS);		errCode := FSRead(refNum_xx,byteCount,@NV_ABS_Handle^^);	        ReserveMem(SizeOf(NVI_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NVI_ABS_Handle := NVI_ABSHndl(NewHandle(SizeOf(NVI_ABS)));		HLock(Handle(NVI_ABS_Handle));		byteCount := Sizeof(NVI_ABS);		errCode := FSRead(refNum_xx,byteCount,@NVI_ABS_Handle^^);	        ReserveMem(SizeOf(NVII_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NVII_ABS_Handle := NVII_ABSHndl(NewHandle(SizeOf(NVII_ABS)));		HLock(Handle(NVII_ABS_Handle));		byteCount := Sizeof(NVII_ABS);		errCode := FSRead(refNum_xx,byteCount,@NVII_ABS_Handle^^);		        ReserveMem(SizeOf(NOl_ABS)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then Bag_the_Program;	          NOl_ABS_Handle := NOl_ABSHndl(NewHandle(SizeOf(NOl_ABS)));		HLock(Handle(NOl_ABS_Handle));		byteCount := Sizeof(NOl_ABS);		errCode := FSRead(refNum_xx,byteCount,@NOl_ABS_Handle^^);				{errCode := FSclose(refNum_xx); } 		    end;	{ Over_Flow_2 }	{$S INITIALIZE2}	PROCEDURE load_energy_series;			VAR			byteCount	:	longint;			errCode		:	integer;				BEGIN			ReserveMem(SizeOf(Energy_Series));			if MemError = memFullErr then Bag_the_Program;			EnSer_Handle := EnSer_Hndl(NewHandle(SizeOf(Energy_Series)));			HLock(Handle(EnSer_Handle));			byteCount := SizeOf(Energy_Series);			errCode := FSRead(refNum_xx,byteCount,@EnSer_Handle^^);					errCode := FSclose(refNum_xx); 				END;   {load_energy_series}    PROCEDURE ProtoInits;       { ...to initialize resource item numbers, etc for dialogs }      VAR        index                        : integer;      BEGIN        FOR index := 1 TO 10 DO          BEGIN            A^.Peak_Info_Width[index] := index + 17;            A^.Peak_Info_Amplitude[index] := index + 27;            A^.Peak_Info_Energy[index] := index + 37;            A^.C_Full[index] := index + 2;            A^.S_to_Work[index] := index;            A^.Work_to_S[index] := index + 9;            A^.Copy_S_to_Work[index] := index;            A^.Copy_Work_to_S[index] := index + 9;            A^.Plt_Syms_S[index] := index + 2;          END;                                        { for index }        A^.C_Full[9] := 2;        A^.C_Full[10] := 1;      END; 	procedure CheckBits;		const			QD32Trap = $AB03;			UnimplementedTrap = $A89F;		var			myEnvRec: SysEnvRec;			err: OSErr;			OldSystem: boolean;			SystemRefNum: integer;			Has32BitQuickDraw: boolean;				begin		err := SysEnvirons(1, myEnvRec);		if err <> envNotPresent then			with MyEnvRec do begin					if not HasColorQD then begin							PutEarlyMessage('DTSA needs a Macintosh with Color QuickDraw.','','','');							Halt;						end;					{if not HasFPU then begin			 PutEarlyMessage('DTSA needs a floating-point coprocessor because of the extensive ',							 'mathematical and physical calculations performed, often at every',							 'channel of the spectrum. You would be unhappy with the ',							 'program if we allowed you to proceed!!! Sorry.');							Halt;						end;}					OldSystem := systemVersion < $0605;					SystemRefNum := sysVRefNum;				end;		Has32BitQuickDraw := nGetTrapAddress(QD32Trap, ToolTrap) <> 		                     nGetTrapAddress(UnimplementedTrap, ToolTrap);			MainDevice := GetMainDevice;		if MainDevice^^.gdPmap^^.PixelSize > 8 then begin				(*PutEarlyMessage('This version of DTSA will not work with more than 256 colors.',				                'Change back to 256 colors in the Mac "control panel" ','','');*)				ChangePixDepth := AnswerMessage('This version of DTSA will not work with more than 256 colors.',				                'Change back to 256 colors in the Mac "control panel" ',								'or, if Its OK I will change it for you, ','otherwise select Its NOT OK to exit.');								IF ChangePixDepth then begin				Pix_depth := MainDevice^^.gdPmap^^.PixelSize;				err := SetDepth(MainDevice, 8, 1, 1);				end				ELSE				Halt;			end;		(*ScreenPixMap := MainDevice^^.gdPMap;		ScreenRowBytes := BitAnd(ScreenPixMap^^.rowBytes, $1fff);		ScreenBase := ScreenPixMap^^.baseAddr;	*)	end; FUNCTION GetPrintRecord(theResFile: INTEGER): THPrint;VAR	currentResFile: INTEGER;	theResource:	Handle;	theError:	   OSErr;	str, str1 :          str255;BEGIN	currentResFile := CurResFile;	UseResFile(theResFile);	str := 'Unknown error, number';	theError := ResError;	numtostring(theError,str1);	  if theError = rmvResFailed then str := 'RemoveResource failed';	  if theError = resNotFound then str := 'resource not found';	  if theError = resFNotFound then str := 'resource file not found';	  if theError = addResFailed then str := 'AddResource failed';	  IF theError <> noErr THEN 		 begin		   putmessage('There was an error in trying to open the Printing Record.',										   'The error at 1 was:',str,str1);		   UseResFile(currentResFile);		   exit(GetPrintRecord);		 end;	 	IF theError = noErr THEN BEGIN		theResource := GetResource(gPRResType, gPRResID);		theError := ResError;		numtostring(theError,str1);		  if theError = rmvResFailed then str := 'RemoveResource failed';		  if theError = resNotFound then str  := 'resource not found';		  if theError = resFNotFound then str := 'resource file not found';		  if theError = addResFailed then str := 'AddResource failed';		  IF theError <> noErr THEN 			 begin			   putmessage('There was an error in trying to open the Printing Record.',											   'The error at 2 was:',str,str1);			   UseResFile(currentResFile);			   exit(GetPrintRecord);			 end;	 		IF theError = noErr THEN BEGIN			PrOpen;			theError := PrError;	         IF theError <> noErr THEN PrClose; { Close the Printing Manager before attempting to report the error.} 			numtostring(theError,str1); 			   if theError = -1  then str := 'saving print file';			   if theError = -17 then str := 'unimplemented control instruction';			   if theError = -27 then str := 'I/O error';			   if theError = -108 then str := 'not enough room in heap zone';			   if theError = 128 then str := 'application or user requested abort';			   if theError = -4101  then str := 'Printer not found or closed';			   if theError = -4100  then str := 'Connection just closed';			   if theError = -4099  then str := 'Write request too big ';			   if theError = -4098  then str := 'Request already active';			   if theError = -4097  then str := 'Bad connection refnum';			   if theError = -4096  then str := 'No free CCBs (Connect Control Blocks) available';			   if theError = -8133  then str := 'PostScript error occurred during transmission';			   if theError = -8132  then str := 'Timeout occured.';			   if theError = -43    then str := 'You have not selected a Printer.';	        IF theError <> noErr THEN putmessage('There was trouble getting a print record at 3, the message was:',			           str,'The number was',str1); 			IF theError = noErr THEN IF PrValidate(THPrint(theResource)) THEN ;			IF theError <> noErr THEN putmessage('There was trouble validating the print record','','',''); 			 PrClose; 		END;	END;	PrClose; 	UseResFile(currentResFile);	GetPrintRecord := THPrint(theResource);END;       {=================================}       PROCEDURE ChangeCursor(C: Ptr);   {Change cursor. Current cursor pointer is always in CurrentC}      TYPE        CursorPtr                     = ^Cursor;             BEGIN        IF C = CurrentC          THEN            Exit(ChangeCursor)                        {exit if already proper cursor}          ELSE            IF C = NIL              THEN                SetCursor(CursorPtr(LastC)^)          {last cursor if nil}              ELSE                BEGIN                  LastC := CurrentC;                  {else remember current cursor}                  SetCursor(CursorPtr(C)^);           {and switch to new one}                  CurrentC := C;                END;      END;	    PROCEDURE Default_WorkSpectrum_Fields; { Is used only for bringing in ascii type spectra. }      BEGIN        { Initialize all of the spectrum fields with something that will not be memory merde }        WITH Plt_spec[10]^^ DO          BEGIN            WITH Expt_Info DO              BEGIN                FirstSpec := 1;                LastSpect := 1;				spare2 := False;	{ denotes demo file }              END;                                    { with Expt_Info }            WITH SpectrumStuff.Spectrum_Info DO              BEGIN				spare2 := False;	{ denotes demo spectrum }			    BkgSubtracted := False;                Spectrum_number := 1;                Theoretically_Generated := FALSE;     { Boolean }				This_is_a_Standard := FALSE;				Spectrum_Type := ' ';              END;                                    { with SpectrumStuff.Spectrum_Info }            WITH SpectrumStuff.Acq_Info DO              BEGIN                SpectrumStuff.Acq_Info.Begin_Time := 0; { temp load in current dateTime}              END;                                    { with SpectrumStuff.Acq_Info }          END;      END;                                            { Procedure }PROCEDURE AssignMemory;      VAR        index                    : integer;BEGIN  	   XIntPtr := IntArrayPtr(NewPtr(SizeOf(IntArray)));				   if MemError = memFullErr then Bag_the_Program; 	   YIntPtr := IntArrayPtr(NewPtr(SizeOf(IntArray)));				   if MemError = memFullErr then Bag_the_Program; 	   Bkg_P := Bkg_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Gen_P := Gen_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Composite_P := Composite_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Det_Effic_P := Det_Effic_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   mu_rho_P := mu_rho_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   f_chi_P := f_chi_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Ob_Pks_P := Ob_Pks_Ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Bkg_ResponseFnc := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Gen_ResponseFnc := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Col_1 := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Col_2 := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Col_3 := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Col_4 := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Col_5 := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Col_6 := Col_ptr(NewPtr(SizeOf(Spectrum_counts)));				   if MemError = memFullErr then Bag_the_Program; 	   Generated := GenStuff_ptr(NewPtr(SizeOf(Gen_Pk_Arrays)));				   if MemError = memFullErr then Bag_the_Program; 	   InFront_Detector := GenStuff_ptr(NewPtr(SizeOf(Gen_Pk_Arrays)));				   if MemError = memFullErr then Bag_the_Program; 	   InFront_Detector_Fluor := GenStuff_ptr(NewPtr(SizeOf(Gen_Pk_Arrays)));				   if MemError = memFullErr then Bag_the_Program; 	   Inside_Detector := GenStuff_ptr(NewPtr(SizeOf(Gen_Pk_Arrays)));				   if MemError = memFullErr then Bag_the_Program; 	   Line_Energy := GenStuff_ptr(NewPtr(SizeOf(Gen_Pk_Arrays)));				   if MemError = memFullErr then Bag_the_Program; 	   A := Array_Stuff_Ptr(NewPtr(SizeOf(Array_Stuff)));				   if MemError = memFullErr then Bag_the_Program; 	   xxx := NumRecp_Ptr(NewPtr(SizeOf(glsarray)));				   if MemError = memFullErr then Bag_the_Program; 	   yyy := NumRecp_Ptr(NewPtr(SizeOf(glsarray)));				   if MemError = memFullErr then Bag_the_Program; 	   arr := NumRecp_Ptr(NewPtr(SizeOf(glsarray)));		 if MemError = memFullErr then Bag_the_Program;           FOR index := 1 TO 10 DO          BEGIN		    ReserveMem(SizeOf(work_spectrum)); { Reserve memory near the beginning of heap } 		    if MemError = memFullErr then Bag_the_Program;            Plt_spec[index] := WorkS(NewHandle(SizeOf(work_spectrum)));			HLock(Handle(Plt_spec[index]));             END;        ReserveMem(SizeOf(Simplex_Fit)); { Reserve memory near the beginning of heap }         if MemError = memFullErr then Bag_the_Program;         Analysis_Result := SimpS(NewHandle(SizeOf(Simplex_Fit)));		 HLock(Handle(Analysis_Result));         ReserveMem(SizeOf(References_rec)); { Reserve memory near the beginning of heap }         if MemError = memFullErr then Bag_the_Program;         Ref_Stuff := RefS(NewHandle(sizeof(References_rec)));	{this is the global var}		 HLock(Handle(Ref_Stuff));        ReserveMem(SizeOf(Fit_Record)); { Reserve memory near the beginning of heap }       if MemError = memFullErr then Bag_the_Program;        FitS := FitHdl(NewHandle(SizeOf(Fit_Record)));		HLock(Handle(FitS));		        ReserveMem(SizeOf(Big_Array)); { Reserve memory near the beginning of heap }			   		if MemError = memFullErr then Bag_the_Program;        BigHndl := Big_A(NewHandle(SizeOf(Big_Array)));		HLock(Handle(BigHndl));        ReserveMem(SizeOf(ROIs)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        ROI := ROIHndl(NewHandle(SizeOf(ROIs)));		HLock(Handle(ROI));        ReserveMem(SizeOf(Labels)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        Lab := LabelHndl(NewHandle(SizeOf(Labels)));		HLock(Handle(Lab));        ReserveMem(SizeOf(Spectrum_FFT)); { Reserve memory near the beginning of heap }		if MemError = memFullErr then Bag_the_Program;        theFFTHdl := FFTHdl(NewHandle(SizeOf(Spectrum_FFT)));		HLock(Handle(theFFTHdl)); 		         ReserveMem(SizeOf(TPrint)); { Reserve memory near the beginning of heap }		 if MemError = memFullErr then Bag_the_Program;        thePrRec := THPrint(NewHandle(SizeOf(TPrint))); 		HLock(Handle(thePrRec));         		    ReserveMem(sizeof(ML_Stuff));	if MemError = memFullErr then Bag_the_Program;	ML_Setup:=ML_Stuff_Hdl(NewHandle(sizeof(ML_Stuff)));	HLock(Handle(ML_Setup));			for index:= 1 to Max_Num_Terms do begin		 ReserveMem(sizeof(references_rec));		 if MemError = memFullErr then Bag_the_Program;		 reference[index]:=RefS(NewHandle(sizeof(references_rec))); { an MCA global } 		 HLock(Handle (Reference[index]) );     end;        	(*	ReserveMem(sizeof(CL_outstuff));		if MemError = memFullErr then Bag_the_Program;		CL_Output := CLOutHdl(NewHandle(sizeof(CL_outstuff)));		HLock(Handle(CL_Output));			*)				ReserveMem(sizeof(CL_BaseStuff));		if MemError = memFullErr then Bag_the_Program;		CL_BsSetup := CLBsHdl(NewHandle(sizeof(CL_BaseStuff)));		HLock(Handle(CL_BsSetup));		        		ReserveMem(sizeof(Hall_outstuff));		if MemError = memFullErr then Bag_the_Program;		Hall_Output := HallOutHdl(NewHandle(sizeof(Hall_outstuff)));		HLock(Handle(Hall_Output));				ReserveMem(sizeof(Hall_stuff));		if MemError = memFullErr then Bag_the_Program;		Hall_Setup := HallHdl(NewHandle(sizeof(Hall_stuff)));		HLock(Handle(Hall_Setup));				ReserveMem(sizeof(SiLi_Rec));		if MemError = memFullErr then Bag_the_Program;		theGenRec := SiLi_RecHdl(NewHandle(sizeof(SiLi_Rec)));		HLock(Handle(theGenRec));				ReserveMem(sizeof(SiLi_Rec));		if MemError = memFullErr then Bag_the_Program;		theBGRec := SiLi_RecHdl(NewHandle(sizeof(SiLi_Rec)));		HLock(Handle(theBGRec));				ReserveMem(sizeof(X_Sect_Lab));		if MemError = memFullErr then Bag_the_Program;		X_SectRec := X_SectHdl(NewHandle(sizeof(X_Sect_Lab)));		HLock(Handle(X_SectRec));			 		        		Save_Volume_Name:=StringPtr(NewPtr(Sizeof(Str255)));				   if MemError = memFullErr then Bag_the_Program;		volName:=StringPtr(NewPtr(Sizeof(Str255)));				   if MemError = memFullErr then Bag_the_Program;		Default_Volume_Name:=StringPtr(NewPtr(Sizeof(Str255)));				   if MemError = memFullErr then Bag_the_Program;		Binary_Volume_Name:=StringPtr(NewPtr(Sizeof(Str255)));				   if MemError = memFullErr then Bag_the_Program;END; { PROCEDURE AssignMemory }{$S INITIALIZE3}    PROCEDURE Init_X_Sec_List;    	VAR  		index				: integer;  		temp_str			: string[23];  	BEGIN		{Create the lists of cross-sections for the spectrum header.}	WITH X_SectRec^^ DO	 BEGIN  		temp_str := '';		For index := 1 to 51 do begin			Thin_X_Xec_List[index] := '';			Bulk_X_Xec_List[index] := '';		end;		temp_str := 'Casnati';		Thin_X_Xec_List[2] := copy(temp_str,1,7);		Thin_X_Xec_List[3] := 'Schreiber_Wimms';		Thin_X_Xec_List[4] := 'Mott_Massey';		Thin_X_Xec_List[5] := 'Kolbenstvedt';		Thin_X_Xec_List[6] := 'Bethe_Fermi_Zalusek';		Thin_X_Xec_List[7] := 'Fabre';		Thin_X_Xec_List[8] := 'Sigma_K';		Thin_X_Xec_List[9] := 'Lotz_1_25';		Thin_X_Xec_List[10] := 'Green_Cosslett';		Thin_X_Xec_List[11] := 'Worthington_Tomlin';		Thin_X_Xec_List[12] := 'Gryzinski';		Thin_X_Xec_List[13] := 'Brown';		Thin_X_Xec_List[14] := 'Drawin';		Thin_X_Xec_List[15] := 'Jakoby';		Thin_X_Xec_List[16] := '';		Thin_X_Xec_List[17] := '';		Thin_X_Xec_List[18] := '';		Thin_X_Xec_List[19] := 'Casnati_L';		Thin_X_Xec_List[20] := 'Bethe_Fiori';		Thin_X_Xec_List[21] := 'Schreiber_Wimm';		Thin_X_Xec_List[22] := 'Bethe_Fermi_Zalusek';		Thin_X_Xec_List[23] := 'Brown';		Thin_X_Xec_List[24] := 'Bethe_Powell';		Thin_X_Xec_List[25] := 'Sigma_L';		Thin_X_Xec_List[26] := 'Fabre';		Thin_X_Xec_List[27] := '';		Thin_X_Xec_List[28] := '';		Thin_X_Xec_List[29] := '';		Thin_X_Xec_List[30] := 'Casnati_M';		Thin_X_Xec_List[31] := 'Schreiber_Wimms';		Thin_X_Xec_List[32] := 'Bethe';		Thin_X_Xec_List[33] := 'Bethe_Fiori_M';		Thin_X_Xec_List[34] := '';		Thin_X_Xec_List[35] := '';		Thin_X_Xec_List[36] := 'Marshall_Hall';		Thin_X_Xec_List[37] := 'Kirkpatrick_Wiedmann';		Thin_X_Xec_List[38] := 'Kirkpatrick_Wiedman';		Thin_X_Xec_List[39] := 'Modified_Bethe_Heitle';				Bulk_X_Xec_List[2] := 'Drawin';		Bulk_X_Xec_List[3] := 'Brown';		Bulk_X_Xec_List[4] := 'Gryzinski';		Bulk_X_Xec_List[5] := 'Worthington_Tomlin';		Bulk_X_Xec_List[6] := 'Green_Cosslett';		Bulk_X_Xec_List[7] := 'Lotz_1_25';		Bulk_X_Xec_List[8] := 'Sigma_K';		Bulk_X_Xec_List[9] := 'Fabre';		Bulk_X_Xec_List[10] := 'Casnati';		Bulk_X_Xec_List[11] := 'Kolbenstvedt';		Bulk_X_Xec_List[12] := 'Mott_Massey';		Bulk_X_Xec_List[13] := 'Jakoby';		Bulk_X_Xec_List[14] := 'Pouchou_Pichoir';		Bulk_X_Xec_List[15] := 'Pouchou';		Bulk_X_Xec_List[16] := '';		Bulk_X_Xec_List[17] := '';		Bulk_X_Xec_List[18] := 'Sigma_L';		Bulk_X_Xec_List[19] := 'Bethe_Powell';		Bulk_X_Xec_List[20] := 'Brown';		Bulk_X_Xec_List[21] := 'Fiori_Myklebust_L';		Bulk_X_Xec_List[22] := 'Casnati_L';		Bulk_X_Xec_List[23] := 'Pouchou_Pichoir_L';		Bulk_X_Xec_List[24] := 'Pouchou_L';		Bulk_X_Xec_List[25] := 'Jakoby_L';		Bulk_X_Xec_List[26] := 'Green_Cosslett_L';		Bulk_X_Xec_List[27] := '';		Bulk_X_Xec_List[28] := '';		Bulk_X_Xec_List[29] := '';		Bulk_X_Xec_List[30] := '';		Bulk_X_Xec_List[31] := '';		Bulk_X_Xec_List[32] := '';				Bulk_X_Xec_List[33] := 'Bethe_Fiori_M';		Bulk_X_Xec_List[34] := 'Bethe';		Bulk_X_Xec_List[35] := 'Casnati_M';		Bulk_X_Xec_List[36] := 'Pouchou_Pichoir_M';		Bulk_X_Xec_List[37] := 'Pouchou_M';		Bulk_X_Xec_List[38] := 'Rez';		Bulk_X_Xec_List[39] := 'Gryzinski_M';		Bulk_X_Xec_List[40] := 'Fabre_M';		Bulk_X_Xec_List[41] := 'Hehenkamp_Bocker';		Bulk_X_Xec_List[42] := '';		Bulk_X_Xec_List[43] := '';		Bulk_X_Xec_List[44] := '';		Bulk_X_Xec_List[45] := '';		Bulk_X_Xec_List[46] := '';		Bulk_X_Xec_List[47] := 'Small_Kramers_Normal';		Bulk_X_Xec_List[48] := 'Kramers';		Bulk_X_Xec_List[49] := 'Lifshin';		Bulk_X_Xec_List[50] := 'Smith_Gold';		Bulk_X_Xec_List[51] := 'Rao_Sahib_Wittry';  	END;	{with}  	END;		{Init_X-Sec_List}    PROCEDURE Physics_Initialize;                     { initialize everything for the program }	const	  SpinCursor1                   = 7;      SpinCursor2                   = 8;      SpinCursor3                   = 9;      SpinCursor4                   = 10;      SpinCursor5                   = 11;      SpinCursor6                   = 12;      SpinCursor7                   = 13;      SpinCursor8                   = 14;      SpinCursor9                   = 15;      SpinCursor10                  = 16;      SpinCursor11                  = 17;      SpinCursor12                  = 18;      SpinCursor13                  = 19;      VAR        index, nn                    : integer;        theError               		: osErr;		thePtr						 : SiLi_RecPtr;        str,str1                     : str255;      BEGIN                                           { Physics_initialize }                 IgnoreError := SetVol(NIL, 0);                { Paranoia }        IgnoreError := GetVol(NIL, MCA_VolRefNum);        In_VolRefNum := MCA_VolRefNum;        Out_VolRefNum := MCA_VolRefNum;		        over_flow_1; { bring in the x-rays }		over_flow_2;        load_energy_series;		        Scale_Button   :=    31;  {Auto Size the screen }		        Analysis_Results_Counter := 0;  		        Pi4 := 4.0 * Pi;        Pi2 := 2.0 * Pi;        PiRt := 1.0 / sqrt(Pi2);        aSigConst := 1.0 / (2.354825 * 2.354825);        theSigConst := 2.5 * aSigConst;        Make_Element_Symbols;        Load_Symbols;        Spectrum_Size := 1024;        ChannelMin := 1;        ChannelMax := 1024;        Old_ChannelMin := 1;        Old_ChannelMax := 1024;           New_Range := 1024;        Range_Keeper := 7;                            { 7 is 1024 }        Scratch := TENew(ScratchRect, ScratchRect);        TEActivate(Scratch);		(*Indices for the line codes - New version 본*)	Nm_Line[1] := 'KA1   '; {K}	Nm_Line[2] := 'KA2   '; {K}	Nm_Line[3] := 'KB1   '; {K}	Nm_Line[4] := 'KB2   '; {K}	Nm_Line[5] := 'KB3   '; {K}	Nm_Line[6] := 'KB4   '; {K}	Nm_Line[7] := 'KB5   '; {K}	Nm_Line[8] := 'L1-M1 ';	{LI}	Nm_Line[9] := 'L1-N1 ';	{LI}	Nm_Line[10] := 'L1-N4 ';	{LI}	Nm_Line[11] := 'L1-O1 ';	{LI}	Nm_Line[12] := 'L1-O4 ';	{LI}	Nm_Line[13] := 'LB10  ';  {M4	LI}	Nm_Line[14] := 'LB3   ';  {M3	LI}	Nm_Line[15] := 'LB4   ';  {M2	LI}	Nm_Line[16] := 'LB9   ';  {M5	LI}	Nm_Line[17] := 'LG11  ';  {N5	LI}	Nm_Line[18] := 'LG3   ';  {N3	LI}	Nm_Line[19] := 'LG4   ';  {O3	LI}	Nm_Line[20] := 'LG4`  ';  {O2	LI}	Nm_Line[21] := 'L2-M2 ';	{LII}	Nm_Line[22] := 'L2-M5 ';	{LII}	Nm_Line[23] := 'L2-N2 ';	{LII}	Nm_Line[24] := 'L2-N3 ';	{LII}	Nm_Line[25] := 'L2-N5 ';	{LII}	Nm_Line[26] := 'L2-O2 ';	{LII}	Nm_Line[27] := 'L2-O3 ';	{LII}	Nm_Line[28] := 'L2-P2 ';	{LII}	Nm_Line[29] := 'LB1   ';  {M4	LII}	Nm_Line[30] := 'LB17  ';  {M3	LII}	Nm_Line[31] := 'LG1   ';  {N4	LII}	Nm_Line[32] := 'LG5   ';  {N1	LII}	Nm_Line[33] := 'LG6   ';  {O4	LII}	Nm_Line[34] := 'LG8   ';  {O1	LII}	Nm_Line[35] := 'Ln    ';	{LII}	Nm_Line[36] := 'Lv    ';  {N6	LII}	Nm_Line[37] := 'L3-N2 ';	{LIII}	Nm_Line[38] := 'L3-N3 ';	{LIII}	Nm_Line[39] := 'L3-O2 ';	{LIII}	Nm_Line[40] := 'L3-O3 ';	{LIII}	Nm_Line[41] := 'L3-P1 ';	{LIII}	Nm_Line[42] := 'LA1   ';  {M5	LIII}	Nm_Line[43] := 'LA2   ';  {M4	LIII}	Nm_Line[44] := 'LB15  ';  {N4	LIII}	Nm_Line[45] := 'LB2   ';  {N5	LIII}	Nm_Line[46] := 'LB5   ';  {O4,O5	LIII}	Nm_Line[47] := 'LB6   ';  {N1	LIII}	Nm_Line[48] := 'LB7   ';  {O1	LIII}	Nm_Line[49] := 'Ll    ';  {M1	LIII}	Nm_Line[50] := 'Ls    ';  {M3	LIII}	Nm_Line[51] := 'Lt    ';  {M2	LIII}	Nm_Line[52] := 'Lu    ';  {N4,N7	LIII}	Nm_Line[53] := 'M1-N2 ';	{MI}	Nm_Line[54] := 'M1-N3 ';	{MI}	Nm_Line[55] := 'M2-M4 ';	{MII}	Nm_Line[56] := 'M2-N1 ';	{MII}	Nm_Line[57] := 'M2-N4 ';	{MII}	Nm_Line[58] := 'M2-O4 ';	{MII}	Nm_Line[59] := 'M3-M4 ';	{MIII}	Nm_Line[60] := 'M3-M5 ';	{MIII}	Nm_Line[61] := 'M3-N1 ';	{MIII}	Nm_Line[62] := 'M3-N4 ';	{MIII}	Nm_Line[63] := 'M3-O1 ';	{MIII}	Nm_Line[64] := 'M3-O4 ';	{MIII}	Nm_Line[65] := 'M3-O5 ';	{MIII}	Nm_Line[66] := 'MG    ';  {N5	MIII}	Nm_Line[67] := 'M4-N3 ';	{MIV}	Nm_Line[68] := 'M4-O2 ';	{MIV}	Nm_Line[69] := 'MB    ';  {N6	MIV}	Nm_Line[70] := 'MZ2   ';  {N2	MIV}	Nm_Line[71] := 'M5-O3 ';	{MV}	Nm_Line[72] := 'MA1   ';  {N7	MV}	Nm_Line[73] := 'MA2   ';  {N6	MV}	Nm_Line[74] := 'MZ1   ';  {N3	MV}	Nm_Line[75] := 'N4-N6 ';	{N4}	Nm_Line[76] := 'N5-N6 ';	{N5}	Nm_Line[77] := 'SKA   ';	{K}	Nm_Line[78] := 'SKA3  ';	{K}	Nm_Line[79] := 'SKA3` ';	{K}	Nm_Line[80] := 'SKA3``';	{K}	Nm_Line[81] := 'SKA4  ';	{K}	Nm_Line[82] := 'SKA5  ';	{K}	Nm_Line[83] := 'SKA6  ';	{K}	Nm_Line[84] := 'SKA7  ';	{K}	Nm_Line[85] := 'SKA8  ';	{K}	Nm_Line[86] := 'SKA9  ';	{K}	Nm_Line[87] := 'SKA`  ';	{K}	Nm_Line[88] := 'SKA`` ';	{K}	Nm_Line[89] := 'SKB   ';	{K}	Nm_Line[90] := 'SKB10 ';	{K}	Nm_Line[91] := 'SKB6  ';	{K}	Nm_Line[92] := 'SKB7  ';	{K}	Nm_Line[93] := 'SKB8  ';	{K}	Nm_Line[94] := 'SKB9  ';	{K}	Nm_Line[95] := 'SKB`  ';	{K}	Nm_Line[96] := 'SKB`` ';	{K}	Nm_Line[97] := 'SKBN  ';	{K}	Nm_Line[98] := 'SKBX  ';	{K}	Nm_Line[99] := 'SKB^4 ';	{K}	Nm_Line[100] := 'SKB^5 ';	{K}	Nm_Line[101] := 'SLA1^Z';	{LIII}	Nm_Line[102] := 'SLA2` ';	{LIII}	Nm_Line[103] := 'SLA3  ';	{LIII}	Nm_Line[104] := 'SLA3^Z';	{LIII}	Nm_Line[105] := 'SLA4  ';	{LIII}	Nm_Line[106] := 'SLA5  ';	{LIII}	Nm_Line[107] := 'SLA6  ';	{LIII}	Nm_Line[108] := 'SLA7  ';	{LIII}	Nm_Line[109] := 'SLA8  ';	{LIII}	Nm_Line[110] := 'SLA9  ';	{LIII}	Nm_Line[111] := 'SLAA  ';	{LIII}	Nm_Line[112] := 'SLA`  ';	{LIII}	Nm_Line[113] := 'SLAS  ';	{LIII}	Nm_Line[114] := 'SLA^IX';	{LIII}	Nm_Line[115] := 'SLA^X ';	{LIII}	Nm_Line[116] := 'SLA^Y ';	{LIII}	Nm_Line[117] := 'SLB2^1';	{LIII}	Nm_Line[118] := 'SLB2^2';	{LIII}	Nm_Line[119] := 'SLB2^3';	{LIII}	Nm_Line[120] := 'SLB2^4';	{LIII}	Nm_Line[121] := 'SLB2^5';	{LIII}	Nm_Line[122] := 'SLB2^7';	{LIII}	Nm_Line[123] := 'SLB2^A';	{LIII}	Nm_Line[124] := 'SLB2^B';	{LIII}	Nm_Line[125] := 'SLB2^C';	{LIII}	Nm_Line[126] := 'SLB5^1';	{LIII}	Nm_Line[127] := 'SLB5^2';	{LIII}	Nm_Line[128] := 'SLB14 ';	{LII}	Nm_Line[129] := 'SLB1``';	{LII}	Nm_Line[130] := 'SLB1^4';	{LII}	Nm_Line[131] := 'SLG10 ';	{LII}	Nm_Line[132] := 'SLG1` ';	{LII}	Nm_Line[133] := 'SLG2` ';	{LI}	Nm_Line[134] := 'SLG2``';	{LI}	Nm_Line[135] := 'SLG9 ';	{LI}	Nm_Line[136] := 'SMA^1';	{MV}	Nm_Line[137] := 'SMA^2';	{MV}	Nm_Line[138] := 'SMA^3';	{MV}	Nm_Line[139] := 'SMA^4';	{MV}	Nm_Line[140] := 'SMB1 ';	{MIV}	Nm_Line[141] := 'SMB2 ';	{MIV}	Nm_Line[142] := 'SMB3 ';	{MIV}	Nm_Line[143] := 'SMG` ';	{MIV   MIII}	Nm_Line[144] := 'LG2  ';	{N2	LI}		one:=1.0;		zero:=0.0;          		   FOR nn := 1 to Maximum_Channels do		   begin            Col_1^[nn] := 0.0;            Col_2^[nn] := 0.0;			Col_3^[nn] := 0.0;			Col_4^[nn] := 0.0;			Col_5^[nn] := 0.0;			Col_6^[nn] := 0.0;           end;                IF NOT RealFont(Symbol, 9) THEN		 PutEarlyMessage('Could not find the SYMBOL 9 font in your system.',		            'Consequently, the program cannot display greek symbols. Consider',					'installing this font into your system.','');		        FOR nn := 1 TO Max_Fitting_Chans DO begin        FitS^^.Gaussians[nn] := zero;        FitS^^.Residuals[nn] := zero;        FitS^^.FittedBkg[nn] := zero;		end;       FOR nn := 1 TO MaxNumPks DO periodic_picks[nn] := 1;	   Elements_Chosen := False;	   Number_of_Elements_Simplexed := 0;       Live_Time := 1000.0;                    { real for generating}	   Maximum_Iterations := 5000;         { Initialize all of the spectrum fields  }FOR nn := 1 to Maximum_Channels do Plt_spec[1]^^.S[nn] := 0.0;		 WITH Plt_spec[1]^^ DO BEGIN 	WITH Expt_Info DO	  BEGIN		Specimen_ID := 'Dummy';               { String[50] }		Specimen_Comment_Field :=             { do not put a cr in following text!! }		 'Enter here comments germane to the whole collection of spectra to be a part of this file.';		MCA_Filename           := ' ';		FirstSpec              := 1;		LastSpect              := 1;		Analyst                := 'Chuck';                       { String[50] }		RefFile				   := FALSE;		Detector.Spec          := EDS;                           { SiLi }		Detector.ID            := 1;                             { SiLi }		Azimuth                := -90.0 {zero};                          { Real, degrees }		Elevation              := 40.0;               { Real, degrees }		Detector_Area          :=10.0;               { Real, cm sq }		Detector_Thickness     := 3.0;                { Real, mm }		C_Thickness            := zero;                          { Real, um }		Diamond                := zero;                          { Real, um }		Quantum                := zero;                          { Real, um }		Al_Thickness           := zero;		Ice_Thickness          := 0.1;                { Real, um }		Au_Thickness           := 0.01;               { Real, um }		Be_Thickness           :=7.6;                { Real, um }		Si_Thickness           := 0.03;               { Real, um }		Si_Resolution          := 148.5;		BN_Thickness           := zero;		SiN_Thickness          := zero;		Mylar                  := zero;		Moxtek                 := zero;		Paralene               := zero;		Detector_Tilt          := 90;		dE                     := 10.0;                { Real }		Number_of_Channels     := Spectrum_Size;		kV                     := 20.000;             { Real }		Energy_Slope           := one;		Energy_Intercept       := zero;	  END;  { with Expt_Info }			  			              WITH SpectrumStuff.Spectrum_Info DO              BEGIN			    BkgSubtracted             := False;                Spectrum_Type             := ' ';                              Spectrum_Comment_Field    := 'X';                 { Str255 }                Spectrum_number           := 1;                Spectrum_Class            := '          ';        { String[10] }                Theoretically_Generated   := FALSE;               { Boolean }				This_is_a_Standard        := False;                Maximum_counts            := 10.0;                Minimum_counts            := zero;				X_Tilt                    := 0.0;				Y_Tilt                    := 0.0;				                Take_Off_Angle            := 40.0;     { Real, degrees }                Spec_Detector_Distance    := 15.0;     { Real, mm }                Specimen_Thickness        := 0.00001;  { Real, cm }                Specimen_Density          := 7.0;      { Real, g/cm sq. }                Number_of_Elements        := 0;                   { Integer }                FOR nn := 1 TO 15 DO                  BEGIN                    Element_Info[nn].Atomic_Number   := 0;                    Element_Info[nn].Weight_Fraction := zero;					Element_Info[nn].Valence         := zero;                  END;				WDS_in_eV				  := false;                END;                                    { with SpectrumStuff.Spectrum_Info }            WITH SpectrumStuff.Acq_Info DO              BEGIN                Probed_Area                            := zero;          { Real, cm sq. }                X_Position                             := zero;          { Real, um }                Y_Position                             := zero;          { Real, um }                Begin_Faraday                          := 1;  { Real, namps }                End_Faraday                            := 1;  { Real, namps }                GetDateTime( SpectrumStuff.Acq_Info.Begin_Time );   { temp load in current dateTime}                Real_Time                              := 1000.0;   { real secs }                Live_Time                              := 1000.0;   { real secs }                Slow_Channel_Counts                    := 0;             { Longint }                Medium_Channel_Counts                  := 0;             { Longint }                Fast_Channel_Counts                    := 0;             { Longint }				RequestedLiveTime                      := 1;             { Longint } 				ActualLiveTime                         := 1;             { Longint }								Acquiring                              := FALSE;         { Boolean }				LLD									   := 16;	{sdd}	 { Integer }								Offset								   :=  0;	{sdd}	 { Integer }				PulseProcessorType					   :=  1;	{sdd}	 { Integer }				PulseProcessorSetting				   :=  7;	{sdd}	 { Integer }				FirstChannel                 		   := 1;				LastChannel                  		   := 400;				FirstValue                   		   := 50.0;    { eg if WDS spectrum the begin lamda}				EndValue                     		   := 80.0;              END;                                    { with SpectrumStuff.Acq_Info }            WITH Plot_Info DO              BEGIN                Spectrum_Color.red := 0;                                Spectrum_Color.green := $FFFF;                            Spectrum_Color.blue := 0;                              END;                                    { with Plot_Info }          END;                                        { WITH Plt_Spec[1]^^ }         FOR index := 2 TO 10 DO BlockMove(@Plt_spec[1]^^, @Plt_spec[index]^^, Sizeof(Plt_spec[1]^^)); 				With theGenRec^^ do begin			   Detector.Spec          := EDS;                           { SiLi }			   Detector.ID            := 1;                             { SiLi }			   Azimuth                := -90.0 {zero};                          { Real, degrees }			   Elevation              := 40.0;               { Real, degrees }			   Detector_Area          := 10.0;               { Real, cm sq }			   Detector_Thickness     := 3.0;                { Real, mm }			   C_Thickness            := zero;                          { Real, um }			   Diamond                := zero;                          { Real, um }			   Quantum                := zero;                          { Real, um }			   Al_Thickness           := zero;			   Ice_Thickness          := 0.1;                { Real, um }			   Au_Thickness           := 0.01;               { Real, um }			   Be_Thickness           := 7.6;                { Real, um }			   Si_Thickness           := 0.03;               { Real, um }			   Si_Resolution          := 148.5;			   BN_Thickness           := zero;			   SiN_Thickness          := zero;			   Mylar                  := zero;			   Moxtek                 := zero;		{11/22/96}			   Paralene               := zero;		{11/22/96}			   Detector_Tilt          := 90;			   dE                     := 10.0;                { Real }			   Number_of_Channels     := Spectrum_Size;			   kV                     := 20.0000;             { Real }			   Energy_Slope           := one;			   Energy_Intercept       := zero;			   X_Tilt                    := 0.0;			   Y_Tilt                    := 0.0;							   Take_Off_Angle            := 40.0;     { Real, degrees }			   Spec_Detector_Distance    := 15.0;     { Real, mm }				end;	{ ...With theGenRec^^}				BlockMove(@theGenRec^^, @theBGRec^^, Sizeof(theBGRec^^)); 		theBGRec^^.Si_Thickness := 0.031; { Just to make it a little different to handle		                                               the case of no preferences }		          Analysis_Result^^.ExptStuff := Plt_spec[10]^^.Expt_Info;        Analysis_Result^^.SpectrumStuff := Plt_spec[10]^^.SpectrumStuff;		 		        WITH Analysis_Result^^ DO          BEGIN            WITH Fit_params, Fit_Result DO              BEGIN                Fit_Procedure := 'Sm'; {string[2]}				Toler := 0.00001;				DEN := 30.0;				DFWHMM := 4.0;				switch := 1000.0;                Chosen_ROI_Lo :=1450.0;                Chosen_ROI_Hi := 1540.0;                Chosen_Norm_Bkg := 0.0;                Number_of_Peaks := 0;                 {total in all windows}                FOR nn := 1 TO MaxNumPks DO           {the max number of windows is the same as 				                                       max number peaks }                  BEGIN                    First_in_Roi[nn] := 1;                    Fitting_Roi_Lo[nn] := 1;          {over windows}                    Fitting_Roi_Hi[nn] := 2;          {over windows}                    Atomic_Number[nn] := 26;                    Siegbahn[nn] := 'KA1  ';            {over peaks}                    Iterations[nn] := 1;              {over windows}                    Response[nn] := one;              {over windows}                    FWHM_Mn[nn] := 161.0;             {over windows}                    Area[nn] := zero;                    Err_or_Energy[nn] := 6.4;                    Peak_to_Local_Bkg[nn] := one;                    Peak_to_Chosen_Bkg[nn] := one;					conc[nn] := 1;                  END;              END;                                    { WITH Fit_Params, Fit_result }          END;                                        { WITH Analysis_Result^^ }		Geom.Beta_Angle := 90.0;		Geom.Spec_Det_Dist := 52.0;		Geom.Elevation_Angle := 40.0;        Geom.Azimuthal_Angle := -90.0 {zero};        Geom.X_Tilt_Angle := 0.0;        Geom.Y_Tilt_Angle := 0.0;		Geom.Angle_of_TakeOff :=  40.0;		Geom.Beam_Entry_Angle := 90.0;		Specimen_Thickness := 0.00001;		           { Real, cm }        theCursorHandle := GetCursor(watchCursor);        SetCursor(theCursorHandle^^);                 { set to watch cursor }        GasdevIset := 0;  { in random num gen }        WtSwitch := TRUE;        FOR nn := 1 TO Max_ROIs DO          BEGIN            ROI^^.Peak[nn].Lo := 1;            ROI^^.Peak[nn].Hi := 1;            ROI^^.Peak[nn].ROI := nn;                {Sets up a unique number for each ROI 			                                          seperate from the index}            ROI^^.Peak[nn].value := zero;            ROI^^.Peak[nn].Exists := FALSE;            ROI^^.BackGround[nn].Lo := 1;            ROI^^.BackGround[nn].Hi := 1;            ROI^^.BackGround[nn].ROI := nn;           {Sets up a unique number for each ROI 			                                           seperate from the index}            ROI^^.BackGround[nn].value := zero;            ROI^^.BackGround[nn].Exists := FALSE;          END;		          Chosen_Region := 1;        ROI^^.Scale.Lo := 1;        ROI^^.Scale.Hi := 1;        ROI^^.Scale.ROI := 1;        ROI^^.Scale.value := 0;        ROI^^.Scale.Exists := FALSE;        ROI^^.Quant.Lo := 145;        ROI^^.Quant.Hi := 154;        ROI^^.Quant.ROI := 1;        ROI^^.Quant.value := 0;        ROI^^.Quant.Exists := FALSE;			    Called_for_Generate   := False;	    Called_for_Work_Spec  := False;        Number_of_BackGrounds := 1;        Number_of_PeakRois := 1;					   Label_Counter := 0;			   Active_Peak_Label := 0;			   LabelSize := 9;        FOR nn := 0 TO MaxLabels DO          BEGIN            Lab^^.S[nn].Box.Top          := 10;			Lab^^.S[nn].Box.Bottom       := 20;			Lab^^.S[nn].Box.Left         := 10;			Lab^^.S[nn].Box.Right        := 30;			Lab^^.S[nn].Channel          := 100;			Lab^^.S[nn].ShiftedChannel   := 100;			Lab^^.S[nn].V_Scale_Top      := one;			Lab^^.S[nn].V_Scale_Bottom   := zero;					Lab^^.S[nn].XCenter          := 200;			Lab^^.S[nn].YCenter          := 200;            Lab^^.S[nn].Element          := '';			Lab^^.S[nn].Family           := '';			Lab^^.S[nn].Greek            := '';            Lab^^.S[nn].Exists           := False;			Lab^^.S[nn].Active           := False;          END;			Lab^^.L             := 'Hi, this is a test label';			Lab^^.XCenter       := 100;			Lab^^.YCenter       := 100;			Lab^^.Exists        := true;			Lab^^.Active        := FALSE;		          My := one;        FOR nn := 0 TO 2 * (Maximum_Channels) DO theFFTHdl^^.FFTdata[nn] := 0.0;		        For nn := 1 to Maximum_Channels do Bkg_P^[nn] := 0.0;   				For nn := 1 to Maximum_Channels do  Det_Effic_P^[nn] := 0.0;        SiLi_Response_Calculated := FALSE;		ItsBeenAcquired := FALSE;		SiLi_Buffer_Calculated := FALSE;				BlockMove(@Bkg_P^, @Gen_P^, Sizeof(Spectrum_counts));		BlockMove(@Bkg_P^, @Ob_Pks_P^, Sizeof(Spectrum_counts));		BlockMove(@Bkg_P^, @Composite_P^, Sizeof(Spectrum_counts));		 		BlockMove(@Det_Effic_P^, @Mu_rho_P^, Sizeof(Spectrum_counts)); 		BlockMove(@Det_Effic_P^, @f_Chi_P^, Sizeof(Spectrum_counts));		BlockMove(@Det_Effic_P^, @Gen_ResponseFnc^, Sizeof(Spectrum_counts));		BlockMove(@Det_Effic_P^, @Bkg_ResponseFnc^, Sizeof(Spectrum_counts));		          Analysis_result^^.fit_Params.constrained := False;        Constraint_Switch := FALSE;        Incomplete_Charge_Switch := FALSE;         Clear_Start_Acquire := FALSE;        Stop_Acquire := FALSE;        Continue_Acquire := FALSE;        Clear_Acquire := FALSE;        Acquisition_Seconds := 30;        { some of the following must be converted to cgs units where they are used }        Geom.Spec_Det_Dist := 52.5;						{convert by / 10}		thePtr := SiLi_RecPtr(NewPtr(sizeof(Sili_Rec)));				   if thePtr = NIL then				     begin					   SysBeep(1);				       putmessage('Not enough memory available for this operation',					   'The program must quit, please  do a "get info" and assign more memory to DTSA.','',''); 					   Halt;					 end;				thePtr := @Plt_Spec[10]^^.Expt_Info.Detector;		theGenRec^^ := thePtr^;		with theGenRec^^ do begin			Spec_Detector_Distance := Geom.Spec_Det_Dist;         	X_Tilt := Geom.X_Tilt_Angle;        	Y_Tilt := Geom.Y_Tilt_Angle;        	Take_Off_Angle := Geom.Angle_of_TakeOff ;			Si_Resolution := 145.0;			WDS_Resolution := 15.0;		end;		 		BlockMove(@theGenRec^^, @theBGRec^^, Sizeof(theBGRec^^));		DisposePtr(Ptr(thePtr));		thePtr := NIL;        Live_Time := 1000.0;        Faraday_Current := 0.5;                       {convert by * 1E-9}				FWHM     :=  145.0 ; { needed for convolver in assembler code }         dE := 10.0 ; { needed for convolver in assembler code }		 		FOR nn := 2 TO 15 DO          BEGIN            A^.Thin_At_Num[nn] := 0;            A^.Thin_Concentration[nn] := 0.0 ;            A^.Thin_valence[nn] := 0 ;            A^.Bulk_At_Num[nn] := 0;            A^.Bulk_Concentration[nn] := 0.0 ;            A^.Bulk_valence[nn] := 0 ;          END;        A^.Thin_At_Num[1] := 26;        A^.Thin_Concentration[1] :=  1.0 ;        A^.Thin_valence[1] := 2 ;        Thin_KV :=  100.0 ;                             { * 1000 }		Specimen_Thickness :=  0.00001 ;         Thin_Density := 7.87 ;        Bulk_Density :=  7.87 ;        tilt := 0.0;        A^.Bulk_At_Num[1] := 26;        A^.Bulk_Concentration[1] :=  1.0 ;        A^.Bulk_valence[1] := 2 ;        Bulk_KV :=  20.0 ;                              { * 1000 }        Begin_End := 0;        FOR index := 1 TO 10 DO          BEGIN            Spectrum_Full[index] := FALSE;            CheckItem(FullMenu, index, Spectrum_Full[index]);          END;        Log_Scale_Display := FALSE;        Bipolar_Display := FALSE;        Linear_Display := FALSE;        Square_Root_Display := FALSE;        Auto_Scale_Display := True;        Mouse_Function_Expand := FALSE;        Mouse_Function_Contract := FALSE;        Mouse_Vert_Expand := FALSE;        Mouse_Vert_Contract := FALSE;        ROI_Window_Active := FALSE;        SiLi_Window_Active := FALSE;        StripPeak_Window_Active := FALSE;        Calibrate_Window_Active := FALSE;        ID_Window_Active := FALSE;        Simplex_Results_Active := FALSE;        Windowtest := 0;         FOR nn := 1 TO 10 DO          BEGIN            A^.Plot_Symbol[nn] := 1;            A^.Plot_Connected[nn] := 1;          END;        Plt_spec[10]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[10]^^.Plot_Info.Spectrum_Color.green := 20108;        Plt_spec[10]^^.Plot_Info.Spectrum_Color.blue := $9D1D;        Plt_spec[9]^^.Plot_Info.Spectrum_Color.red := $A76E;        Plt_spec[9]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[9]^^.Plot_Info.Spectrum_Color.blue := 2604;        Plt_spec[8]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[8]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[8]^^.Plot_Info.Spectrum_Color.blue := $10;        Plt_spec[7]^^.Plot_Info.Spectrum_Color.red := $10;        Plt_spec[7]^^.Plot_Info.Spectrum_Color.green := $10;        Plt_spec[7]^^.Plot_Info.Spectrum_Color.blue := $FFFF;        Plt_spec[6]^^.Plot_Info.Spectrum_Color.red := $10;        Plt_spec[6]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[6]^^.Plot_Info.Spectrum_Color.blue := $10;        Plt_spec[5]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[5]^^.Plot_Info.Spectrum_Color.green := $10;        Plt_spec[5]^^.Plot_Info.Spectrum_Color.blue := $10;        Plt_spec[4]^^.Plot_Info.Spectrum_Color.red := 25000;        Plt_spec[4]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[4]^^.Plot_Info.Spectrum_Color.blue := 25000;        Plt_spec[3]^^.Plot_Info.Spectrum_Color.red := 15000;        Plt_spec[3]^^.Plot_Info.Spectrum_Color.green := 30000;        Plt_spec[3]^^.Plot_Info.Spectrum_Color.blue := $FFFF;        Plt_spec[2]^^.Plot_Info.Spectrum_Color.red := 5000;        Plt_spec[2]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[2]^^.Plot_Info.Spectrum_Color.blue := 30000;        Plt_spec[1]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[1]^^.Plot_Info.Spectrum_Color.green := 15000;        Plt_spec[1]^^.Plot_Info.Spectrum_Color.blue := 15000;        WITH SpectrumColor[1] DO   { the below are the actual spectra colors, 		                             the above are the headers }          BEGIN            red := $FFFF;            green := 15000;            blue := 15000;          END;        WITH SpectrumColor[2] DO          BEGIN            red := 5000;            green := $FFFF;            blue := 30000;          END;        WITH SpectrumColor[3] DO          BEGIN            red := 15000;            green := 30000;            blue := $FFFF;          END;        WITH SpectrumColor[4] DO          BEGIN            red := 25000;            green := $FFFF;            blue := 25000;          END;        WITH SpectrumColor[5] DO          BEGIN            red := $FFFF;            green := $10;            blue := $10;          END;        WITH SpectrumColor[6] DO          BEGIN            red := $10;            green := $FFFF;            blue := $10;          END;        WITH SpectrumColor[7] DO          BEGIN            red := $10;            green := $10;            blue := $FFFF;          END;        WITH SpectrumColor[8] DO          BEGIN            red := $FFFF;            green := $FFFF;            blue := $10;          END;        WITH SpectrumColor[10] DO          BEGIN            red := $FFFF;            green := 20108;            blue := $9D1D;          END;        WITH SpectrumColor[9] DO          BEGIN            red := $A76E;            green := $FFFF;            blue := 2604;          END;        WITH BackGround_Color DO          BEGIN            red := 688;            green := 1602;            blue := 23713;          END;        WITH PeakROI_Color DO          BEGIN            red := $FFFF;            green := $FFFF;            blue := $FFFF;          END;        WITH Text_Color DO          BEGIN            red := $FFFF;            green := $B9B3;            blue := 632;          END;        WITH BkgROI_Color DO          BEGIN            red := $A898;            blue := $C9F7;            green := $FDE8;          END;        WITH QuantROI_Color DO          BEGIN            red := $FDE8;            blue := $C9F7;            green := $A898;          END;        WITH ScaleROI_Color DO          BEGIN            red := 748;            green := $E023;            blue := $FFFF;          END;        WITH Axes_Color DO          BEGIN            red := 10;            green := $FFFF;            blue := 10;          END;        WITH KLMColor DO          BEGIN            red := $FFFF;            green := $FFFF;            blue := $FFFF;          END;        WITH PeakLabel_Color DO          BEGIN            red := $EC46;            green := $FDE8;            blue := 752;          END;        WITH Black_Color DO          BEGIN            red := 0;            green := 0;            blue := 0;          END;        WITH White_Color DO          BEGIN            red := - 1;            green := - 1;            blue := - 1;          END;                                        { critical in making copybits work }        V_Scale_Top := 2000.0;        V_Scale_Bottom := zero;        V_Scale_Top_Arrow := 2000.0;        V_Scale_Bottom_Arrow := zero;        ScratchPlot := FALSE;        Z := 26;        Floor_x := 0;        Ceiling := 200;        cursor_Position := 500;        {Temp := FrontWindow;}        Xtemp := 0;        Ytemp := 0;        Hloc := 10;        Vloc := 50;        Ticks := TickCount;                           {set up clock to seed RND}        Linear_Display := TRUE;        Mouse_Function_Expand := TRUE;        seed_y := TickCount - Ticks;                  { second seed for RND }        Blink_Timer := 1;        Blinker := FALSE;        Points_for_Smooth := 5;        Atomic_Number := 26;        Multiplier := zero;                           { The multiplier of column 2 in math window }        abort_x := FALSE;                               { For the exit test logic }        Num_of_Fits := 0;        ShowMarkers := true;        Center_Lobe := 14;        Left_Lobe := 7;        Right_Lobe := 7;        Arrow_Signer := + 1;        Thin_K_Xsect       := 7;        Bulk_K_Xsect       := 9;        Thin_L_Xsect       := 6;        Bulk_L_Xsect       := 6;        Thin_M_Xsect       := 7;        Bulk_M_Xsect       := 2;        Bulk_CONT_Xsect    := 4;        Thin_CONT_Xsect    := 7;        Bulk_CONT_Xsect_BG := 16;        Thin_CONT_Xsect_BG := 17;				        Thin_Fluor_Yield   := 3;        Bulk_Fluor_Yield   := 3;        Thin_Wk_Choice := 100;        Thin_Rslt_Choice := 0;        Thin_S1_Choice := 0;        Thin_S2_Choice := 0;        Thin_S3_Choice := 0;        Thin_S4_Choice := 0;        Thin_S5_Choice := 0;        Thin_S6_Choice := 0;        Thin_S7_Choice := 0;        Thin_S8_Choice := 0;        Bulk_Wk_Choice := 100;        Bulk_Rslt_Choice := 0;        Bulk_S1_Choice := 0;        Bulk_S2_Choice := 0;        Bulk_S3_Choice := 0;        Bulk_S4_Choice := 0;        Bulk_S5_Choice := 0;        Bulk_S6_Choice := 0;        Bulk_S7_Choice := 0;        Bulk_S8_Choice := 0;        Bulk_K_ScaleFactor := one;        Bulk_L_ScaleFactor := one;        Bulk_M_ScaleFactor := one;        Bulk_CONT_ScaleFactor := one;        Thin_K_ScaleFactor := one;        Thin_L_ScaleFactor := one;        Thin_M_ScaleFactor := one;        Thin_CONT_ScaleFactor := one;        Running_Bulk_Mode := FALSE;        Running_Thin_Mode := TRUE;        K_Peak_2_Bkg := FALSE;        L_Peak_2_Bkg := FALSE;        M_Peak_2_Bkg := FALSE;		OneShot := FALSE;		Nearest_K := TRUE;		Nearest_L := FALSE;		Nearest_M := FALSE;		Clr_One := FALSE;        Clr_Family := FALSE;	    Last_Label_Element := '';	    Last_Label_Family  := '';        Lab_Left_Limit     := 0;		Lab_right_Limit    := 0;        Expert_got_Clicked := FALSE;        Expert := TRUE;        {CheckItem(ManageMenu, Expert_Mode, Expert);}   { Check }        KLM_Boolean := FALSE;        Scale_Changed_Event := False;        FOR index := 1 TO 10 DO          BEGIN            A^.DataMaxS[index] := 100;            A^.DataMinS[index] := 0;          END;        FOR index := 1 TO 11 DO A^.Spectrum_Class_Holding_String[index] := '   ';		A^.Spectrum_Class_Holding_String[12] := 'bulk';		A^.Spectrum_Class_Holding_String[13] := 'film';		No_Header_in_Print := FALSE;		{2/16/94}        VLabelColor := 10;        BoxLeft := 500;        BoxTop := 30;        XCenter := BoxLeft + 45;        YCenter := BoxTop + 7;		BoxLeft := XCenter - 40;		BoxTop := YCenter - 7 ;			SetRect(BoxRect, BoxLeft, BoxTop, BoxLeft + 108, BoxTop + 10);		BoxVisable:=False;        DragBox := FALSE;        DragLabel := FALSE;        Spectrum_Counter := 0;        OldBox.Left := 1;		OldBox.Right := 2;		OldBox.Top := 1;		OldBox.Bottom := 2;        Fit_Invisibly := FALSE;        InitCursor;        MCA_Spectrum_Active := FALSE;		        SpecWork_has_been_Changed := FALSE;				One_Label                := True;		Some_Labels              := FALSE;		All_Labels               := FALSE;                High_Peak_Meas :=  8047.78;						 { These are Cu KA1 and LA1,2 }        High_Peak_Book :=  8047.78;        Low_Peak_Meas :=  929.7;        Low_Peak_Book :=  929.7;        NM_Alpha :=  1.00;			                    { Original Nelder-Meade Coefficients }        NM_Beta := 0.5;        NM_Gamma := 2.0;        Amp_Perturb := 0.2;        Energy_Perturb :=  0.001;        Width_Perturb := 0.01;        Energy_Estimate := 20.0;			            { The Duane-Hunt SWL estimate }        Num_Noise_Spectra := 25;        PlainName := 'CurveFitResults';        Plain_Boolean := FALSE;        Spread_Boolean := FALSE;        MCA_File_Boolean := FALSE;        Bulk_Physics_Boolean := FALSE;        Thin_Physics_Boolean := FALSE;		BG_Active	:= False;		Normal_Output := True;		Reduced_Output := FALSE;        IgnoreError := SetVol(NIL, 0);                { Paranoia }        IgnoreError := GetVol(NIL, MCA_VolRefNum);        In_VolRefNum := MCA_VolRefNum;        Out_VolRefNum := MCA_VolRefNum;        Mu_Choice := 1;		is_batch := false;        Results_Added  := FALSE;        Simplex_Active := FALSE;        LLSQ_Active    := FALSE;		MarkerPopup := 1 ;		Marker_Sums     := True ;	    Marker_Escapes  := True ;	    Marker_Peaks    := True ;	    Marker_Edges    := False ;		Marker_WDS      := False ;        Marker_Counter := 68;        Old_LowerVert := '';        Old_Label := '';        Old_UpperVert := '';		Old_RightHoriz := '';        Old_LeftHoriz := '';	    Old_Work := -1;	    Old_Results := -1;		OldSpec1 := -1;		OldSpec2 := -1;		OldSpec3 := -1;		OldSpec4 := -1;		OldSpec5 := -1;		OldSpec6 := -1;		OldSpec7 := -1;		OldSpec8 := -1;		OldChan_Num := -1;        Old_Atomic_Number := 1;		 		WDS_BgnEDS	               := 1; 		WDS_EndLam	               := 2; 		WDS_EndWDS	               := 1000;   		WDS_BgnLam	               := 1; 		WDS_BgnWDS	               := 1;   		WDS_Two_d 	               := 4.0267;		WDS_d_Lambda               := 0.0001;		WDS_Angstroms              := False;		WDS_Sin_Theta              := False;		WDS_millimeters            := True;		WDS_Convert_X_and_Y_axis   := True; 		WDS_Convert_only_X_axis    := True;		WDS_MYR 	               := 80.0; 		WDS_NaCl 	               := 5.638; 		WDS_KAP 	               := 26.64; 		WDS_RAP 	               := 26.1; 		WDS_TAP 	               := 25.757; 		WDS_PET 	               := 8.742; 		WDS_LiF 	               := 4.0267; 		WDS_LOD 	               :=  1; 		WDS_LDE1 	               :=  59.8; 		WDS_V_C 	               :=  97.0; 		WDS_MoB4C 	               :=  144.6; 		WDS_SiO2_1011 	           :=  6.686; 		WDS_SiO2_1010 	           :=  8.51; 		WDS_Si    	               :=  6.272; 		WDS_Graphite 	           := 13.4; 		WDS_Pb_Stearate 	       :=  100.4; 		WDS_Mica  	               :=  19.86; 		WDS_EDDT  	               :=  8.804; 		WDS_User1 	               :=  1; 		WDS_User2 	               :=  1;			Calibrate_Energy_Scale     := False;		Cal_vals.energy_slope := 1.0;		Cal_vals.energy_intercept := 0.0;		Xray_Data_Request		   := true; 			for nn := 1 to 20 do begin			  A^.GR[nn] := 0; 			  A^.IZ[nn] := 0;                        		end;       gloldm                       := -1.0; { double_t }	  ZAF_Active                   := False;	  ZAF_Run					   := False;	  citZAF_Active				   := False;	  Cit_Particle_Active		   := False;	  citZAF_Run				   := False;	  Hall_Active                  := False;	  Whole_Cell_Active            := False;	  Cliff_Lorimer_Active         := False;	  Standardless_Active          := False;	  Do_Fit_Results			   := False;      Active_Chemical_Scale        := 1; { weight fraction }      	  	  Clmn1 := 10;   { in calculator }	  Clmn2 := 9;	  Clmn3 := 1;	  WW    := 1.0 {one};	  XX    := zero;	  YY    := zero;	  ZZ    := zero; 	  DebugerON := False;	  Attach_Fields_to_Ascii_Spectrum := False;	  MouseUp_Waiting := False;	  	  {Load and lock all cursors from resource file}	  CursH := GetCursor(FlatHandCursor); HLock(Handle(CursH)); DragC := Ptr(CursH^); 	  CursH := GetCursor(ArrowCursor);    HLock(Handle(CursH)); ArrowC := Ptr(CursH^); 	  CursH := GetCursor(SpinCursor1);  HLock(Handle(CursH)); SpinC1 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor2);  HLock(Handle(CursH)); SpinC2 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor3);  HLock(Handle(CursH)); SpinC3 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor4);  HLock(Handle(CursH)); SpinC4 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor5);  HLock(Handle(CursH)); SpinC5 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor6);  HLock(Handle(CursH)); SpinC6 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor7);  HLock(Handle(CursH)); SpinC7 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor8);  HLock(Handle(CursH)); SpinC8 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor9);  HLock(Handle(CursH)); SpinC9 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor10); HLock(Handle(CursH)); SpinC10 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor11); HLock(Handle(CursH)); SpinC11 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor12); HLock(Handle(CursH)); SpinC12 := Ptr(CursH^);	  CursH := GetCursor(SpinCursor13); HLock(Handle(CursH)); SpinC13 := Ptr(CursH^);	   Choice_of_Display := 3; Choice_of_Family := 5; Choice_of_Units := 3;       Pierson_Num :=  0.0000002 ;	 Shift_amount := zero;	 Fat_amount := zero;	 Strip_Refs_Active := False;	std4  := 0.04;	std3  := 0.02;	Diff_gain := 50000;	mintofit := 20;	 Number_of_Spectra := 1;	saved_displayed := false; 		 thePrRec := GetPrintRecord(MCA_Home_Res_RefNum);	  	 IF thePrRec = NIL THEN 		BEGIN 		 thePrRec := THPrint(NewHandle(SIZEOF(TPrint)));         PrOpen; 			theError := PrError;	         IF theError <> noErr THEN PrClose; { Close the Printing Manager before attempting to report the error.} 			    numtostring(theError,str1);				str := 'Unknown Error'; 			   if theError = -1  then str := 'saving print file';			   if theError = -17 then str := 'unimplemented control instruction';			   if theError = -27 then str := 'I/O error';			   if theError = -108 then str := 'not enough room in heap zone';			   if theError = 128 then str := 'application or user requested abort';			   if theError = -4101  then str := 'Printer not found or closed';			   if theError = -4100  then str := 'Connection just closed';			   if theError = -4099  then str := 'Write request too big ';			   if theError = -4098  then str := 'Request already active';			   if theError = -4097  then str := 'Bad connection refnum';			   if theError = -4096  then str := 'No free CCBs (Connect Control Blocks) available';			   if theError = -8133  then str := 'PostScript error occurred during transmission';			   if theError = -8132  then str := 'Timeout occured.';	        IF theError <> noErr THEN putmessage('There was trouble getting a print record at 4, the message was:',			           str,'The number was',str1);           Marker_Plot := False;        IF theError = noErr          THEN            BEGIN			 PrintDefault(thePrRec);            END;		  PrClose;	         END;     RdBinaryName := 'none';    WrtBinaryName := 'none';		Read_DTSA_Spec.name := 'none';			{본New DTSA file spec본}	Write_DTSA_Spec.name := 'none';			{본New DTSA file spec본}	RefSpec.name := 'none';					{본New DTSA file spec본}	SERIAL_Active := false;					{본New DTSA file spec본}	  FOR nn := 1 TO 10 DO		BEGIN		  Gaussian_Energy[nn] := zero;		  Gaussian_Width[nn] := zero;		  Gaussian_Amplitude[nn] := zero;		END;	  Gaussian_Energy[1] :=  5000.0 ;	  Gaussian_Width[1] :=  140.0 ;	  Gaussian_Amplitude[1] :=  1000.0 ;			DataBase_Open := FALSE;	OpenNew_Database := False;	Database_Name := ' ';	Do_it_in_the_Dark := false;    search_Range := 20.0;		Comp_handles := false;		{ ## comp database handles ## }	Majors       := True;	Minors       := False;	Satellites   := False;	WDS_Active := False;	WDS_Fitting_Resolution := 10.0;	Ready_to_Save_WDS := False;  	Ge_Active := False; 	Si_Active := True;     One_Coeff                 := 0.000002;    Two_Coeff                 := 1.0; 	ln2 := ln(2.0);	f_size    := 15;    sensi     := 2.5;	Use_Manual_ROIs := False;	Kill_citZAF := False;	EDS_eV := 140.0; { holding variable }	WDS_eV := 1.0;   { holding variable }	See_fit := False;	SkipFam := NIL;	Skip_Some := false;	do_ascii := false;    CL_Output := NIL;	CL_BsSetup^^.Report_oxides := false;	CL_BsSetup^^.ox_by_Stoic := false;	CL_BsSetup^^.relative_error := 3.0;	for index := 1 to MaxNumPks do CL_Setup[index] := NIL;	Do_HallOutput := false;	Do_CLOutput := false;	QC_Enabled := false;	QC_running := false;	QC_SEM := true;		Init_X_Sec_List;	      END;                                            { of proc Physics_Initialize }END.